/* tslint:disable */
/* eslint-disable */
/**
 * Discord HTTP API (Preview) - REST API Client
 * Preview of the Discord v10 HTTP API specification. See https://discord.com/developers/docs for more details.
 * 
 * ## Metadata
 *   
 * - **Copyright**: Copyright (c) 2025 Qntx
 * - **Author**: ΣX <gitctrlx@gmail.com>
 * - **Version**: 10
 * - **Modified**: 2025-07-01T10:27:27.556630340Z[Etc/UTC]
 * - **Generator Version**: 7.14.0
 *
 * <details>
 * <summary><strong>⚠️ Important Disclaimer & Limitation of Liability</strong></summary>
 * <br>
 * > **IMPORTANT**: This software is provided "as is" without any warranties, express or implied, including but not limited
 * > to warranties of merchantability, fitness for a particular purpose, or non-infringement. The developers, contributors,
 * > and licensors (collectively, "Developers") make no representations regarding the accuracy, completeness, or reliability
 * > of this software or its outputs.
 * >
 * > This client is not intended to provide financial, investment, tax, or legal advice. It facilitates interaction with the
 * > Discord HTTP API (Preview) service but does not endorse or recommend any financial actions, including the purchase, sale, or holding of
 * > financial instruments (e.g., stocks, bonds, derivatives, cryptocurrencies). Users must consult qualified financial or
 * > legal professionals before making decisions based on this software's outputs.
 * >
 * > Financial markets are inherently speculative and carry significant risks. Using this software in trading, analysis, or
 * > other financial activities may result in substantial losses, including total loss of capital. The Developers are not
 * > liable for any losses or damages arising from such use. Users assume full responsibility for validating the software's
 * > outputs and ensuring their suitability for intended purposes.
 * >
 * > This client may rely on third-party data or services (e.g., market feeds, APIs). The Developers do not control or verify
 * > the accuracy of these services and are not liable for any errors, delays, or losses resulting from their use. Users must
 * > comply with third-party terms and conditions.
 * >
 * > Users are solely responsible for ensuring compliance with all applicable financial, tax, and regulatory requirements in
 * > their jurisdiction. This includes obtaining necessary licenses or approvals for trading or investment activities. The
 * > Developers disclaim liability for any legal consequences arising from non-compliance.
 * >
 * > To the fullest extent permitted by law, the Developers shall not be liable for any direct, indirect, incidental,
 * > consequential, or punitive damages arising from the use or inability to use this software, including but not limited to
 * > loss of profits, data, or business opportunities.
 *
 * </details>
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccountResponse
 */
export interface AccountResponse {
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface ActionRowComponentForMessageRequest
 */
export interface ActionRowComponentForMessageRequest {
    /**
     * 
     * @type {number}
     * @memberof ActionRowComponentForMessageRequest
     */
    'type': number;
    /**
     * 
     * @type {Array<ActionRowComponentForMessageRequestComponentsInner>}
     * @memberof ActionRowComponentForMessageRequest
     */
    'components': Array<ActionRowComponentForMessageRequestComponentsInner>;
}
/**
 * @type ActionRowComponentForMessageRequestComponentsInner
 * @export
 */
export type ActionRowComponentForMessageRequestComponentsInner = ButtonComponentForMessageRequest | ChannelSelectComponentForMessageRequest | MentionableSelectComponentForMessageRequest | RoleSelectComponentForMessageRequest | StringSelectComponentForMessageRequest | UserSelectComponentForMessageRequest;

/**
 * 
 * @export
 * @interface ActionRowComponentForModalRequest
 */
export interface ActionRowComponentForModalRequest {
    /**
     * 
     * @type {number}
     * @memberof ActionRowComponentForModalRequest
     */
    'type': number;
    /**
     * 
     * @type {Array<TextInputComponentForModalRequest>}
     * @memberof ActionRowComponentForModalRequest
     */
    'components': Array<TextInputComponentForModalRequest>;
}
/**
 * 
 * @export
 * @interface ActionRowComponentResponse
 */
export interface ActionRowComponentResponse {
    /**
     * 
     * @type {number}
     * @memberof ActionRowComponentResponse
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof ActionRowComponentResponse
     */
    'id': number;
    /**
     * 
     * @type {Array<ActionRowComponentResponseComponentsInner>}
     * @memberof ActionRowComponentResponse
     */
    'components'?: Array<ActionRowComponentResponseComponentsInner> | null;
}
/**
 * @type ActionRowComponentResponseComponentsInner
 * @export
 */
export type ActionRowComponentResponseComponentsInner = ButtonComponentResponse | ChannelSelectComponentResponse | MentionableSelectComponentResponse | RoleSelectComponentResponse | StringSelectComponentResponse | TextInputComponentResponse | UserSelectComponentResponse;

/**
 * 
 * @export
 * @interface ActivitiesAttachmentResponse
 */
export interface ActivitiesAttachmentResponse {
    /**
     * 
     * @type {AttachmentResponse}
     * @memberof ActivitiesAttachmentResponse
     */
    'attachment': AttachmentResponse;
}
/**
 * @type AddGroupDmUser201Response
 * @export
 */
export type AddGroupDmUser201Response = PrivateChannelResponse | PrivateGroupChannelResponse;

/**
 * 
 * @export
 * @interface AddGroupDmUserRequest
 */
export interface AddGroupDmUserRequest {
    /**
     * 
     * @type {string}
     * @memberof AddGroupDmUserRequest
     */
    'access_token'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddGroupDmUserRequest
     */
    'nick'?: string | null;
}
/**
 * 
 * @export
 * @interface AddGuildMemberRequest
 */
export interface AddGuildMemberRequest {
    /**
     * 
     * @type {string}
     * @memberof AddGuildMemberRequest
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof AddGuildMemberRequest
     */
    'nick'?: string | null;
    /**
     * 
     * @type {Set<string | null>}
     * @memberof AddGuildMemberRequest
     */
    'roles'?: Set<string | null> | null;
    /**
     * 
     * @type {boolean}
     * @memberof AddGuildMemberRequest
     */
    'mute'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof AddGuildMemberRequest
     */
    'deaf'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof AddGuildMemberRequest
     */
    'flags'?: number | null;
}
/**
 * 
 * @export
 * @interface AddLobbyMemberRequest
 */
export interface AddLobbyMemberRequest {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AddLobbyMemberRequest
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof AddLobbyMemberRequest
     */
    'flags'?: AddLobbyMemberRequestFlagsEnum | null;
}

export const AddLobbyMemberRequestFlagsEnum = {
    NUMBER_1: 1
} as const;

export type AddLobbyMemberRequestFlagsEnum = typeof AddLobbyMemberRequestFlagsEnum[keyof typeof AddLobbyMemberRequestFlagsEnum];

/**
 * 
 * @export
 * @interface ApplicationCommandAttachmentOption
 */
export interface ApplicationCommandAttachmentOption {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandAttachmentOption
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandAttachmentOption
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandAttachmentOption
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandAttachmentOption
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandAttachmentOption
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandAttachmentOption
     */
    'required'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ApplicationCommandAttachmentOptionResponse
 */
export interface ApplicationCommandAttachmentOptionResponse {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandAttachmentOptionResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandAttachmentOptionResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandAttachmentOptionResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandAttachmentOptionResponse
     */
    'name_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandAttachmentOptionResponse
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandAttachmentOptionResponse
     */
    'description_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandAttachmentOptionResponse
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandAttachmentOptionResponse
     */
    'required'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ApplicationCommandAutocompleteCallbackRequest
 */
export interface ApplicationCommandAutocompleteCallbackRequest {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandAutocompleteCallbackRequest
     */
    'type': number | null;
    /**
     * 
     * @type {ApplicationCommandAutocompleteCallbackRequestData}
     * @memberof ApplicationCommandAutocompleteCallbackRequest
     */
    'data': ApplicationCommandAutocompleteCallbackRequestData;
}
/**
 * 
 * @export
 * @interface ApplicationCommandAutocompleteCallbackRequestData
 */
export interface ApplicationCommandAutocompleteCallbackRequestData {
    /**
     * 
     * @type {Array<ApplicationCommandOptionStringChoice>}
     * @memberof ApplicationCommandAutocompleteCallbackRequestData
     */
    'choices'?: Array<ApplicationCommandOptionStringChoice>;
}
/**
 * 
 * @export
 * @interface ApplicationCommandBooleanOption
 */
export interface ApplicationCommandBooleanOption {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandBooleanOption
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandBooleanOption
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandBooleanOption
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandBooleanOption
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandBooleanOption
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandBooleanOption
     */
    'required'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ApplicationCommandBooleanOptionResponse
 */
export interface ApplicationCommandBooleanOptionResponse {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandBooleanOptionResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandBooleanOptionResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandBooleanOptionResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandBooleanOptionResponse
     */
    'name_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandBooleanOptionResponse
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandBooleanOptionResponse
     */
    'description_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandBooleanOptionResponse
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandBooleanOptionResponse
     */
    'required'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ApplicationCommandChannelOption
 */
export interface ApplicationCommandChannelOption {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandChannelOption
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandChannelOption
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandChannelOption
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandChannelOption
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandChannelOption
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandChannelOption
     */
    'required'?: boolean | null;
    /**
     * 
     * @type {Set<number>}
     * @memberof ApplicationCommandChannelOption
     */
    'channel_types'?: Set<number> | null;
}
/**
 * 
 * @export
 * @interface ApplicationCommandChannelOptionResponse
 */
export interface ApplicationCommandChannelOptionResponse {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandChannelOptionResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandChannelOptionResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandChannelOptionResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandChannelOptionResponse
     */
    'name_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandChannelOptionResponse
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandChannelOptionResponse
     */
    'description_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandChannelOptionResponse
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandChannelOptionResponse
     */
    'required'?: boolean | null;
    /**
     * 
     * @type {Set<number>}
     * @memberof ApplicationCommandChannelOptionResponse
     */
    'channel_types'?: Set<number> | null;
}
/**
 * 
 * @export
 * @interface ApplicationCommandCreateRequest
 */
export interface ApplicationCommandCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandCreateRequest
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandCreateRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandCreateRequest
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ApplicationCommandCreateRequestOptionsInner>}
     * @memberof ApplicationCommandCreateRequest
     */
    'options'?: Array<ApplicationCommandCreateRequestOptionsInner> | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandCreateRequest
     */
    'default_member_permissions'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandCreateRequest
     */
    'dm_permission'?: boolean | null;
    /**
     * 
     * @type {Set<number>}
     * @memberof ApplicationCommandCreateRequest
     */
    'contexts'?: Set<number> | null;
    /**
     * 
     * @type {Set<number>}
     * @memberof ApplicationCommandCreateRequest
     */
    'integration_types'?: Set<number> | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandCreateRequest
     */
    'handler'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandCreateRequest
     */
    'type'?: number;
}
/**
 * @type ApplicationCommandCreateRequestOptionsInner
 * @export
 */
export type ApplicationCommandCreateRequestOptionsInner = ApplicationCommandAttachmentOption | ApplicationCommandBooleanOption | ApplicationCommandChannelOption | ApplicationCommandIntegerOption | ApplicationCommandMentionableOption | ApplicationCommandNumberOption | ApplicationCommandRoleOption | ApplicationCommandStringOption | ApplicationCommandSubcommandGroupOption | ApplicationCommandSubcommandOption | ApplicationCommandUserOption;

/**
 * 
 * @export
 * @interface ApplicationCommandIntegerOption
 */
export interface ApplicationCommandIntegerOption {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandIntegerOption
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandIntegerOption
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandIntegerOption
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandIntegerOption
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandIntegerOption
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandIntegerOption
     */
    'required'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandIntegerOption
     */
    'autocomplete'?: boolean | null;
    /**
     * 
     * @type {Array<ApplicationCommandOptionIntegerChoice>}
     * @memberof ApplicationCommandIntegerOption
     */
    'choices'?: Array<ApplicationCommandOptionIntegerChoice> | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandIntegerOption
     */
    'min_value'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandIntegerOption
     */
    'max_value'?: number;
}
/**
 * 
 * @export
 * @interface ApplicationCommandIntegerOptionResponse
 */
export interface ApplicationCommandIntegerOptionResponse {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandIntegerOptionResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandIntegerOptionResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandIntegerOptionResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandIntegerOptionResponse
     */
    'name_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandIntegerOptionResponse
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandIntegerOptionResponse
     */
    'description_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandIntegerOptionResponse
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandIntegerOptionResponse
     */
    'required'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandIntegerOptionResponse
     */
    'autocomplete'?: boolean | null;
    /**
     * 
     * @type {Array<ApplicationCommandOptionIntegerChoiceResponse>}
     * @memberof ApplicationCommandIntegerOptionResponse
     */
    'choices'?: Array<ApplicationCommandOptionIntegerChoiceResponse> | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandIntegerOptionResponse
     */
    'min_value'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandIntegerOptionResponse
     */
    'max_value'?: number;
}
/**
 * 
 * @export
 * @interface ApplicationCommandInteractionMetadataResponse
 */
export interface ApplicationCommandInteractionMetadataResponse {
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandInteractionMetadataResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandInteractionMetadataResponse
     */
    'type': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandInteractionMetadataResponse
     */
    'authorizing_integration_owners': { [key: string]: string; };
    /**
     * 
     * @type {UserResponse}
     * @memberof ApplicationCommandInteractionMetadataResponse
     */
    'user'?: UserResponse | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandInteractionMetadataResponse
     */
    'original_response_message_id'?: string;
    /**
     * 
     * @type {UserResponse}
     * @memberof ApplicationCommandInteractionMetadataResponse
     */
    'target_user'?: UserResponse | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandInteractionMetadataResponse
     */
    'target_message_id'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationCommandMentionableOption
 */
export interface ApplicationCommandMentionableOption {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandMentionableOption
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandMentionableOption
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandMentionableOption
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandMentionableOption
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandMentionableOption
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandMentionableOption
     */
    'required'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ApplicationCommandMentionableOptionResponse
 */
export interface ApplicationCommandMentionableOptionResponse {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandMentionableOptionResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandMentionableOptionResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandMentionableOptionResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandMentionableOptionResponse
     */
    'name_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandMentionableOptionResponse
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandMentionableOptionResponse
     */
    'description_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandMentionableOptionResponse
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandMentionableOptionResponse
     */
    'required'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ApplicationCommandNumberOption
 */
export interface ApplicationCommandNumberOption {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandNumberOption
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandNumberOption
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandNumberOption
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandNumberOption
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandNumberOption
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandNumberOption
     */
    'required'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandNumberOption
     */
    'autocomplete'?: boolean | null;
    /**
     * 
     * @type {Array<ApplicationCommandOptionNumberChoice>}
     * @memberof ApplicationCommandNumberOption
     */
    'choices'?: Array<ApplicationCommandOptionNumberChoice> | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandNumberOption
     */
    'min_value'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandNumberOption
     */
    'max_value'?: number | null;
}
/**
 * 
 * @export
 * @interface ApplicationCommandNumberOptionResponse
 */
export interface ApplicationCommandNumberOptionResponse {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandNumberOptionResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandNumberOptionResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandNumberOptionResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandNumberOptionResponse
     */
    'name_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandNumberOptionResponse
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandNumberOptionResponse
     */
    'description_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandNumberOptionResponse
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandNumberOptionResponse
     */
    'required'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandNumberOptionResponse
     */
    'autocomplete'?: boolean | null;
    /**
     * 
     * @type {Array<ApplicationCommandOptionNumberChoiceResponse>}
     * @memberof ApplicationCommandNumberOptionResponse
     */
    'choices'?: Array<ApplicationCommandOptionNumberChoiceResponse> | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandNumberOptionResponse
     */
    'min_value'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandNumberOptionResponse
     */
    'max_value'?: number | null;
}
/**
 * 
 * @export
 * @interface ApplicationCommandOptionIntegerChoice
 */
export interface ApplicationCommandOptionIntegerChoice {
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandOptionIntegerChoice
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandOptionIntegerChoice
     */
    'value': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandOptionIntegerChoice
     */
    'name_localizations'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ApplicationCommandOptionIntegerChoiceResponse
 */
export interface ApplicationCommandOptionIntegerChoiceResponse {
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandOptionIntegerChoiceResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandOptionIntegerChoiceResponse
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandOptionIntegerChoiceResponse
     */
    'name_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandOptionIntegerChoiceResponse
     */
    'name_localizations'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ApplicationCommandOptionNumberChoice
 */
export interface ApplicationCommandOptionNumberChoice {
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandOptionNumberChoice
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandOptionNumberChoice
     */
    'value': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandOptionNumberChoice
     */
    'name_localizations'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ApplicationCommandOptionNumberChoiceResponse
 */
export interface ApplicationCommandOptionNumberChoiceResponse {
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandOptionNumberChoiceResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandOptionNumberChoiceResponse
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandOptionNumberChoiceResponse
     */
    'name_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandOptionNumberChoiceResponse
     */
    'name_localizations'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ApplicationCommandOptionStringChoice
 */
export interface ApplicationCommandOptionStringChoice {
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandOptionStringChoice
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandOptionStringChoice
     */
    'value': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandOptionStringChoice
     */
    'name_localizations'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ApplicationCommandOptionStringChoiceResponse
 */
export interface ApplicationCommandOptionStringChoiceResponse {
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandOptionStringChoiceResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandOptionStringChoiceResponse
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandOptionStringChoiceResponse
     */
    'name_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandOptionStringChoiceResponse
     */
    'name_localizations'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ApplicationCommandPatchRequestPartial
 */
export interface ApplicationCommandPatchRequestPartial {
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandPatchRequestPartial
     */
    'name'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandPatchRequestPartial
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandPatchRequestPartial
     */
    'description'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandPatchRequestPartial
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ApplicationCommandCreateRequestOptionsInner>}
     * @memberof ApplicationCommandPatchRequestPartial
     */
    'options'?: Array<ApplicationCommandCreateRequestOptionsInner> | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandPatchRequestPartial
     */
    'default_member_permissions'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandPatchRequestPartial
     */
    'dm_permission'?: boolean | null;
    /**
     * 
     * @type {Set<number>}
     * @memberof ApplicationCommandPatchRequestPartial
     */
    'contexts'?: Set<number> | null;
    /**
     * 
     * @type {Set<number>}
     * @memberof ApplicationCommandPatchRequestPartial
     */
    'integration_types'?: Set<number> | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandPatchRequestPartial
     */
    'handler'?: number;
}
/**
 * 
 * @export
 * @interface ApplicationCommandPermission
 */
export interface ApplicationCommandPermission {
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandPermission
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandPermission
     */
    'type': number;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandPermission
     */
    'permission': boolean;
}
/**
 * 
 * @export
 * @interface ApplicationCommandResponse
 */
export interface ApplicationCommandResponse {
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandResponse
     */
    'application_id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandResponse
     */
    'version': string;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandResponse
     */
    'default_member_permissions'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandResponse
     */
    'name_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandResponse
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandResponse
     */
    'description_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandResponse
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandResponse
     */
    'guild_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandResponse
     */
    'dm_permission'?: boolean | null;
    /**
     * 
     * @type {Set<number>}
     * @memberof ApplicationCommandResponse
     */
    'contexts'?: Set<number> | null;
    /**
     * 
     * @type {Set<number>}
     * @memberof ApplicationCommandResponse
     */
    'integration_types'?: Set<number> | null;
    /**
     * 
     * @type {Array<ApplicationCommandResponseOptionsInner>}
     * @memberof ApplicationCommandResponse
     */
    'options'?: Array<ApplicationCommandResponseOptionsInner> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandResponse
     */
    'nsfw'?: boolean | null;
}
/**
 * @type ApplicationCommandResponseOptionsInner
 * @export
 */
export type ApplicationCommandResponseOptionsInner = ApplicationCommandAttachmentOptionResponse | ApplicationCommandBooleanOptionResponse | ApplicationCommandChannelOptionResponse | ApplicationCommandIntegerOptionResponse | ApplicationCommandMentionableOptionResponse | ApplicationCommandNumberOptionResponse | ApplicationCommandRoleOptionResponse | ApplicationCommandStringOptionResponse | ApplicationCommandSubcommandGroupOptionResponse | ApplicationCommandSubcommandOptionResponse | ApplicationCommandUserOptionResponse;

/**
 * 
 * @export
 * @interface ApplicationCommandRoleOption
 */
export interface ApplicationCommandRoleOption {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandRoleOption
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandRoleOption
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandRoleOption
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandRoleOption
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandRoleOption
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandRoleOption
     */
    'required'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ApplicationCommandRoleOptionResponse
 */
export interface ApplicationCommandRoleOptionResponse {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandRoleOptionResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandRoleOptionResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandRoleOptionResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandRoleOptionResponse
     */
    'name_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandRoleOptionResponse
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandRoleOptionResponse
     */
    'description_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandRoleOptionResponse
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandRoleOptionResponse
     */
    'required'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ApplicationCommandStringOption
 */
export interface ApplicationCommandStringOption {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandStringOption
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandStringOption
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandStringOption
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandStringOption
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandStringOption
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandStringOption
     */
    'required'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandStringOption
     */
    'autocomplete'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandStringOption
     */
    'min_length'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandStringOption
     */
    'max_length'?: number | null;
    /**
     * 
     * @type {Array<ApplicationCommandOptionStringChoice>}
     * @memberof ApplicationCommandStringOption
     */
    'choices'?: Array<ApplicationCommandOptionStringChoice> | null;
}
/**
 * 
 * @export
 * @interface ApplicationCommandStringOptionResponse
 */
export interface ApplicationCommandStringOptionResponse {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandStringOptionResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandStringOptionResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandStringOptionResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandStringOptionResponse
     */
    'name_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandStringOptionResponse
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandStringOptionResponse
     */
    'description_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandStringOptionResponse
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandStringOptionResponse
     */
    'required'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandStringOptionResponse
     */
    'autocomplete'?: boolean | null;
    /**
     * 
     * @type {Array<ApplicationCommandOptionStringChoiceResponse>}
     * @memberof ApplicationCommandStringOptionResponse
     */
    'choices'?: Array<ApplicationCommandOptionStringChoiceResponse> | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandStringOptionResponse
     */
    'min_length'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandStringOptionResponse
     */
    'max_length'?: number | null;
}
/**
 * 
 * @export
 * @interface ApplicationCommandSubcommandGroupOption
 */
export interface ApplicationCommandSubcommandGroupOption {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandSubcommandGroupOption
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandSubcommandGroupOption
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandSubcommandGroupOption
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandSubcommandGroupOption
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandSubcommandGroupOption
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandSubcommandGroupOption
     */
    'required'?: boolean | null;
    /**
     * 
     * @type {Array<ApplicationCommandSubcommandOption>}
     * @memberof ApplicationCommandSubcommandGroupOption
     */
    'options'?: Array<ApplicationCommandSubcommandOption> | null;
}
/**
 * 
 * @export
 * @interface ApplicationCommandSubcommandGroupOptionResponse
 */
export interface ApplicationCommandSubcommandGroupOptionResponse {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandSubcommandGroupOptionResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandSubcommandGroupOptionResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandSubcommandGroupOptionResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandSubcommandGroupOptionResponse
     */
    'name_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandSubcommandGroupOptionResponse
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandSubcommandGroupOptionResponse
     */
    'description_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandSubcommandGroupOptionResponse
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandSubcommandGroupOptionResponse
     */
    'required'?: boolean | null;
    /**
     * 
     * @type {Array<ApplicationCommandSubcommandOptionResponse>}
     * @memberof ApplicationCommandSubcommandGroupOptionResponse
     */
    'options'?: Array<ApplicationCommandSubcommandOptionResponse> | null;
}
/**
 * 
 * @export
 * @interface ApplicationCommandSubcommandOption
 */
export interface ApplicationCommandSubcommandOption {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandSubcommandOption
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandSubcommandOption
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandSubcommandOption
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandSubcommandOption
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandSubcommandOption
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandSubcommandOption
     */
    'required'?: boolean | null;
    /**
     * 
     * @type {Array<ApplicationCommandSubcommandOptionOptionsInner>}
     * @memberof ApplicationCommandSubcommandOption
     */
    'options'?: Array<ApplicationCommandSubcommandOptionOptionsInner> | null;
}
/**
 * @type ApplicationCommandSubcommandOptionOptionsInner
 * @export
 */
export type ApplicationCommandSubcommandOptionOptionsInner = ApplicationCommandAttachmentOption | ApplicationCommandBooleanOption | ApplicationCommandChannelOption | ApplicationCommandIntegerOption | ApplicationCommandMentionableOption | ApplicationCommandNumberOption | ApplicationCommandRoleOption | ApplicationCommandStringOption | ApplicationCommandUserOption;

/**
 * 
 * @export
 * @interface ApplicationCommandSubcommandOptionResponse
 */
export interface ApplicationCommandSubcommandOptionResponse {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandSubcommandOptionResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandSubcommandOptionResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandSubcommandOptionResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandSubcommandOptionResponse
     */
    'name_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandSubcommandOptionResponse
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandSubcommandOptionResponse
     */
    'description_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandSubcommandOptionResponse
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandSubcommandOptionResponse
     */
    'required'?: boolean | null;
    /**
     * 
     * @type {Array<ApplicationCommandSubcommandOptionResponseOptionsInner>}
     * @memberof ApplicationCommandSubcommandOptionResponse
     */
    'options'?: Array<ApplicationCommandSubcommandOptionResponseOptionsInner> | null;
}
/**
 * @type ApplicationCommandSubcommandOptionResponseOptionsInner
 * @export
 */
export type ApplicationCommandSubcommandOptionResponseOptionsInner = ApplicationCommandAttachmentOptionResponse | ApplicationCommandBooleanOptionResponse | ApplicationCommandChannelOptionResponse | ApplicationCommandIntegerOptionResponse | ApplicationCommandMentionableOptionResponse | ApplicationCommandNumberOptionResponse | ApplicationCommandRoleOptionResponse | ApplicationCommandStringOptionResponse | ApplicationCommandUserOptionResponse;

/**
 * 
 * @export
 * @interface ApplicationCommandUpdateRequest
 */
export interface ApplicationCommandUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandUpdateRequest
     */
    'name': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandUpdateRequest
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandUpdateRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandUpdateRequest
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ApplicationCommandCreateRequestOptionsInner>}
     * @memberof ApplicationCommandUpdateRequest
     */
    'options'?: Array<ApplicationCommandCreateRequestOptionsInner> | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandUpdateRequest
     */
    'default_member_permissions'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandUpdateRequest
     */
    'dm_permission'?: boolean | null;
    /**
     * 
     * @type {Set<number>}
     * @memberof ApplicationCommandUpdateRequest
     */
    'contexts'?: Set<number> | null;
    /**
     * 
     * @type {Set<number>}
     * @memberof ApplicationCommandUpdateRequest
     */
    'integration_types'?: Set<number> | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandUpdateRequest
     */
    'handler'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandUpdateRequest
     */
    'type'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandUpdateRequest
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationCommandUserOption
 */
export interface ApplicationCommandUserOption {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandUserOption
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandUserOption
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandUserOption
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandUserOption
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandUserOption
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandUserOption
     */
    'required'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ApplicationCommandUserOptionResponse
 */
export interface ApplicationCommandUserOptionResponse {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCommandUserOptionResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandUserOptionResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandUserOptionResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandUserOptionResponse
     */
    'name_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandUserOptionResponse
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ApplicationCommandUserOptionResponse
     */
    'description_localized'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationCommandUserOptionResponse
     */
    'description_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCommandUserOptionResponse
     */
    'required'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ApplicationFormPartial
 */
export interface ApplicationFormPartial {
    /**
     * 
     * @type {ApplicationFormPartialDescription}
     * @memberof ApplicationFormPartial
     */
    'description'?: ApplicationFormPartialDescription;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormPartial
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormPartial
     */
    'cover_image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormPartial
     */
    'team_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApplicationFormPartial
     */
    'flags'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormPartial
     */
    'interactions_endpoint_url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationFormPartial
     */
    'explicit_content_filter'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationFormPartial
     */
    'max_participants'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationFormPartial
     */
    'type'?: number | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof ApplicationFormPartial
     */
    'tags'?: Set<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormPartial
     */
    'custom_install_url'?: string | null;
    /**
     * 
     * @type {ApplicationOAuth2InstallParams}
     * @memberof ApplicationFormPartial
     */
    'install_params'?: ApplicationOAuth2InstallParams | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormPartial
     */
    'role_connections_verification_url'?: string | null;
    /**
     * 
     * @type {{ [key: string]: ApplicationFormPartialIntegrationTypesConfigValue; }}
     * @memberof ApplicationFormPartial
     */
    'integration_types_config'?: { [key: string]: ApplicationFormPartialIntegrationTypesConfigValue; };
}
/**
 * 
 * @export
 * @interface ApplicationFormPartialDescription
 */
export interface ApplicationFormPartialDescription {
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormPartialDescription
     */
    'default': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationFormPartialDescription
     */
    'localizations'?: { [key: string]: string; };
}
/**
 * @type ApplicationFormPartialIntegrationTypesConfigValue
 * @export
 */
export type ApplicationFormPartialIntegrationTypesConfigValue = ApplicationIntegrationTypeConfiguration;

/**
 * 
 * @export
 * @interface ApplicationIncomingWebhookResponse
 */
export interface ApplicationIncomingWebhookResponse {
    /**
     * 
     * @type {string}
     * @memberof ApplicationIncomingWebhookResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationIncomingWebhookResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ApplicationIncomingWebhookResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationIncomingWebhookResponse
     */
    'application_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationIncomingWebhookResponse
     */
    'avatar'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationIncomingWebhookResponse
     */
    'channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationIncomingWebhookResponse
     */
    'guild_id'?: string;
    /**
     * 
     * @type {UserResponse}
     * @memberof ApplicationIncomingWebhookResponse
     */
    'user'?: UserResponse | null;
}
/**
 * 
 * @export
 * @interface ApplicationIntegrationTypeConfiguration
 */
export interface ApplicationIntegrationTypeConfiguration {
    /**
     * 
     * @type {ApplicationOAuth2InstallParams}
     * @memberof ApplicationIntegrationTypeConfiguration
     */
    'oauth2_install_params'?: ApplicationOAuth2InstallParams | null;
}
/**
 * 
 * @export
 * @interface ApplicationIntegrationTypeConfigurationResponse
 */
export interface ApplicationIntegrationTypeConfigurationResponse {
    /**
     * 
     * @type {ApplicationOAuth2InstallParamsResponse}
     * @memberof ApplicationIntegrationTypeConfigurationResponse
     */
    'oauth2_install_params'?: ApplicationOAuth2InstallParamsResponse | null;
}
/**
 * 
 * @export
 * @interface ApplicationOAuth2InstallParams
 */
export interface ApplicationOAuth2InstallParams {
    /**
     * 
     * @type {Set<string>}
     * @memberof ApplicationOAuth2InstallParams
     */
    'scopes'?: Set<string> | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationOAuth2InstallParams
     */
    'permissions'?: number | null;
}
/**
 * 
 * @export
 * @interface ApplicationOAuth2InstallParamsResponse
 */
export interface ApplicationOAuth2InstallParamsResponse {
    /**
     * 
     * @type {Set<string>}
     * @memberof ApplicationOAuth2InstallParamsResponse
     */
    'scopes': Set<string>;
    /**
     * 
     * @type {string}
     * @memberof ApplicationOAuth2InstallParamsResponse
     */
    'permissions': string;
}
/**
 * 
 * @export
 * @interface ApplicationResponse
 */
export interface ApplicationResponse {
    /**
     * 
     * @type {string}
     * @memberof ApplicationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationResponse
     */
    'verify_key': string;
    /**
     * 
     * @type {number}
     * @memberof ApplicationResponse
     */
    'flags': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationResponse
     */
    'icon'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationResponse
     */
    'type'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationResponse
     */
    'cover_image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationResponse
     */
    'primary_sku_id'?: string;
    /**
     * 
     * @type {UserResponse}
     * @memberof ApplicationResponse
     */
    'bot'?: UserResponse | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationResponse
     */
    'slug'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationResponse
     */
    'guild_id'?: string;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof ApplicationResponse
     */
    'rpc_origins'?: Array<string | null> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationResponse
     */
    'bot_public'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationResponse
     */
    'bot_require_code_grant'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationResponse
     */
    'terms_of_service_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationResponse
     */
    'privacy_policy_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationResponse
     */
    'custom_install_url'?: string | null;
    /**
     * 
     * @type {ApplicationOAuth2InstallParamsResponse}
     * @memberof ApplicationResponse
     */
    'install_params'?: ApplicationOAuth2InstallParamsResponse | null;
    /**
     * 
     * @type {{ [key: string]: ApplicationIntegrationTypeConfigurationResponse; }}
     * @memberof ApplicationResponse
     */
    'integration_types_config'?: { [key: string]: ApplicationIntegrationTypeConfigurationResponse; };
    /**
     * 
     * @type {number}
     * @memberof ApplicationResponse
     */
    'max_participants'?: number | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof ApplicationResponse
     */
    'tags'?: Set<string> | null;
}
/**
 * 
 * @export
 * @interface ApplicationRoleConnectionsMetadataItemRequest
 */
export interface ApplicationRoleConnectionsMetadataItemRequest {
    /**
     * 
     * @type {number}
     * @memberof ApplicationRoleConnectionsMetadataItemRequest
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationRoleConnectionsMetadataItemRequest
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationRoleConnectionsMetadataItemRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationRoleConnectionsMetadataItemRequest
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: string | null; }}
     * @memberof ApplicationRoleConnectionsMetadataItemRequest
     */
    'name_localizations'?: { [key: string]: string | null; };
    /**
     * 
     * @type {{ [key: string]: string | null; }}
     * @memberof ApplicationRoleConnectionsMetadataItemRequest
     */
    'description_localizations'?: { [key: string]: string | null; };
}
/**
 * 
 * @export
 * @interface ApplicationRoleConnectionsMetadataItemResponse
 */
export interface ApplicationRoleConnectionsMetadataItemResponse {
    /**
     * 
     * @type {number}
     * @memberof ApplicationRoleConnectionsMetadataItemResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationRoleConnectionsMetadataItemResponse
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationRoleConnectionsMetadataItemResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationRoleConnectionsMetadataItemResponse
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationRoleConnectionsMetadataItemResponse
     */
    'name_localizations'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationRoleConnectionsMetadataItemResponse
     */
    'description_localizations'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ApplicationUserRoleConnectionResponse
 */
export interface ApplicationUserRoleConnectionResponse {
    /**
     * 
     * @type {string}
     * @memberof ApplicationUserRoleConnectionResponse
     */
    'platform_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUserRoleConnectionResponse
     */
    'platform_username'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationUserRoleConnectionResponse
     */
    'metadata'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface AttachmentResponse
 */
export interface AttachmentResponse {
    /**
     * 
     * @type {string}
     * @memberof AttachmentResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentResponse
     */
    'filename': string;
    /**
     * 
     * @type {number}
     * @memberof AttachmentResponse
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof AttachmentResponse
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentResponse
     */
    'proxy_url': string;
    /**
     * 
     * @type {number}
     * @memberof AttachmentResponse
     */
    'width'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AttachmentResponse
     */
    'height'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AttachmentResponse
     */
    'duration_secs'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AttachmentResponse
     */
    'waveform'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttachmentResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttachmentResponse
     */
    'content_type'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AttachmentResponse
     */
    'ephemeral'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof AttachmentResponse
     */
    'title'?: string | null;
    /**
     * 
     * @type {ApplicationResponse}
     * @memberof AttachmentResponse
     */
    'application'?: ApplicationResponse | null;
    /**
     * 
     * @type {string}
     * @memberof AttachmentResponse
     */
    'clip_created_at'?: string | null;
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof AttachmentResponse
     */
    'clip_participants'?: Array<UserResponse> | null;
}
/**
 * 
 * @export
 * @interface AuditLogEntryResponse
 */
export interface AuditLogEntryResponse {
    /**
     * 
     * @type {string}
     * @memberof AuditLogEntryResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof AuditLogEntryResponse
     */
    'action_type': number | null;
    /**
     * 
     * @type {string}
     * @memberof AuditLogEntryResponse
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLogEntryResponse
     */
    'target_id'?: string;
    /**
     * 
     * @type {Array<AuditLogObjectChangeResponse>}
     * @memberof AuditLogEntryResponse
     */
    'changes'?: Array<AuditLogObjectChangeResponse> | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AuditLogEntryResponse
     */
    'options'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof AuditLogEntryResponse
     */
    'reason'?: string | null;
}
/**
 * 
 * @export
 * @interface AuditLogObjectChangeResponse
 */
export interface AuditLogObjectChangeResponse {
    /**
     * 
     * @type {string}
     * @memberof AuditLogObjectChangeResponse
     */
    'key'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof AuditLogObjectChangeResponse
     */
    'new_value'?: any;
    /**
     * 
     * @type {any}
     * @memberof AuditLogObjectChangeResponse
     */
    'old_value'?: any;
}
/**
 * 
 * @export
 * @interface BanUserFromGuildRequest
 */
export interface BanUserFromGuildRequest {
    /**
     * 
     * @type {number}
     * @memberof BanUserFromGuildRequest
     */
    'delete_message_seconds'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BanUserFromGuildRequest
     */
    'delete_message_days'?: number | null;
}
/**
 * 
 * @export
 * @interface BaseCreateMessageCreateRequest
 */
export interface BaseCreateMessageCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof BaseCreateMessageCreateRequest
     */
    'content'?: string | null;
    /**
     * 
     * @type {Array<RichEmbed>}
     * @memberof BaseCreateMessageCreateRequest
     */
    'embeds'?: Array<RichEmbed> | null;
    /**
     * 
     * @type {MessageAllowedMentionsRequest}
     * @memberof BaseCreateMessageCreateRequest
     */
    'allowed_mentions'?: MessageAllowedMentionsRequest | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseCreateMessageCreateRequest
     */
    'sticker_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<BaseCreateMessageCreateRequestComponentsInner>}
     * @memberof BaseCreateMessageCreateRequest
     */
    'components'?: Array<BaseCreateMessageCreateRequestComponentsInner> | null;
    /**
     * 
     * @type {number}
     * @memberof BaseCreateMessageCreateRequest
     */
    'flags'?: number | null;
    /**
     * 
     * @type {Array<MessageAttachmentRequest>}
     * @memberof BaseCreateMessageCreateRequest
     */
    'attachments'?: Array<MessageAttachmentRequest> | null;
    /**
     * 
     * @type {PollCreateRequest}
     * @memberof BaseCreateMessageCreateRequest
     */
    'poll'?: PollCreateRequest | null;
    /**
     * 
     * @type {object}
     * @memberof BaseCreateMessageCreateRequest
     */
    'confetti_potion'?: object;
}
/**
 * @type BaseCreateMessageCreateRequestComponentsInner
 * @export
 */
export type BaseCreateMessageCreateRequestComponentsInner = ActionRowComponentForMessageRequest | ContainerComponentForMessageRequest | FileComponentForMessageRequest | MediaGalleryComponentForMessageRequest | SectionComponentForMessageRequest | SeparatorComponentForMessageRequest | TextDisplayComponentForMessageRequest;

/**
 * 
 * @export
 * @interface BasicApplicationResponse
 */
export interface BasicApplicationResponse {
    /**
     * 
     * @type {string}
     * @memberof BasicApplicationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BasicApplicationResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BasicApplicationResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof BasicApplicationResponse
     */
    'icon'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BasicApplicationResponse
     */
    'type'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BasicApplicationResponse
     */
    'cover_image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BasicApplicationResponse
     */
    'primary_sku_id'?: string;
    /**
     * 
     * @type {UserResponse}
     * @memberof BasicApplicationResponse
     */
    'bot'?: UserResponse | null;
}
/**
 * 
 * @export
 * @interface BasicMessageResponse
 */
export interface BasicMessageResponse {
    /**
     * 
     * @type {number}
     * @memberof BasicMessageResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof BasicMessageResponse
     */
    'content': string;
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof BasicMessageResponse
     */
    'mentions': Array<UserResponse>;
    /**
     * 
     * @type {Set<string>}
     * @memberof BasicMessageResponse
     */
    'mention_roles': Set<string>;
    /**
     * 
     * @type {Array<MessageAttachmentResponse>}
     * @memberof BasicMessageResponse
     */
    'attachments': Array<MessageAttachmentResponse>;
    /**
     * 
     * @type {Array<MessageEmbedResponse>}
     * @memberof BasicMessageResponse
     */
    'embeds': Array<MessageEmbedResponse>;
    /**
     * 
     * @type {string}
     * @memberof BasicMessageResponse
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof BasicMessageResponse
     */
    'flags': number;
    /**
     * 
     * @type {Array<BasicMessageResponseComponentsInner>}
     * @memberof BasicMessageResponse
     */
    'components': Array<BasicMessageResponseComponentsInner>;
    /**
     * 
     * @type {string}
     * @memberof BasicMessageResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BasicMessageResponse
     */
    'channel_id': string;
    /**
     * 
     * @type {UserResponse}
     * @memberof BasicMessageResponse
     */
    'author': UserResponse;
    /**
     * 
     * @type {boolean}
     * @memberof BasicMessageResponse
     */
    'pinned': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BasicMessageResponse
     */
    'mention_everyone': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BasicMessageResponse
     */
    'tts': boolean;
    /**
     * 
     * @type {string}
     * @memberof BasicMessageResponse
     */
    'edited_timestamp'?: string | null;
    /**
     * 
     * @type {ResolvedObjectsResponse}
     * @memberof BasicMessageResponse
     */
    'resolved'?: ResolvedObjectsResponse | null;
    /**
     * 
     * @type {Array<GetSticker200Response>}
     * @memberof BasicMessageResponse
     */
    'stickers'?: Array<GetSticker200Response> | null;
    /**
     * 
     * @type {Array<MessageStickerItemResponse>}
     * @memberof BasicMessageResponse
     */
    'sticker_items'?: Array<MessageStickerItemResponse> | null;
    /**
     * 
     * @type {MessageCallResponse}
     * @memberof BasicMessageResponse
     */
    'call'?: MessageCallResponse | null;
    /**
     * 
     * @type {object}
     * @memberof BasicMessageResponse
     */
    'activity'?: object;
    /**
     * 
     * @type {BasicApplicationResponse}
     * @memberof BasicMessageResponse
     */
    'application'?: BasicApplicationResponse | null;
    /**
     * 
     * @type {string}
     * @memberof BasicMessageResponse
     */
    'application_id'?: string;
    /**
     * 
     * @type {MessageInteractionResponse}
     * @memberof BasicMessageResponse
     */
    'interaction'?: MessageInteractionResponse | null;
    /**
     * 
     * @type {BasicMessageResponseNonce}
     * @memberof BasicMessageResponse
     */
    'nonce'?: BasicMessageResponseNonce | null;
    /**
     * 
     * @type {string}
     * @memberof BasicMessageResponse
     */
    'webhook_id'?: string;
    /**
     * 
     * @type {MessageReferenceResponse}
     * @memberof BasicMessageResponse
     */
    'message_reference'?: MessageReferenceResponse | null;
    /**
     * 
     * @type {ThreadResponse}
     * @memberof BasicMessageResponse
     */
    'thread'?: ThreadResponse | null;
    /**
     * 
     * @type {Array<MessageMentionChannelResponse | null>}
     * @memberof BasicMessageResponse
     */
    'mention_channels'?: Array<MessageMentionChannelResponse | null> | null;
    /**
     * 
     * @type {MessageRoleSubscriptionDataResponse}
     * @memberof BasicMessageResponse
     */
    'role_subscription_data'?: MessageRoleSubscriptionDataResponse | null;
    /**
     * 
     * @type {PurchaseNotificationResponse}
     * @memberof BasicMessageResponse
     */
    'purchase_notification'?: PurchaseNotificationResponse | null;
    /**
     * 
     * @type {number}
     * @memberof BasicMessageResponse
     */
    'position'?: number | null;
    /**
     * 
     * @type {PollResponse}
     * @memberof BasicMessageResponse
     */
    'poll'?: PollResponse | null;
    /**
     * 
     * @type {BasicMessageResponseInteractionMetadata}
     * @memberof BasicMessageResponse
     */
    'interaction_metadata'?: BasicMessageResponseInteractionMetadata | null;
    /**
     * 
     * @type {Array<MessageSnapshotResponse>}
     * @memberof BasicMessageResponse
     */
    'message_snapshots'?: Array<MessageSnapshotResponse> | null;
}
/**
 * @type BasicMessageResponseComponentsInner
 * @export
 */
export type BasicMessageResponseComponentsInner = ActionRowComponentResponse | ContainerComponentResponse | FileComponentResponse | MediaGalleryComponentResponse | SectionComponentResponse | SeparatorComponentResponse | TextDisplayComponentResponse;

/**
 * @type BasicMessageResponseInteractionMetadata
 * @export
 */
export type BasicMessageResponseInteractionMetadata = ApplicationCommandInteractionMetadataResponse | MessageComponentInteractionMetadataResponse | ModalSubmitInteractionMetadataResponse;

/**
 * @type BasicMessageResponseNonce
 * @export
 */
export type BasicMessageResponseNonce = number | string;

/**
 * 
 * @export
 * @interface BlockMessageAction
 */
export interface BlockMessageAction {
    /**
     * 
     * @type {number}
     * @memberof BlockMessageAction
     */
    'type': number;
    /**
     * 
     * @type {BlockMessageActionMetadata}
     * @memberof BlockMessageAction
     */
    'metadata'?: BlockMessageActionMetadata | null;
}
/**
 * 
 * @export
 * @interface BlockMessageActionMetadata
 */
export interface BlockMessageActionMetadata {
    /**
     * 
     * @type {string}
     * @memberof BlockMessageActionMetadata
     */
    'custom_message'?: string | null;
}
/**
 * 
 * @export
 * @interface BlockMessageActionMetadataResponse
 */
export interface BlockMessageActionMetadataResponse {
    /**
     * 
     * @type {string}
     * @memberof BlockMessageActionMetadataResponse
     */
    'custom_message'?: string | null;
}
/**
 * 
 * @export
 * @interface BlockMessageActionResponse
 */
export interface BlockMessageActionResponse {
    /**
     * 
     * @type {number}
     * @memberof BlockMessageActionResponse
     */
    'type': number;
    /**
     * 
     * @type {BlockMessageActionMetadataResponse}
     * @memberof BlockMessageActionResponse
     */
    'metadata': BlockMessageActionMetadataResponse;
}
/**
 * 
 * @export
 * @interface BotAccountPatchRequest
 */
export interface BotAccountPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof BotAccountPatchRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof BotAccountPatchRequest
     */
    'avatar'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BotAccountPatchRequest
     */
    'banner'?: string | null;
}
/**
 * 
 * @export
 * @interface BulkBanUsersFromGuildRequest
 */
export interface BulkBanUsersFromGuildRequest {
    /**
     * 
     * @type {Set<string>}
     * @memberof BulkBanUsersFromGuildRequest
     */
    'user_ids': Set<string>;
    /**
     * 
     * @type {number}
     * @memberof BulkBanUsersFromGuildRequest
     */
    'delete_message_seconds'?: number | null;
}
/**
 * 
 * @export
 * @interface BulkBanUsersResponse
 */
export interface BulkBanUsersResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkBanUsersResponse
     */
    'banned_users': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkBanUsersResponse
     */
    'failed_users': Array<string>;
}
/**
 * 
 * @export
 * @interface BulkDeleteMessagesRequest
 */
export interface BulkDeleteMessagesRequest {
    /**
     * 
     * @type {Set<string>}
     * @memberof BulkDeleteMessagesRequest
     */
    'messages': Set<string>;
}
/**
 * 
 * @export
 * @interface BulkLobbyMemberRequest
 */
export interface BulkLobbyMemberRequest {
    /**
     * 
     * @type {string}
     * @memberof BulkLobbyMemberRequest
     */
    'id': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BulkLobbyMemberRequest
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof BulkLobbyMemberRequest
     */
    'flags'?: BulkLobbyMemberRequestFlagsEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof BulkLobbyMemberRequest
     */
    'remove_member'?: boolean | null;
}

export const BulkLobbyMemberRequestFlagsEnum = {
    NUMBER_1: 1
} as const;

export type BulkLobbyMemberRequestFlagsEnum = typeof BulkLobbyMemberRequestFlagsEnum[keyof typeof BulkLobbyMemberRequestFlagsEnum];

/**
 * 
 * @export
 * @interface BulkUpdateGuildChannelsRequestInner
 */
export interface BulkUpdateGuildChannelsRequestInner {
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateGuildChannelsRequestInner
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof BulkUpdateGuildChannelsRequestInner
     */
    'position'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateGuildChannelsRequestInner
     */
    'parent_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BulkUpdateGuildChannelsRequestInner
     */
    'lock_permissions'?: boolean | null;
}
/**
 * 
 * @export
 * @interface BulkUpdateGuildRolesRequestInner
 */
export interface BulkUpdateGuildRolesRequestInner {
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateGuildRolesRequestInner
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof BulkUpdateGuildRolesRequestInner
     */
    'position'?: number | null;
}
/**
 * 
 * @export
 * @interface ButtonComponentForMessageRequest
 */
export interface ButtonComponentForMessageRequest {
    /**
     * 
     * @type {number}
     * @memberof ButtonComponentForMessageRequest
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof ButtonComponentForMessageRequest
     */
    'style': number | null;
    /**
     * 
     * @type {string}
     * @memberof ButtonComponentForMessageRequest
     */
    'custom_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ButtonComponentForMessageRequest
     */
    'label'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ButtonComponentForMessageRequest
     */
    'disabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ButtonComponentForMessageRequest
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ButtonComponentForMessageRequest
     */
    'sku_id'?: string;
    /**
     * 
     * @type {ComponentEmojiForMessageRequest}
     * @memberof ButtonComponentForMessageRequest
     */
    'emoji'?: ComponentEmojiForMessageRequest | null;
}
/**
 * 
 * @export
 * @interface ButtonComponentResponse
 */
export interface ButtonComponentResponse {
    /**
     * 
     * @type {number}
     * @memberof ButtonComponentResponse
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof ButtonComponentResponse
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ButtonComponentResponse
     */
    'style': number | null;
    /**
     * 
     * @type {string}
     * @memberof ButtonComponentResponse
     */
    'custom_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ButtonComponentResponse
     */
    'label'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ButtonComponentResponse
     */
    'disabled'?: boolean | null;
    /**
     * 
     * @type {ComponentEmojiResponse}
     * @memberof ButtonComponentResponse
     */
    'emoji'?: ComponentEmojiResponse | null;
    /**
     * 
     * @type {string}
     * @memberof ButtonComponentResponse
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ButtonComponentResponse
     */
    'sku_id'?: string;
}
/**
 * 
 * @export
 * @interface ChannelFollowerResponse
 */
export interface ChannelFollowerResponse {
    /**
     * 
     * @type {string}
     * @memberof ChannelFollowerResponse
     */
    'channel_id': string;
    /**
     * 
     * @type {string}
     * @memberof ChannelFollowerResponse
     */
    'webhook_id': string;
}
/**
 * 
 * @export
 * @interface ChannelFollowerWebhookResponse
 */
export interface ChannelFollowerWebhookResponse {
    /**
     * 
     * @type {string}
     * @memberof ChannelFollowerWebhookResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ChannelFollowerWebhookResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ChannelFollowerWebhookResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ChannelFollowerWebhookResponse
     */
    'application_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelFollowerWebhookResponse
     */
    'avatar'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChannelFollowerWebhookResponse
     */
    'channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelFollowerWebhookResponse
     */
    'guild_id'?: string;
    /**
     * 
     * @type {UserResponse}
     * @memberof ChannelFollowerWebhookResponse
     */
    'user'?: UserResponse | null;
    /**
     * 
     * @type {WebhookSourceGuildResponse}
     * @memberof ChannelFollowerWebhookResponse
     */
    'source_guild'?: WebhookSourceGuildResponse | null;
    /**
     * 
     * @type {WebhookSourceChannelResponse}
     * @memberof ChannelFollowerWebhookResponse
     */
    'source_channel'?: WebhookSourceChannelResponse | null;
}
/**
 * 
 * @export
 * @interface ChannelPermissionOverwriteRequest
 */
export interface ChannelPermissionOverwriteRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelPermissionOverwriteRequest
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ChannelPermissionOverwriteRequest
     */
    'type'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ChannelPermissionOverwriteRequest
     */
    'allow'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ChannelPermissionOverwriteRequest
     */
    'deny'?: number | null;
}
/**
 * 
 * @export
 * @interface ChannelPermissionOverwriteResponse
 */
export interface ChannelPermissionOverwriteResponse {
    /**
     * 
     * @type {string}
     * @memberof ChannelPermissionOverwriteResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ChannelPermissionOverwriteResponse
     */
    'type': number | null;
    /**
     * 
     * @type {string}
     * @memberof ChannelPermissionOverwriteResponse
     */
    'allow': string;
    /**
     * 
     * @type {string}
     * @memberof ChannelPermissionOverwriteResponse
     */
    'deny': string;
}
/**
 * 
 * @export
 * @interface ChannelSelectComponentForMessageRequest
 */
export interface ChannelSelectComponentForMessageRequest {
    /**
     * 
     * @type {number}
     * @memberof ChannelSelectComponentForMessageRequest
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof ChannelSelectComponentForMessageRequest
     */
    'custom_id': string;
    /**
     * 
     * @type {string}
     * @memberof ChannelSelectComponentForMessageRequest
     */
    'placeholder'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ChannelSelectComponentForMessageRequest
     */
    'min_values'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ChannelSelectComponentForMessageRequest
     */
    'max_values'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelSelectComponentForMessageRequest
     */
    'disabled'?: boolean | null;
    /**
     * 
     * @type {Array<ChannelSelectDefaultValue>}
     * @memberof ChannelSelectComponentForMessageRequest
     */
    'default_values'?: Array<ChannelSelectDefaultValue> | null;
    /**
     * 
     * @type {Set<number>}
     * @memberof ChannelSelectComponentForMessageRequest
     */
    'channel_types'?: Set<number> | null;
}
/**
 * 
 * @export
 * @interface ChannelSelectComponentResponse
 */
export interface ChannelSelectComponentResponse {
    /**
     * 
     * @type {number}
     * @memberof ChannelSelectComponentResponse
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof ChannelSelectComponentResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ChannelSelectComponentResponse
     */
    'custom_id': string;
    /**
     * 
     * @type {string}
     * @memberof ChannelSelectComponentResponse
     */
    'placeholder'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ChannelSelectComponentResponse
     */
    'min_values'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ChannelSelectComponentResponse
     */
    'max_values'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelSelectComponentResponse
     */
    'disabled'?: boolean | null;
    /**
     * 
     * @type {Set<number>}
     * @memberof ChannelSelectComponentResponse
     */
    'channel_types'?: Set<number> | null;
    /**
     * 
     * @type {Array<ChannelSelectDefaultValueResponse>}
     * @memberof ChannelSelectComponentResponse
     */
    'default_values'?: Array<ChannelSelectDefaultValueResponse> | null;
}
/**
 * 
 * @export
 * @interface ChannelSelectDefaultValue
 */
export interface ChannelSelectDefaultValue {
    /**
     * 
     * @type {string}
     * @memberof ChannelSelectDefaultValue
     */
    'type': string | null;
    /**
     * 
     * @type {string}
     * @memberof ChannelSelectDefaultValue
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ChannelSelectDefaultValueResponse
 */
export interface ChannelSelectDefaultValueResponse {
    /**
     * 
     * @type {string}
     * @memberof ChannelSelectDefaultValueResponse
     */
    'type': string | null;
    /**
     * 
     * @type {string}
     * @memberof ChannelSelectDefaultValueResponse
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface CommandPermissionResponse
 */
export interface CommandPermissionResponse {
    /**
     * 
     * @type {string}
     * @memberof CommandPermissionResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof CommandPermissionResponse
     */
    'type': number;
    /**
     * 
     * @type {boolean}
     * @memberof CommandPermissionResponse
     */
    'permission': boolean;
}
/**
 * 
 * @export
 * @interface CommandPermissionsResponse
 */
export interface CommandPermissionsResponse {
    /**
     * 
     * @type {string}
     * @memberof CommandPermissionsResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CommandPermissionsResponse
     */
    'application_id': string;
    /**
     * 
     * @type {string}
     * @memberof CommandPermissionsResponse
     */
    'guild_id': string;
    /**
     * 
     * @type {Array<CommandPermissionResponse>}
     * @memberof CommandPermissionsResponse
     */
    'permissions': Array<CommandPermissionResponse>;
}
/**
 * 
 * @export
 * @interface ComponentEmojiForMessageRequest
 */
export interface ComponentEmojiForMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof ComponentEmojiForMessageRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ComponentEmojiForMessageRequest
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface ComponentEmojiResponse
 */
export interface ComponentEmojiResponse {
    /**
     * 
     * @type {string}
     * @memberof ComponentEmojiResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ComponentEmojiResponse
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ComponentEmojiResponse
     */
    'animated'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ConnectedAccountGuildResponse
 */
export interface ConnectedAccountGuildResponse {
    /**
     * 
     * @type {string}
     * @memberof ConnectedAccountGuildResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectedAccountGuildResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectedAccountGuildResponse
     */
    'icon'?: string | null;
}
/**
 * 
 * @export
 * @interface ConnectedAccountIntegrationResponse
 */
export interface ConnectedAccountIntegrationResponse {
    /**
     * 
     * @type {string}
     * @memberof ConnectedAccountIntegrationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectedAccountIntegrationResponse
     */
    'type': string | null;
    /**
     * 
     * @type {AccountResponse}
     * @memberof ConnectedAccountIntegrationResponse
     */
    'account': AccountResponse;
    /**
     * 
     * @type {ConnectedAccountGuildResponse}
     * @memberof ConnectedAccountIntegrationResponse
     */
    'guild': ConnectedAccountGuildResponse;
}
/**
 * 
 * @export
 * @interface ConnectedAccountResponse
 */
export interface ConnectedAccountResponse {
    /**
     * 
     * @type {string}
     * @memberof ConnectedAccountResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectedAccountResponse
     */
    'type': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectedAccountResponse
     */
    'friend_sync': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectedAccountResponse
     */
    'show_activity': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectedAccountResponse
     */
    'two_way_link': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectedAccountResponse
     */
    'verified': boolean;
    /**
     * 
     * @type {number}
     * @memberof ConnectedAccountResponse
     */
    'visibility': number | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectedAccountResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {Array<ConnectedAccountIntegrationResponse>}
     * @memberof ConnectedAccountResponse
     */
    'integrations'?: Array<ConnectedAccountIntegrationResponse> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectedAccountResponse
     */
    'revoked'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ContainerComponentForMessageRequest
 */
export interface ContainerComponentForMessageRequest {
    /**
     * 
     * @type {number}
     * @memberof ContainerComponentForMessageRequest
     */
    'type': number;
    /**
     * 
     * @type {Array<ContainerComponentForMessageRequestComponentsInner>}
     * @memberof ContainerComponentForMessageRequest
     */
    'components': Array<ContainerComponentForMessageRequestComponentsInner>;
    /**
     * 
     * @type {number}
     * @memberof ContainerComponentForMessageRequest
     */
    'accent_color'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ContainerComponentForMessageRequest
     */
    'spoiler'?: boolean | null;
}
/**
 * @type ContainerComponentForMessageRequestComponentsInner
 * @export
 */
export type ContainerComponentForMessageRequestComponentsInner = ActionRowComponentForMessageRequest | FileComponentForMessageRequest | MediaGalleryComponentForMessageRequest | SectionComponentForMessageRequest | SeparatorComponentForMessageRequest | TextDisplayComponentForMessageRequest;

/**
 * 
 * @export
 * @interface ContainerComponentResponse
 */
export interface ContainerComponentResponse {
    /**
     * 
     * @type {number}
     * @memberof ContainerComponentResponse
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof ContainerComponentResponse
     */
    'id': number;
    /**
     * 
     * @type {Array<ContainerComponentResponseComponentsInner>}
     * @memberof ContainerComponentResponse
     */
    'components': Array<ContainerComponentResponseComponentsInner>;
    /**
     * 
     * @type {boolean}
     * @memberof ContainerComponentResponse
     */
    'spoiler': boolean;
    /**
     * 
     * @type {number}
     * @memberof ContainerComponentResponse
     */
    'accent_color'?: number | null;
}
/**
 * @type ContainerComponentResponseComponentsInner
 * @export
 */
export type ContainerComponentResponseComponentsInner = ActionRowComponentResponse | FileComponentResponse | MediaGalleryComponentResponse | SectionComponentResponse | SeparatorComponentResponse | TextDisplayComponentResponse;

/**
 * 
 * @export
 * @interface CreateApplicationEmojiRequest
 */
export interface CreateApplicationEmojiRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationEmojiRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationEmojiRequest
     */
    'image': string;
}
/**
 * @type CreateAutoModerationRule200Response
 * @export
 */
export type CreateAutoModerationRule200Response = DefaultKeywordRuleResponse | KeywordRuleResponse | MLSpamRuleResponse | MentionSpamRuleResponse | SpamLinkRuleResponse;

/**
 * @type CreateAutoModerationRuleRequest
 * @export
 */
export type CreateAutoModerationRuleRequest = DefaultKeywordListUpsertRequest | KeywordUpsertRequest | MLSpamUpsertRequest | MentionSpamUpsertRequest;

/**
 * 
 * @export
 * @interface CreateChannelInviteRequest
 */
export interface CreateChannelInviteRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateChannelInviteRequest
     */
    'max_age'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateChannelInviteRequest
     */
    'temporary'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateChannelInviteRequest
     */
    'max_uses'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateChannelInviteRequest
     */
    'unique'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateChannelInviteRequest
     */
    'target_user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateChannelInviteRequest
     */
    'target_application_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateChannelInviteRequest
     */
    'target_type'?: number | null;
}
/**
 * 
 * @export
 * @interface CreateEntitlementRequestData
 */
export interface CreateEntitlementRequestData {
    /**
     * 
     * @type {string}
     * @memberof CreateEntitlementRequestData
     */
    'sku_id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEntitlementRequestData
     */
    'owner_id': string;
    /**
     * 
     * @type {number}
     * @memberof CreateEntitlementRequestData
     */
    'owner_type': number;
}
/**
 * 
 * @export
 * @interface CreateForumThreadRequest
 */
export interface CreateForumThreadRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateForumThreadRequest
     */
    'name': string;
    /**
     * 
     * @type {BaseCreateMessageCreateRequest}
     * @memberof CreateForumThreadRequest
     */
    'message': BaseCreateMessageCreateRequest;
    /**
     * 
     * @type {number}
     * @memberof CreateForumThreadRequest
     */
    'auto_archive_duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateForumThreadRequest
     */
    'rate_limit_per_user'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateForumThreadRequest
     */
    'applied_tags'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CreateGroupDMInviteRequest
 */
export interface CreateGroupDMInviteRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateGroupDMInviteRequest
     */
    'max_age'?: number | null;
}
/**
 * 
 * @export
 * @interface CreateGuildChannelRequest
 */
export interface CreateGuildChannelRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateGuildChannelRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildChannelRequest
     */
    'type'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildChannelRequest
     */
    'position'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CreateGuildChannelRequest
     */
    'topic'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildChannelRequest
     */
    'bitrate'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildChannelRequest
     */
    'user_limit'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateGuildChannelRequest
     */
    'nsfw'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildChannelRequest
     */
    'rate_limit_per_user'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CreateGuildChannelRequest
     */
    'parent_id'?: string;
    /**
     * 
     * @type {Array<ChannelPermissionOverwriteRequest>}
     * @memberof CreateGuildChannelRequest
     */
    'permission_overwrites'?: Array<ChannelPermissionOverwriteRequest> | null;
    /**
     * 
     * @type {string}
     * @memberof CreateGuildChannelRequest
     */
    'rtc_region'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildChannelRequest
     */
    'video_quality_mode'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildChannelRequest
     */
    'default_auto_archive_duration'?: number;
    /**
     * 
     * @type {UpdateDefaultReactionEmojiRequest}
     * @memberof CreateGuildChannelRequest
     */
    'default_reaction_emoji'?: UpdateDefaultReactionEmojiRequest | null;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildChannelRequest
     */
    'default_thread_rate_limit_per_user'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildChannelRequest
     */
    'default_sort_order'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildChannelRequest
     */
    'default_forum_layout'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateGuildChannelRequest
     */
    'default_tag_setting'?: string;
    /**
     * 
     * @type {Array<CreateOrUpdateThreadTagRequest | null>}
     * @memberof CreateGuildChannelRequest
     */
    'available_tags'?: Array<CreateOrUpdateThreadTagRequest | null> | null;
}
/**
 * 
 * @export
 * @interface CreateGuildEmojiRequest
 */
export interface CreateGuildEmojiRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateGuildEmojiRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGuildEmojiRequest
     */
    'image': string;
    /**
     * 
     * @type {Set<string | null>}
     * @memberof CreateGuildEmojiRequest
     */
    'roles'?: Set<string | null> | null;
}
/**
 * 
 * @export
 * @interface CreateGuildFromTemplateRequest
 */
export interface CreateGuildFromTemplateRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateGuildFromTemplateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGuildFromTemplateRequest
     */
    'icon'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateGuildInviteRequest
 */
export interface CreateGuildInviteRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateGuildInviteRequest
     */
    'max_age'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateGuildInviteRequest
     */
    'temporary'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildInviteRequest
     */
    'max_uses'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateGuildInviteRequest
     */
    'unique'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof CreateGuildInviteRequest
     */
    'target_user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGuildInviteRequest
     */
    'target_application_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildInviteRequest
     */
    'target_type'?: number | null;
}
/**
 * 
 * @export
 * @interface CreateGuildRequestChannelItem
 */
export interface CreateGuildRequestChannelItem {
    /**
     * 
     * @type {string}
     * @memberof CreateGuildRequestChannelItem
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildRequestChannelItem
     */
    'type'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildRequestChannelItem
     */
    'position'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CreateGuildRequestChannelItem
     */
    'topic'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildRequestChannelItem
     */
    'bitrate'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildRequestChannelItem
     */
    'user_limit'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateGuildRequestChannelItem
     */
    'nsfw'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildRequestChannelItem
     */
    'rate_limit_per_user'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CreateGuildRequestChannelItem
     */
    'parent_id'?: string;
    /**
     * 
     * @type {Array<ChannelPermissionOverwriteRequest>}
     * @memberof CreateGuildRequestChannelItem
     */
    'permission_overwrites'?: Array<ChannelPermissionOverwriteRequest> | null;
    /**
     * 
     * @type {string}
     * @memberof CreateGuildRequestChannelItem
     */
    'rtc_region'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildRequestChannelItem
     */
    'video_quality_mode'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildRequestChannelItem
     */
    'default_auto_archive_duration'?: number;
    /**
     * 
     * @type {UpdateDefaultReactionEmojiRequest}
     * @memberof CreateGuildRequestChannelItem
     */
    'default_reaction_emoji'?: UpdateDefaultReactionEmojiRequest | null;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildRequestChannelItem
     */
    'default_thread_rate_limit_per_user'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildRequestChannelItem
     */
    'default_sort_order'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildRequestChannelItem
     */
    'default_forum_layout'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateGuildRequestChannelItem
     */
    'default_tag_setting'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGuildRequestChannelItem
     */
    'id'?: string;
    /**
     * 
     * @type {Array<CreateOrUpdateThreadTagRequest>}
     * @memberof CreateGuildRequestChannelItem
     */
    'available_tags'?: Array<CreateOrUpdateThreadTagRequest> | null;
}
/**
 * 
 * @export
 * @interface CreateGuildRequestRoleItem
 */
export interface CreateGuildRequestRoleItem {
    /**
     * 
     * @type {number}
     * @memberof CreateGuildRequestRoleItem
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CreateGuildRequestRoleItem
     */
    'name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildRequestRoleItem
     */
    'permissions'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildRequestRoleItem
     */
    'color'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateGuildRequestRoleItem
     */
    'hoist'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateGuildRequestRoleItem
     */
    'mentionable'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof CreateGuildRequestRoleItem
     */
    'unicode_emoji'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateGuildRoleRequest
 */
export interface CreateGuildRoleRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateGuildRoleRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildRoleRequest
     */
    'permissions'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CreateGuildRoleRequest
     */
    'color'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateGuildRoleRequest
     */
    'hoist'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateGuildRoleRequest
     */
    'mentionable'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof CreateGuildRoleRequest
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateGuildRoleRequest
     */
    'unicode_emoji'?: string | null;
}
/**
 * @type CreateGuildScheduledEventRequest
 * @export
 */
export type CreateGuildScheduledEventRequest = ExternalScheduledEventCreateRequest | StageScheduledEventCreateRequest | VoiceScheduledEventCreateRequest;

/**
 * 
 * @export
 * @interface CreateGuildTemplateRequest
 */
export interface CreateGuildTemplateRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateGuildTemplateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGuildTemplateRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateInteractionResponseRequest
 */
export interface CreateInteractionResponseRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateInteractionResponseRequest
     */
    'type': number | null;
    /**
     * 
     * @type {IncomingWebhookUpdateForInteractionCallbackRequestPartial}
     * @memberof CreateInteractionResponseRequest
     */
    'data': IncomingWebhookUpdateForInteractionCallbackRequestPartial;
}
/**
 * 
 * @export
 * @interface CreateLobbyRequest
 */
export interface CreateLobbyRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateLobbyRequest
     */
    'idle_timeout_seconds'?: number | null;
    /**
     * 
     * @type {Array<LobbyMemberRequest>}
     * @memberof CreateLobbyRequest
     */
    'members'?: Array<LobbyMemberRequest> | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateLobbyRequest
     */
    'metadata'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CreateMessageInteractionCallbackRequest
 */
export interface CreateMessageInteractionCallbackRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateMessageInteractionCallbackRequest
     */
    'type': number | null;
    /**
     * 
     * @type {IncomingWebhookInteractionRequest}
     * @memberof CreateMessageInteractionCallbackRequest
     */
    'data'?: IncomingWebhookInteractionRequest | null;
}
/**
 * 
 * @export
 * @interface CreateMessageInteractionCallbackResponse
 */
export interface CreateMessageInteractionCallbackResponse {
    /**
     * 
     * @type {number}
     * @memberof CreateMessageInteractionCallbackResponse
     */
    'type': number | null;
    /**
     * 
     * @type {MessageResponse}
     * @memberof CreateMessageInteractionCallbackResponse
     */
    'message': MessageResponse;
}
/**
 * 
 * @export
 * @interface CreateOrJoinLobbyRequest
 */
export interface CreateOrJoinLobbyRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateOrJoinLobbyRequest
     */
    'secret': string;
    /**
     * 
     * @type {number}
     * @memberof CreateOrJoinLobbyRequest
     */
    'idle_timeout_seconds'?: number | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateOrJoinLobbyRequest
     */
    'lobby_metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateOrJoinLobbyRequest
     */
    'member_metadata'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CreateOrUpdateThreadTagRequest
 */
export interface CreateOrUpdateThreadTagRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateThreadTagRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateThreadTagRequest
     */
    'emoji_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateThreadTagRequest
     */
    'emoji_name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOrUpdateThreadTagRequest
     */
    'moderated'?: boolean | null;
}
/**
 * 
 * @export
 * @interface CreatePrivateChannelRequest
 */
export interface CreatePrivateChannelRequest {
    /**
     * 
     * @type {string}
     * @memberof CreatePrivateChannelRequest
     */
    'recipient_id'?: string;
    /**
     * 
     * @type {Set<string>}
     * @memberof CreatePrivateChannelRequest
     */
    'access_tokens'?: Set<string> | null;
    /**
     * 
     * @type {{ [key: string]: string | null; }}
     * @memberof CreatePrivateChannelRequest
     */
    'nicks'?: { [key: string]: string | null; };
}
/**
 * 
 * @export
 * @interface CreateStageInstanceRequest
 */
export interface CreateStageInstanceRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateStageInstanceRequest
     */
    'topic': string;
    /**
     * 
     * @type {string}
     * @memberof CreateStageInstanceRequest
     */
    'channel_id': string;
    /**
     * 
     * @type {number}
     * @memberof CreateStageInstanceRequest
     */
    'privacy_level'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateStageInstanceRequest
     */
    'guild_scheduled_event_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateStageInstanceRequest
     */
    'send_start_notification'?: boolean | null;
}
/**
 * 
 * @export
 * @interface CreateTextThreadWithMessageRequest
 */
export interface CreateTextThreadWithMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTextThreadWithMessageRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CreateTextThreadWithMessageRequest
     */
    'auto_archive_duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateTextThreadWithMessageRequest
     */
    'rate_limit_per_user'?: number | null;
}
/**
 * 
 * @export
 * @interface CreateTextThreadWithoutMessageRequest
 */
export interface CreateTextThreadWithoutMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTextThreadWithoutMessageRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CreateTextThreadWithoutMessageRequest
     */
    'auto_archive_duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateTextThreadWithoutMessageRequest
     */
    'rate_limit_per_user'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CreateTextThreadWithoutMessageRequest
     */
    'type'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateTextThreadWithoutMessageRequest
     */
    'invitable'?: boolean | null;
}
/**
 * 
 * @export
 * @interface CreateThreadRequest
 */
export interface CreateThreadRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateThreadRequest
     */
    'name': string;
    /**
     * 
     * @type {BaseCreateMessageCreateRequest}
     * @memberof CreateThreadRequest
     */
    'message': BaseCreateMessageCreateRequest;
    /**
     * 
     * @type {number}
     * @memberof CreateThreadRequest
     */
    'auto_archive_duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateThreadRequest
     */
    'rate_limit_per_user'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateThreadRequest
     */
    'applied_tags'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CreateThreadRequest
     */
    'type'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateThreadRequest
     */
    'invitable'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateWebhookRequest
 */
export interface CreateWebhookRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    'avatar'?: string | null;
}
/**
 * 
 * @export
 * @interface CreatedThreadResponse
 */
export interface CreatedThreadResponse {
    /**
     * 
     * @type {string}
     * @memberof CreatedThreadResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof CreatedThreadResponse
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof CreatedThreadResponse
     */
    'flags': number;
    /**
     * 
     * @type {string}
     * @memberof CreatedThreadResponse
     */
    'guild_id': string;
    /**
     * 
     * @type {string}
     * @memberof CreatedThreadResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreatedThreadResponse
     */
    'owner_id': string;
    /**
     * 
     * @type {number}
     * @memberof CreatedThreadResponse
     */
    'message_count': number;
    /**
     * 
     * @type {number}
     * @memberof CreatedThreadResponse
     */
    'member_count': number;
    /**
     * 
     * @type {number}
     * @memberof CreatedThreadResponse
     */
    'total_message_sent': number;
    /**
     * 
     * @type {string}
     * @memberof CreatedThreadResponse
     */
    'last_message_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatedThreadResponse
     */
    'last_pin_timestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreatedThreadResponse
     */
    'parent_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreatedThreadResponse
     */
    'rate_limit_per_user'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CreatedThreadResponse
     */
    'bitrate'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CreatedThreadResponse
     */
    'user_limit'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CreatedThreadResponse
     */
    'rtc_region'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreatedThreadResponse
     */
    'video_quality_mode'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreatedThreadResponse
     */
    'permissions'?: string | null;
    /**
     * 
     * @type {ThreadMetadataResponse}
     * @memberof CreatedThreadResponse
     */
    'thread_metadata'?: ThreadMetadataResponse | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreatedThreadResponse
     */
    'applied_tags'?: Array<string> | null;
    /**
     * 
     * @type {ThreadMemberResponse}
     * @memberof CreatedThreadResponse
     */
    'member'?: ThreadMemberResponse | null;
}
/**
 * 
 * @export
 * @interface DefaultKeywordListTriggerMetadata
 */
export interface DefaultKeywordListTriggerMetadata {
    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultKeywordListTriggerMetadata
     */
    'allow_list'?: Array<string> | null;
    /**
     * 
     * @type {Set<number>}
     * @memberof DefaultKeywordListTriggerMetadata
     */
    'presets'?: Set<number> | null;
}
/**
 * 
 * @export
 * @interface DefaultKeywordListTriggerMetadataResponse
 */
export interface DefaultKeywordListTriggerMetadataResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultKeywordListTriggerMetadataResponse
     */
    'allow_list': Array<string>;
    /**
     * 
     * @type {Set<number>}
     * @memberof DefaultKeywordListTriggerMetadataResponse
     */
    'presets': Set<number>;
}
/**
 * 
 * @export
 * @interface DefaultKeywordListUpsertRequest
 */
export interface DefaultKeywordListUpsertRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultKeywordListUpsertRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof DefaultKeywordListUpsertRequest
     */
    'event_type': number;
    /**
     * 
     * @type {number}
     * @memberof DefaultKeywordListUpsertRequest
     */
    'trigger_type': number;
    /**
     * 
     * @type {DefaultKeywordListTriggerMetadata}
     * @memberof DefaultKeywordListUpsertRequest
     */
    'trigger_metadata': DefaultKeywordListTriggerMetadata;
    /**
     * 
     * @type {Array<DefaultKeywordListUpsertRequestActionsInner>}
     * @memberof DefaultKeywordListUpsertRequest
     */
    'actions'?: Array<DefaultKeywordListUpsertRequestActionsInner> | null;
    /**
     * 
     * @type {boolean}
     * @memberof DefaultKeywordListUpsertRequest
     */
    'enabled'?: boolean | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof DefaultKeywordListUpsertRequest
     */
    'exempt_roles'?: Set<string> | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof DefaultKeywordListUpsertRequest
     */
    'exempt_channels'?: Set<string> | null;
}
/**
 * @type DefaultKeywordListUpsertRequestActionsInner
 * @export
 */
export type DefaultKeywordListUpsertRequestActionsInner = BlockMessageAction | FlagToChannelAction | QuarantineUserAction | UserCommunicationDisabledAction;

/**
 * 
 * @export
 * @interface DefaultKeywordListUpsertRequestPartial
 */
export interface DefaultKeywordListUpsertRequestPartial {
    /**
     * 
     * @type {string}
     * @memberof DefaultKeywordListUpsertRequestPartial
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof DefaultKeywordListUpsertRequestPartial
     */
    'event_type'?: number;
    /**
     * 
     * @type {Array<DefaultKeywordListUpsertRequestActionsInner>}
     * @memberof DefaultKeywordListUpsertRequestPartial
     */
    'actions'?: Array<DefaultKeywordListUpsertRequestActionsInner> | null;
    /**
     * 
     * @type {boolean}
     * @memberof DefaultKeywordListUpsertRequestPartial
     */
    'enabled'?: boolean | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof DefaultKeywordListUpsertRequestPartial
     */
    'exempt_roles'?: Set<string> | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof DefaultKeywordListUpsertRequestPartial
     */
    'exempt_channels'?: Set<string> | null;
    /**
     * 
     * @type {number}
     * @memberof DefaultKeywordListUpsertRequestPartial
     */
    'trigger_type'?: number;
    /**
     * 
     * @type {DefaultKeywordListTriggerMetadata}
     * @memberof DefaultKeywordListUpsertRequestPartial
     */
    'trigger_metadata'?: DefaultKeywordListTriggerMetadata;
}
/**
 * 
 * @export
 * @interface DefaultKeywordRuleResponse
 */
export interface DefaultKeywordRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof DefaultKeywordRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DefaultKeywordRuleResponse
     */
    'guild_id': string;
    /**
     * 
     * @type {string}
     * @memberof DefaultKeywordRuleResponse
     */
    'creator_id': string;
    /**
     * 
     * @type {string}
     * @memberof DefaultKeywordRuleResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof DefaultKeywordRuleResponse
     */
    'event_type': number;
    /**
     * 
     * @type {Array<DefaultKeywordRuleResponseActionsInner>}
     * @memberof DefaultKeywordRuleResponse
     */
    'actions': Array<DefaultKeywordRuleResponseActionsInner>;
    /**
     * 
     * @type {number}
     * @memberof DefaultKeywordRuleResponse
     */
    'trigger_type': number;
    /**
     * 
     * @type {DefaultKeywordListTriggerMetadataResponse}
     * @memberof DefaultKeywordRuleResponse
     */
    'trigger_metadata': DefaultKeywordListTriggerMetadataResponse;
    /**
     * 
     * @type {boolean}
     * @memberof DefaultKeywordRuleResponse
     */
    'enabled'?: boolean | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof DefaultKeywordRuleResponse
     */
    'exempt_roles'?: Set<string> | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof DefaultKeywordRuleResponse
     */
    'exempt_channels'?: Set<string> | null;
}
/**
 * @type DefaultKeywordRuleResponseActionsInner
 * @export
 */
export type DefaultKeywordRuleResponseActionsInner = BlockMessageActionResponse | FlagToChannelActionResponse | QuarantineUserActionResponse | UserCommunicationDisabledActionResponse;

/**
 * 
 * @export
 * @interface DefaultReactionEmojiResponse
 */
export interface DefaultReactionEmojiResponse {
    /**
     * 
     * @type {string}
     * @memberof DefaultReactionEmojiResponse
     */
    'emoji_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DefaultReactionEmojiResponse
     */
    'emoji_name'?: string | null;
}
/**
 * 
 * @export
 * @interface DiscordIntegrationResponse
 */
export interface DiscordIntegrationResponse {
    /**
     * 
     * @type {string}
     * @memberof DiscordIntegrationResponse
     */
    'type': string | null;
    /**
     * 
     * @type {string}
     * @memberof DiscordIntegrationResponse
     */
    'id': string;
    /**
     * 
     * @type {IntegrationApplicationResponse}
     * @memberof DiscordIntegrationResponse
     */
    'application': IntegrationApplicationResponse;
    /**
     * 
     * @type {Set<string>}
     * @memberof DiscordIntegrationResponse
     */
    'scopes': Set<string>;
    /**
     * 
     * @type {string}
     * @memberof DiscordIntegrationResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {AccountResponse}
     * @memberof DiscordIntegrationResponse
     */
    'account'?: AccountResponse | null;
    /**
     * 
     * @type {boolean}
     * @memberof DiscordIntegrationResponse
     */
    'enabled'?: boolean | null;
    /**
     * 
     * @type {UserResponse}
     * @memberof DiscordIntegrationResponse
     */
    'user'?: UserResponse | null;
}
/**
 * 
 * @export
 * @interface EditLobbyChannelLinkRequest
 */
export interface EditLobbyChannelLinkRequest {
    /**
     * 
     * @type {string}
     * @memberof EditLobbyChannelLinkRequest
     */
    'channel_id'?: string;
}
/**
 * 
 * @export
 * @interface EmbeddedActivityInstance
 */
export interface EmbeddedActivityInstance {
    /**
     * 
     * @type {string}
     * @memberof EmbeddedActivityInstance
     */
    'application_id': string;
    /**
     * 
     * @type {string}
     * @memberof EmbeddedActivityInstance
     */
    'instance_id': string;
    /**
     * 
     * @type {string}
     * @memberof EmbeddedActivityInstance
     */
    'launch_id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmbeddedActivityInstance
     */
    'users': Array<string>;
    /**
     * 
     * @type {EmbeddedActivityInstanceLocation}
     * @memberof EmbeddedActivityInstance
     */
    'location'?: EmbeddedActivityInstanceLocation | null;
}
/**
 * @type EmbeddedActivityInstanceLocation
 * @export
 */
export type EmbeddedActivityInstanceLocation = GuildChannelLocation | PrivateChannelLocation;

/**
 * 
 * @export
 * @interface EmojiResponse
 */
export interface EmojiResponse {
    /**
     * 
     * @type {string}
     * @memberof EmojiResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EmojiResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmojiResponse
     */
    'roles': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof EmojiResponse
     */
    'require_colons': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmojiResponse
     */
    'managed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmojiResponse
     */
    'animated': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmojiResponse
     */
    'available': boolean;
    /**
     * 
     * @type {UserResponse}
     * @memberof EmojiResponse
     */
    'user'?: UserResponse | null;
}
/**
 * 
 * @export
 * @interface EntitlementResponse
 */
export interface EntitlementResponse {
    /**
     * 
     * @type {string}
     * @memberof EntitlementResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EntitlementResponse
     */
    'sku_id': string;
    /**
     * 
     * @type {string}
     * @memberof EntitlementResponse
     */
    'application_id': string;
    /**
     * 
     * @type {string}
     * @memberof EntitlementResponse
     */
    'user_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementResponse
     */
    'deleted': boolean;
    /**
     * 
     * @type {number}
     * @memberof EntitlementResponse
     */
    'type': number | null;
    /**
     * 
     * @type {string}
     * @memberof EntitlementResponse
     */
    'guild_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntitlementResponse
     */
    'starts_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EntitlementResponse
     */
    'ends_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EntitlementResponse
     */
    'fulfilled_at'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EntitlementResponse
     */
    'fulfillment_status'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementResponse
     */
    'consumed'?: boolean | null;
}
/**
 * 
 * @export
 * @interface EntityMetadataExternal
 */
export interface EntityMetadataExternal {
    /**
     * 
     * @type {string}
     * @memberof EntityMetadataExternal
     */
    'location': string;
}
/**
 * 
 * @export
 * @interface EntityMetadataExternalResponse
 */
export interface EntityMetadataExternalResponse {
    /**
     * 
     * @type {string}
     * @memberof EntityMetadataExternalResponse
     */
    'location': string;
}
/**
 * @type ErrorDetails
 * @export
 */
export type ErrorDetails = InnerErrors | { [key: string]: ErrorDetails; };

/**
 * Errors object returned by the Discord API
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * Discord internal error code. See error code reference
     * @type {number}
     * @memberof ErrorResponse
     */
    'code': number;
    /**
     * Human-readable error message
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     * 
     * @type {ErrorDetails}
     * @memberof ErrorResponse
     */
    'errors'?: ErrorDetails;
}
/**
 * 
 * @export
 * @interface ExecuteWebhookRequest
 */
export interface ExecuteWebhookRequest {
    /**
     * 
     * @type {string}
     * @memberof ExecuteWebhookRequest
     */
    'content'?: string;
    /**
     * 
     * @type {Array<RichEmbed>}
     * @memberof ExecuteWebhookRequest
     */
    'embeds'?: Array<RichEmbed>;
    /**
     * 
     * @type {MessageAllowedMentionsRequest}
     * @memberof ExecuteWebhookRequest
     */
    'allowed_mentions'?: MessageAllowedMentionsRequest;
    /**
     * 
     * @type {Array<BaseCreateMessageCreateRequestComponentsInner>}
     * @memberof ExecuteWebhookRequest
     */
    'components'?: Array<BaseCreateMessageCreateRequestComponentsInner>;
    /**
     * 
     * @type {Array<MessageAttachmentRequest>}
     * @memberof ExecuteWebhookRequest
     */
    'attachments'?: Array<MessageAttachmentRequest>;
    /**
     * 
     * @type {PollCreateRequest}
     * @memberof ExecuteWebhookRequest
     */
    'poll'?: PollCreateRequest;
    /**
     * 
     * @type {boolean}
     * @memberof ExecuteWebhookRequest
     */
    'tts'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExecuteWebhookRequest
     */
    'flags'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExecuteWebhookRequest
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecuteWebhookRequest
     */
    'avatar_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecuteWebhookRequest
     */
    'thread_name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExecuteWebhookRequest
     */
    'applied_tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ExternalConnectionIntegrationResponse
 */
export interface ExternalConnectionIntegrationResponse {
    /**
     * 
     * @type {string}
     * @memberof ExternalConnectionIntegrationResponse
     */
    'type': string | null;
    /**
     * 
     * @type {string}
     * @memberof ExternalConnectionIntegrationResponse
     */
    'id': string;
    /**
     * 
     * @type {UserResponse}
     * @memberof ExternalConnectionIntegrationResponse
     */
    'user': UserResponse;
    /**
     * 
     * @type {string}
     * @memberof ExternalConnectionIntegrationResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {AccountResponse}
     * @memberof ExternalConnectionIntegrationResponse
     */
    'account'?: AccountResponse | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExternalConnectionIntegrationResponse
     */
    'enabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExternalConnectionIntegrationResponse
     */
    'revoked'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof ExternalConnectionIntegrationResponse
     */
    'expire_behavior'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExternalConnectionIntegrationResponse
     */
    'expire_grace_period'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExternalConnectionIntegrationResponse
     */
    'subscriber_count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExternalConnectionIntegrationResponse
     */
    'synced_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExternalConnectionIntegrationResponse
     */
    'role_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExternalConnectionIntegrationResponse
     */
    'syncing'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExternalConnectionIntegrationResponse
     */
    'enable_emoticons'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ExternalScheduledEventCreateRequest
 */
export interface ExternalScheduledEventCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventCreateRequest
     */
    'scheduled_start_time': string;
    /**
     * 
     * @type {any}
     * @memberof ExternalScheduledEventCreateRequest
     */
    'privacy_level': any;
    /**
     * 
     * @type {number}
     * @memberof ExternalScheduledEventCreateRequest
     */
    'entity_type': number | null;
    /**
     * 
     * @type {EntityMetadataExternal}
     * @memberof ExternalScheduledEventCreateRequest
     */
    'entity_metadata': EntityMetadataExternal;
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventCreateRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventCreateRequest
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventCreateRequest
     */
    'scheduled_end_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventCreateRequest
     */
    'channel_id'?: string;
}
/**
 * 
 * @export
 * @interface ExternalScheduledEventPatchRequestPartial
 */
export interface ExternalScheduledEventPatchRequestPartial {
    /**
     * 
     * @type {number}
     * @memberof ExternalScheduledEventPatchRequestPartial
     */
    'status'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventPatchRequestPartial
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventPatchRequestPartial
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventPatchRequestPartial
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventPatchRequestPartial
     */
    'scheduled_start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventPatchRequestPartial
     */
    'scheduled_end_time'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExternalScheduledEventPatchRequestPartial
     */
    'entity_type'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof ExternalScheduledEventPatchRequestPartial
     */
    'privacy_level'?: any;
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventPatchRequestPartial
     */
    'channel_id'?: string;
    /**
     * 
     * @type {EntityMetadataExternal}
     * @memberof ExternalScheduledEventPatchRequestPartial
     */
    'entity_metadata'?: EntityMetadataExternal;
}
/**
 * 
 * @export
 * @interface ExternalScheduledEventResponse
 */
export interface ExternalScheduledEventResponse {
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventResponse
     */
    'guild_id': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventResponse
     */
    'scheduled_start_time': string;
    /**
     * 
     * @type {number}
     * @memberof ExternalScheduledEventResponse
     */
    'status': number | null;
    /**
     * 
     * @type {number}
     * @memberof ExternalScheduledEventResponse
     */
    'entity_type': number | null;
    /**
     * 
     * @type {any}
     * @memberof ExternalScheduledEventResponse
     */
    'privacy_level': any;
    /**
     * 
     * @type {EntityMetadataExternalResponse}
     * @memberof ExternalScheduledEventResponse
     */
    'entity_metadata': EntityMetadataExternalResponse;
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventResponse
     */
    'channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventResponse
     */
    'creator_id'?: string;
    /**
     * 
     * @type {UserResponse}
     * @memberof ExternalScheduledEventResponse
     */
    'creator'?: UserResponse | null;
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventResponse
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventResponse
     */
    'scheduled_end_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExternalScheduledEventResponse
     */
    'entity_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExternalScheduledEventResponse
     */
    'user_count'?: number | null;
    /**
     * 
     * @type {ScheduledEventUserResponse}
     * @memberof ExternalScheduledEventResponse
     */
    'user_rsvp'?: ScheduledEventUserResponse | null;
}
/**
 * 
 * @export
 * @interface FileComponentForMessageRequest
 */
export interface FileComponentForMessageRequest {
    /**
     * 
     * @type {number}
     * @memberof FileComponentForMessageRequest
     */
    'type': number;
    /**
     * 
     * @type {UnfurledMediaRequestWithAttachmentReferenceRequired}
     * @memberof FileComponentForMessageRequest
     */
    'file': UnfurledMediaRequestWithAttachmentReferenceRequired;
    /**
     * 
     * @type {boolean}
     * @memberof FileComponentForMessageRequest
     */
    'spoiler'?: boolean | null;
}
/**
 * 
 * @export
 * @interface FileComponentResponse
 */
export interface FileComponentResponse {
    /**
     * 
     * @type {number}
     * @memberof FileComponentResponse
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof FileComponentResponse
     */
    'id': number;
    /**
     * 
     * @type {UnfurledMediaResponse}
     * @memberof FileComponentResponse
     */
    'file': UnfurledMediaResponse;
    /**
     * 
     * @type {boolean}
     * @memberof FileComponentResponse
     */
    'spoiler': boolean;
    /**
     * 
     * @type {string}
     * @memberof FileComponentResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FileComponentResponse
     */
    'size'?: number | null;
}
/**
 * 
 * @export
 * @interface FlagToChannelAction
 */
export interface FlagToChannelAction {
    /**
     * 
     * @type {number}
     * @memberof FlagToChannelAction
     */
    'type': number;
    /**
     * 
     * @type {FlagToChannelActionMetadata}
     * @memberof FlagToChannelAction
     */
    'metadata': FlagToChannelActionMetadata;
}
/**
 * 
 * @export
 * @interface FlagToChannelActionMetadata
 */
export interface FlagToChannelActionMetadata {
    /**
     * 
     * @type {string}
     * @memberof FlagToChannelActionMetadata
     */
    'channel_id': string;
}
/**
 * 
 * @export
 * @interface FlagToChannelActionMetadataResponse
 */
export interface FlagToChannelActionMetadataResponse {
    /**
     * 
     * @type {string}
     * @memberof FlagToChannelActionMetadataResponse
     */
    'channel_id': string;
}
/**
 * 
 * @export
 * @interface FlagToChannelActionResponse
 */
export interface FlagToChannelActionResponse {
    /**
     * 
     * @type {number}
     * @memberof FlagToChannelActionResponse
     */
    'type': number;
    /**
     * 
     * @type {FlagToChannelActionMetadataResponse}
     * @memberof FlagToChannelActionResponse
     */
    'metadata': FlagToChannelActionMetadataResponse;
}
/**
 * 
 * @export
 * @interface FollowChannelRequest
 */
export interface FollowChannelRequest {
    /**
     * 
     * @type {string}
     * @memberof FollowChannelRequest
     */
    'webhook_channel_id': string;
}
/**
 * 
 * @export
 * @interface ForumTagResponse
 */
export interface ForumTagResponse {
    /**
     * 
     * @type {string}
     * @memberof ForumTagResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ForumTagResponse
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ForumTagResponse
     */
    'moderated': boolean;
    /**
     * 
     * @type {string}
     * @memberof ForumTagResponse
     */
    'emoji_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForumTagResponse
     */
    'emoji_name'?: string | null;
}
/**
 * 
 * @export
 * @interface FriendInviteResponse
 */
export interface FriendInviteResponse {
    /**
     * 
     * @type {string}
     * @memberof FriendInviteResponse
     */
    'code': string;
    /**
     * 
     * @type {number}
     * @memberof FriendInviteResponse
     */
    'type'?: number | null;
    /**
     * 
     * @type {UserResponse}
     * @memberof FriendInviteResponse
     */
    'inviter'?: UserResponse | null;
    /**
     * 
     * @type {number}
     * @memberof FriendInviteResponse
     */
    'max_age'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FriendInviteResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FriendInviteResponse
     */
    'expires_at'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FriendInviteResponse
     */
    'friends_count'?: number | null;
    /**
     * 
     * @type {InviteChannelResponse}
     * @memberof FriendInviteResponse
     */
    'channel'?: InviteChannelResponse | null;
    /**
     * 
     * @type {boolean}
     * @memberof FriendInviteResponse
     */
    'is_contact'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof FriendInviteResponse
     */
    'uses'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FriendInviteResponse
     */
    'max_uses'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FriendInviteResponse
     */
    'flags'?: number | null;
}
/**
 * 
 * @export
 * @interface GatewayBotResponse
 */
export interface GatewayBotResponse {
    /**
     * 
     * @type {string}
     * @memberof GatewayBotResponse
     */
    'url': string;
    /**
     * 
     * @type {GatewayBotSessionStartLimitResponse}
     * @memberof GatewayBotResponse
     */
    'session_start_limit': GatewayBotSessionStartLimitResponse;
    /**
     * 
     * @type {number}
     * @memberof GatewayBotResponse
     */
    'shards': number;
}
/**
 * 
 * @export
 * @interface GatewayBotSessionStartLimitResponse
 */
export interface GatewayBotSessionStartLimitResponse {
    /**
     * 
     * @type {number}
     * @memberof GatewayBotSessionStartLimitResponse
     */
    'max_concurrency': number;
    /**
     * 
     * @type {number}
     * @memberof GatewayBotSessionStartLimitResponse
     */
    'remaining': number;
    /**
     * 
     * @type {number}
     * @memberof GatewayBotSessionStartLimitResponse
     */
    'reset_after': number;
    /**
     * 
     * @type {number}
     * @memberof GatewayBotSessionStartLimitResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface GatewayResponse
 */
export interface GatewayResponse {
    /**
     * 
     * @type {string}
     * @memberof GatewayResponse
     */
    'url': string;
}
/**
 * @type GetChannel200Response
 * @export
 */
export type GetChannel200Response = GuildChannelResponse | PrivateChannelResponse | PrivateGroupChannelResponse | ThreadResponse;

/**
 * @type GetEntitlementsSkuIdsParameter
 * @export
 */
export type GetEntitlementsSkuIdsParameter = Set<string | null> | string;

/**
 * @type GetSticker200Response
 * @export
 */
export type GetSticker200Response = GuildStickerResponse | StandardStickerResponse;

/**
 * 
 * @export
 * @interface GithubAuthor
 */
export interface GithubAuthor {
    /**
     * 
     * @type {string}
     * @memberof GithubAuthor
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GithubAuthor
     */
    'username'?: string | null;
}
/**
 * 
 * @export
 * @interface GithubCheckApp
 */
export interface GithubCheckApp {
    /**
     * 
     * @type {string}
     * @memberof GithubCheckApp
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GithubCheckPullRequest
 */
export interface GithubCheckPullRequest {
    /**
     * 
     * @type {number}
     * @memberof GithubCheckPullRequest
     */
    'number': number;
}
/**
 * 
 * @export
 * @interface GithubCheckRun
 */
export interface GithubCheckRun {
    /**
     * 
     * @type {string}
     * @memberof GithubCheckRun
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GithubCheckRun
     */
    'html_url': string;
    /**
     * 
     * @type {GithubCheckSuite}
     * @memberof GithubCheckRun
     */
    'check_suite': GithubCheckSuite;
    /**
     * 
     * @type {string}
     * @memberof GithubCheckRun
     */
    'conclusion'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GithubCheckRun
     */
    'details_url'?: string | null;
    /**
     * 
     * @type {GithubCheckRunOutput}
     * @memberof GithubCheckRun
     */
    'output'?: GithubCheckRunOutput | null;
    /**
     * 
     * @type {Array<GithubCheckPullRequest>}
     * @memberof GithubCheckRun
     */
    'pull_requests'?: Array<GithubCheckPullRequest> | null;
}
/**
 * 
 * @export
 * @interface GithubCheckRunOutput
 */
export interface GithubCheckRunOutput {
    /**
     * 
     * @type {string}
     * @memberof GithubCheckRunOutput
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GithubCheckRunOutput
     */
    'summary'?: string | null;
}
/**
 * 
 * @export
 * @interface GithubCheckSuite
 */
export interface GithubCheckSuite {
    /**
     * 
     * @type {string}
     * @memberof GithubCheckSuite
     */
    'head_sha': string;
    /**
     * 
     * @type {GithubCheckApp}
     * @memberof GithubCheckSuite
     */
    'app': GithubCheckApp;
    /**
     * 
     * @type {string}
     * @memberof GithubCheckSuite
     */
    'conclusion'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GithubCheckSuite
     */
    'head_branch'?: string | null;
    /**
     * 
     * @type {Array<GithubCheckPullRequest>}
     * @memberof GithubCheckSuite
     */
    'pull_requests'?: Array<GithubCheckPullRequest> | null;
}
/**
 * 
 * @export
 * @interface GithubComment
 */
export interface GithubComment {
    /**
     * 
     * @type {number}
     * @memberof GithubComment
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GithubComment
     */
    'html_url': string;
    /**
     * 
     * @type {GithubUser}
     * @memberof GithubComment
     */
    'user': GithubUser;
    /**
     * 
     * @type {string}
     * @memberof GithubComment
     */
    'body': string;
    /**
     * 
     * @type {string}
     * @memberof GithubComment
     */
    'commit_id'?: string | null;
}
/**
 * 
 * @export
 * @interface GithubCommit
 */
export interface GithubCommit {
    /**
     * 
     * @type {string}
     * @memberof GithubCommit
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GithubCommit
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof GithubCommit
     */
    'message': string;
    /**
     * 
     * @type {GithubAuthor}
     * @memberof GithubCommit
     */
    'author': GithubAuthor;
}
/**
 * 
 * @export
 * @interface GithubDiscussion
 */
export interface GithubDiscussion {
    /**
     * 
     * @type {string}
     * @memberof GithubDiscussion
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof GithubDiscussion
     */
    'number': number;
    /**
     * 
     * @type {string}
     * @memberof GithubDiscussion
     */
    'html_url': string;
    /**
     * 
     * @type {GithubUser}
     * @memberof GithubDiscussion
     */
    'user': GithubUser;
    /**
     * 
     * @type {string}
     * @memberof GithubDiscussion
     */
    'answer_html_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GithubDiscussion
     */
    'body'?: string | null;
}
/**
 * 
 * @export
 * @interface GithubIssue
 */
export interface GithubIssue {
    /**
     * 
     * @type {number}
     * @memberof GithubIssue
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof GithubIssue
     */
    'number': number;
    /**
     * 
     * @type {string}
     * @memberof GithubIssue
     */
    'html_url': string;
    /**
     * 
     * @type {GithubUser}
     * @memberof GithubIssue
     */
    'user': GithubUser;
    /**
     * 
     * @type {string}
     * @memberof GithubIssue
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof GithubIssue
     */
    'body'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof GithubIssue
     */
    'pull_request'?: any;
}
/**
 * 
 * @export
 * @interface GithubRelease
 */
export interface GithubRelease {
    /**
     * 
     * @type {number}
     * @memberof GithubRelease
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GithubRelease
     */
    'tag_name': string;
    /**
     * 
     * @type {string}
     * @memberof GithubRelease
     */
    'html_url': string;
    /**
     * 
     * @type {GithubUser}
     * @memberof GithubRelease
     */
    'author': GithubUser;
}
/**
 * 
 * @export
 * @interface GithubRepository
 */
export interface GithubRepository {
    /**
     * 
     * @type {number}
     * @memberof GithubRepository
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GithubRepository
     */
    'html_url': string;
    /**
     * 
     * @type {string}
     * @memberof GithubRepository
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GithubRepository
     */
    'full_name': string;
}
/**
 * 
 * @export
 * @interface GithubReview
 */
export interface GithubReview {
    /**
     * 
     * @type {GithubUser}
     * @memberof GithubReview
     */
    'user': GithubUser;
    /**
     * 
     * @type {string}
     * @memberof GithubReview
     */
    'html_url': string;
    /**
     * 
     * @type {string}
     * @memberof GithubReview
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof GithubReview
     */
    'body'?: string | null;
}
/**
 * 
 * @export
 * @interface GithubUser
 */
export interface GithubUser {
    /**
     * 
     * @type {number}
     * @memberof GithubUser
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GithubUser
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof GithubUser
     */
    'html_url': string;
    /**
     * 
     * @type {string}
     * @memberof GithubUser
     */
    'avatar_url': string;
}
/**
 * 
 * @export
 * @interface GithubWebhook
 */
export interface GithubWebhook {
    /**
     * 
     * @type {GithubUser}
     * @memberof GithubWebhook
     */
    'sender': GithubUser;
    /**
     * 
     * @type {string}
     * @memberof GithubWebhook
     */
    'action'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GithubWebhook
     */
    'ref'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GithubWebhook
     */
    'ref_type'?: string | null;
    /**
     * 
     * @type {GithubComment}
     * @memberof GithubWebhook
     */
    'comment'?: GithubComment | null;
    /**
     * 
     * @type {GithubIssue}
     * @memberof GithubWebhook
     */
    'issue'?: GithubIssue | null;
    /**
     * 
     * @type {GithubIssue}
     * @memberof GithubWebhook
     */
    'pull_request'?: GithubIssue | null;
    /**
     * 
     * @type {GithubRepository}
     * @memberof GithubWebhook
     */
    'repository'?: GithubRepository | null;
    /**
     * 
     * @type {GithubRepository}
     * @memberof GithubWebhook
     */
    'forkee'?: GithubRepository | null;
    /**
     * 
     * @type {GithubUser}
     * @memberof GithubWebhook
     */
    'member'?: GithubUser | null;
    /**
     * 
     * @type {GithubRelease}
     * @memberof GithubWebhook
     */
    'release'?: GithubRelease | null;
    /**
     * 
     * @type {GithubCommit}
     * @memberof GithubWebhook
     */
    'head_commit'?: GithubCommit | null;
    /**
     * 
     * @type {Array<GithubCommit>}
     * @memberof GithubWebhook
     */
    'commits'?: Array<GithubCommit> | null;
    /**
     * 
     * @type {boolean}
     * @memberof GithubWebhook
     */
    'forced'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof GithubWebhook
     */
    'compare'?: string | null;
    /**
     * 
     * @type {GithubReview}
     * @memberof GithubWebhook
     */
    'review'?: GithubReview | null;
    /**
     * 
     * @type {GithubCheckRun}
     * @memberof GithubWebhook
     */
    'check_run'?: GithubCheckRun | null;
    /**
     * 
     * @type {GithubCheckSuite}
     * @memberof GithubWebhook
     */
    'check_suite'?: GithubCheckSuite | null;
    /**
     * 
     * @type {GithubDiscussion}
     * @memberof GithubWebhook
     */
    'discussion'?: GithubDiscussion | null;
    /**
     * 
     * @type {GithubComment}
     * @memberof GithubWebhook
     */
    'answer'?: GithubComment | null;
}
/**
 * 
 * @export
 * @interface GroupDMInviteResponse
 */
export interface GroupDMInviteResponse {
    /**
     * 
     * @type {string}
     * @memberof GroupDMInviteResponse
     */
    'code': string;
    /**
     * 
     * @type {number}
     * @memberof GroupDMInviteResponse
     */
    'type'?: number | null;
    /**
     * 
     * @type {UserResponse}
     * @memberof GroupDMInviteResponse
     */
    'inviter'?: UserResponse | null;
    /**
     * 
     * @type {number}
     * @memberof GroupDMInviteResponse
     */
    'max_age'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GroupDMInviteResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupDMInviteResponse
     */
    'expires_at'?: string | null;
    /**
     * 
     * @type {InviteChannelResponse}
     * @memberof GroupDMInviteResponse
     */
    'channel'?: InviteChannelResponse | null;
    /**
     * 
     * @type {number}
     * @memberof GroupDMInviteResponse
     */
    'approximate_member_count'?: number | null;
}
/**
 * 
 * @export
 * @interface GuildAuditLogResponse
 */
export interface GuildAuditLogResponse {
    /**
     * 
     * @type {Array<AuditLogEntryResponse>}
     * @memberof GuildAuditLogResponse
     */
    'audit_log_entries': Array<AuditLogEntryResponse>;
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof GuildAuditLogResponse
     */
    'users': Array<UserResponse>;
    /**
     * 
     * @type {Array<GuildAuditLogResponseIntegrationsInner>}
     * @memberof GuildAuditLogResponse
     */
    'integrations': Array<GuildAuditLogResponseIntegrationsInner>;
    /**
     * 
     * @type {Array<ListChannelWebhooks200ResponseInner>}
     * @memberof GuildAuditLogResponse
     */
    'webhooks': Array<ListChannelWebhooks200ResponseInner>;
    /**
     * 
     * @type {Array<ListGuildScheduledEvents200ResponseInner>}
     * @memberof GuildAuditLogResponse
     */
    'guild_scheduled_events': Array<ListGuildScheduledEvents200ResponseInner>;
    /**
     * 
     * @type {Array<ThreadResponse>}
     * @memberof GuildAuditLogResponse
     */
    'threads': Array<ThreadResponse>;
    /**
     * 
     * @type {Array<ApplicationCommandResponse>}
     * @memberof GuildAuditLogResponse
     */
    'application_commands': Array<ApplicationCommandResponse>;
    /**
     * 
     * @type {Array<ListAutoModerationRules200ResponseInner>}
     * @memberof GuildAuditLogResponse
     */
    'auto_moderation_rules': Array<ListAutoModerationRules200ResponseInner>;
}
/**
 * @type GuildAuditLogResponseIntegrationsInner
 * @export
 */
export type GuildAuditLogResponseIntegrationsInner = PartialDiscordIntegrationResponse | PartialExternalConnectionIntegrationResponse | PartialGuildSubscriptionIntegrationResponse;

/**
 * 
 * @export
 * @interface GuildBanResponse
 */
export interface GuildBanResponse {
    /**
     * 
     * @type {UserResponse}
     * @memberof GuildBanResponse
     */
    'user': UserResponse;
    /**
     * 
     * @type {string}
     * @memberof GuildBanResponse
     */
    'reason'?: string | null;
}
/**
 * 
 * @export
 * @interface GuildChannelLocation
 */
export interface GuildChannelLocation {
    /**
     * 
     * @type {string}
     * @memberof GuildChannelLocation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GuildChannelLocation
     */
    'kind': string;
    /**
     * 
     * @type {string}
     * @memberof GuildChannelLocation
     */
    'channel_id': string;
    /**
     * 
     * @type {string}
     * @memberof GuildChannelLocation
     */
    'guild_id': string;
}
/**
 * 
 * @export
 * @interface GuildChannelResponse
 */
export interface GuildChannelResponse {
    /**
     * 
     * @type {string}
     * @memberof GuildChannelResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof GuildChannelResponse
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof GuildChannelResponse
     */
    'flags': number;
    /**
     * 
     * @type {string}
     * @memberof GuildChannelResponse
     */
    'guild_id': string;
    /**
     * 
     * @type {string}
     * @memberof GuildChannelResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GuildChannelResponse
     */
    'position': number;
    /**
     * 
     * @type {string}
     * @memberof GuildChannelResponse
     */
    'last_message_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildChannelResponse
     */
    'last_pin_timestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildChannelResponse
     */
    'parent_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof GuildChannelResponse
     */
    'rate_limit_per_user'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GuildChannelResponse
     */
    'bitrate'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GuildChannelResponse
     */
    'user_limit'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GuildChannelResponse
     */
    'rtc_region'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GuildChannelResponse
     */
    'video_quality_mode'?: number;
    /**
     * 
     * @type {string}
     * @memberof GuildChannelResponse
     */
    'permissions'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildChannelResponse
     */
    'topic'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GuildChannelResponse
     */
    'default_auto_archive_duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof GuildChannelResponse
     */
    'default_thread_rate_limit_per_user'?: number | null;
    /**
     * 
     * @type {Array<ChannelPermissionOverwriteResponse>}
     * @memberof GuildChannelResponse
     */
    'permission_overwrites'?: Array<ChannelPermissionOverwriteResponse> | null;
    /**
     * 
     * @type {boolean}
     * @memberof GuildChannelResponse
     */
    'nsfw'?: boolean | null;
    /**
     * 
     * @type {Array<ForumTagResponse>}
     * @memberof GuildChannelResponse
     */
    'available_tags'?: Array<ForumTagResponse> | null;
    /**
     * 
     * @type {DefaultReactionEmojiResponse}
     * @memberof GuildChannelResponse
     */
    'default_reaction_emoji'?: DefaultReactionEmojiResponse | null;
    /**
     * 
     * @type {number}
     * @memberof GuildChannelResponse
     */
    'default_sort_order'?: number;
    /**
     * 
     * @type {number}
     * @memberof GuildChannelResponse
     */
    'default_forum_layout'?: number;
    /**
     * 
     * @type {string}
     * @memberof GuildChannelResponse
     */
    'default_tag_setting'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildChannelResponse
     */
    'hd_streaming_until'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildChannelResponse
     */
    'hd_streaming_buyer_id'?: string;
}
/**
 * 
 * @export
 * @interface GuildCreateRequest
 */
export interface GuildCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof GuildCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GuildCreateRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildCreateRequest
     */
    'region'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildCreateRequest
     */
    'icon'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GuildCreateRequest
     */
    'verification_level'?: number;
    /**
     * 
     * @type {number}
     * @memberof GuildCreateRequest
     */
    'default_message_notifications'?: number;
    /**
     * 
     * @type {number}
     * @memberof GuildCreateRequest
     */
    'explicit_content_filter'?: number;
    /**
     * 
     * @type {string}
     * @memberof GuildCreateRequest
     */
    'preferred_locale'?: string;
    /**
     * 
     * @type {number}
     * @memberof GuildCreateRequest
     */
    'afk_timeout'?: number | null;
    /**
     * 
     * @type {Array<CreateGuildRequestRoleItem>}
     * @memberof GuildCreateRequest
     */
    'roles'?: Array<CreateGuildRequestRoleItem> | null;
    /**
     * 
     * @type {Array<CreateGuildRequestChannelItem>}
     * @memberof GuildCreateRequest
     */
    'channels'?: Array<CreateGuildRequestChannelItem> | null;
    /**
     * 
     * @type {string}
     * @memberof GuildCreateRequest
     */
    'afk_channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildCreateRequest
     */
    'system_channel_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof GuildCreateRequest
     */
    'system_channel_flags'?: number | null;
}
/**
 * 
 * @export
 * @interface GuildHomeSettingsResponse
 */
export interface GuildHomeSettingsResponse {
    /**
     * 
     * @type {string}
     * @memberof GuildHomeSettingsResponse
     */
    'guild_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof GuildHomeSettingsResponse
     */
    'enabled': boolean;
    /**
     * 
     * @type {WelcomeMessageResponse}
     * @memberof GuildHomeSettingsResponse
     */
    'welcome_message'?: WelcomeMessageResponse | null;
    /**
     * 
     * @type {Array<NewMemberActionResponse | null>}
     * @memberof GuildHomeSettingsResponse
     */
    'new_member_actions'?: Array<NewMemberActionResponse | null> | null;
    /**
     * 
     * @type {Array<ResourceChannelResponse | null>}
     * @memberof GuildHomeSettingsResponse
     */
    'resource_channels'?: Array<ResourceChannelResponse | null> | null;
}
/**
 * 
 * @export
 * @interface GuildIncomingWebhookResponse
 */
export interface GuildIncomingWebhookResponse {
    /**
     * 
     * @type {string}
     * @memberof GuildIncomingWebhookResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GuildIncomingWebhookResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GuildIncomingWebhookResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof GuildIncomingWebhookResponse
     */
    'application_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildIncomingWebhookResponse
     */
    'avatar'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildIncomingWebhookResponse
     */
    'channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildIncomingWebhookResponse
     */
    'guild_id'?: string;
    /**
     * 
     * @type {UserResponse}
     * @memberof GuildIncomingWebhookResponse
     */
    'user'?: UserResponse | null;
    /**
     * 
     * @type {string}
     * @memberof GuildIncomingWebhookResponse
     */
    'token'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildIncomingWebhookResponse
     */
    'url'?: string | null;
}
/**
 * 
 * @export
 * @interface GuildInviteResponse
 */
export interface GuildInviteResponse {
    /**
     * 
     * @type {string}
     * @memberof GuildInviteResponse
     */
    'code': string;
    /**
     * 
     * @type {number}
     * @memberof GuildInviteResponse
     */
    'type'?: number | null;
    /**
     * 
     * @type {UserResponse}
     * @memberof GuildInviteResponse
     */
    'inviter'?: UserResponse | null;
    /**
     * 
     * @type {number}
     * @memberof GuildInviteResponse
     */
    'max_age'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GuildInviteResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildInviteResponse
     */
    'expires_at'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GuildInviteResponse
     */
    'is_contact'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof GuildInviteResponse
     */
    'flags'?: number | null;
    /**
     * 
     * @type {InviteGuildResponse}
     * @memberof GuildInviteResponse
     */
    'guild'?: InviteGuildResponse | null;
    /**
     * 
     * @type {string}
     * @memberof GuildInviteResponse
     */
    'guild_id'?: string;
    /**
     * 
     * @type {InviteChannelResponse}
     * @memberof GuildInviteResponse
     */
    'channel'?: InviteChannelResponse | null;
    /**
     * 
     * @type {number}
     * @memberof GuildInviteResponse
     */
    'target_type'?: number | null;
    /**
     * 
     * @type {UserResponse}
     * @memberof GuildInviteResponse
     */
    'target_user'?: UserResponse | null;
    /**
     * 
     * @type {InviteApplicationResponse}
     * @memberof GuildInviteResponse
     */
    'target_application'?: InviteApplicationResponse | null;
    /**
     * 
     * @type {ScheduledEventResponse}
     * @memberof GuildInviteResponse
     */
    'guild_scheduled_event'?: ScheduledEventResponse | null;
    /**
     * 
     * @type {number}
     * @memberof GuildInviteResponse
     */
    'uses'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GuildInviteResponse
     */
    'max_uses'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof GuildInviteResponse
     */
    'temporary'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof GuildInviteResponse
     */
    'approximate_member_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GuildInviteResponse
     */
    'approximate_presence_count'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof GuildInviteResponse
     */
    'is_nickname_changeable'?: boolean | null;
}
/**
 * 
 * @export
 * @interface GuildMFALevelResponse
 */
export interface GuildMFALevelResponse {
    /**
     * 
     * @type {number}
     * @memberof GuildMFALevelResponse
     */
    'level': number;
}
/**
 * 
 * @export
 * @interface GuildMemberResponse
 */
export interface GuildMemberResponse {
    /**
     * 
     * @type {number}
     * @memberof GuildMemberResponse
     */
    'flags': number;
    /**
     * 
     * @type {string}
     * @memberof GuildMemberResponse
     */
    'joined_at': string;
    /**
     * 
     * @type {boolean}
     * @memberof GuildMemberResponse
     */
    'pending': boolean;
    /**
     * 
     * @type {Set<string>}
     * @memberof GuildMemberResponse
     */
    'roles': Set<string>;
    /**
     * 
     * @type {UserResponse}
     * @memberof GuildMemberResponse
     */
    'user': UserResponse;
    /**
     * 
     * @type {boolean}
     * @memberof GuildMemberResponse
     */
    'mute': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GuildMemberResponse
     */
    'deaf': boolean;
    /**
     * 
     * @type {string}
     * @memberof GuildMemberResponse
     */
    'avatar'?: string | null;
    /**
     * 
     * @type {UserAvatarDecorationResponse}
     * @memberof GuildMemberResponse
     */
    'avatar_decoration_data'?: UserAvatarDecorationResponse | null;
    /**
     * 
     * @type {string}
     * @memberof GuildMemberResponse
     */
    'banner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildMemberResponse
     */
    'communication_disabled_until'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildMemberResponse
     */
    'nick'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildMemberResponse
     */
    'premium_since'?: string | null;
}
/**
 * 
 * @export
 * @interface GuildOnboardingResponse
 */
export interface GuildOnboardingResponse {
    /**
     * 
     * @type {string}
     * @memberof GuildOnboardingResponse
     */
    'guild_id': string;
    /**
     * 
     * @type {Array<OnboardingPromptResponse>}
     * @memberof GuildOnboardingResponse
     */
    'prompts': Array<OnboardingPromptResponse>;
    /**
     * 
     * @type {Set<string>}
     * @memberof GuildOnboardingResponse
     */
    'default_channel_ids': Set<string>;
    /**
     * 
     * @type {boolean}
     * @memberof GuildOnboardingResponse
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface GuildPatchRequestPartial
 */
export interface GuildPatchRequestPartial {
    /**
     * 
     * @type {string}
     * @memberof GuildPatchRequestPartial
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildPatchRequestPartial
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildPatchRequestPartial
     */
    'region'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildPatchRequestPartial
     */
    'icon'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GuildPatchRequestPartial
     */
    'verification_level'?: number;
    /**
     * 
     * @type {number}
     * @memberof GuildPatchRequestPartial
     */
    'default_message_notifications'?: number;
    /**
     * 
     * @type {number}
     * @memberof GuildPatchRequestPartial
     */
    'explicit_content_filter'?: number;
    /**
     * 
     * @type {string}
     * @memberof GuildPatchRequestPartial
     */
    'preferred_locale'?: string;
    /**
     * 
     * @type {number}
     * @memberof GuildPatchRequestPartial
     */
    'afk_timeout'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GuildPatchRequestPartial
     */
    'afk_channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildPatchRequestPartial
     */
    'system_channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildPatchRequestPartial
     */
    'owner_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildPatchRequestPartial
     */
    'splash'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildPatchRequestPartial
     */
    'banner'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GuildPatchRequestPartial
     */
    'system_channel_flags'?: number | null;
    /**
     * 
     * @type {Set<string | null>}
     * @memberof GuildPatchRequestPartial
     */
    'features'?: Set<string | null> | null;
    /**
     * 
     * @type {string}
     * @memberof GuildPatchRequestPartial
     */
    'discovery_splash'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildPatchRequestPartial
     */
    'home_header'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildPatchRequestPartial
     */
    'rules_channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildPatchRequestPartial
     */
    'safety_alerts_channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildPatchRequestPartial
     */
    'public_updates_channel_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GuildPatchRequestPartial
     */
    'premium_progress_bar_enabled'?: boolean | null;
}
/**
 * 
 * @export
 * @interface GuildPreviewResponse
 */
export interface GuildPreviewResponse {
    /**
     * 
     * @type {string}
     * @memberof GuildPreviewResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GuildPreviewResponse
     */
    'name': string;
    /**
     * 
     * @type {Set<string>}
     * @memberof GuildPreviewResponse
     */
    'features': Set<string>;
    /**
     * 
     * @type {number}
     * @memberof GuildPreviewResponse
     */
    'approximate_member_count': number;
    /**
     * 
     * @type {number}
     * @memberof GuildPreviewResponse
     */
    'approximate_presence_count': number;
    /**
     * 
     * @type {Array<EmojiResponse>}
     * @memberof GuildPreviewResponse
     */
    'emojis': Array<EmojiResponse>;
    /**
     * 
     * @type {Array<GuildStickerResponse>}
     * @memberof GuildPreviewResponse
     */
    'stickers': Array<GuildStickerResponse>;
    /**
     * 
     * @type {string}
     * @memberof GuildPreviewResponse
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildPreviewResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildPreviewResponse
     */
    'home_header'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildPreviewResponse
     */
    'splash'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildPreviewResponse
     */
    'discovery_splash'?: string | null;
}
/**
 * 
 * @export
 * @interface GuildProductPurchaseResponse
 */
export interface GuildProductPurchaseResponse {
    /**
     * 
     * @type {string}
     * @memberof GuildProductPurchaseResponse
     */
    'listing_id': string;
    /**
     * 
     * @type {string}
     * @memberof GuildProductPurchaseResponse
     */
    'product_name': string;
}
/**
 * 
 * @export
 * @interface GuildPruneResponse
 */
export interface GuildPruneResponse {
    /**
     * 
     * @type {number}
     * @memberof GuildPruneResponse
     */
    'pruned'?: number | null;
}
/**
 * 
 * @export
 * @interface GuildResponse
 */
export interface GuildResponse {
    /**
     * 
     * @type {string}
     * @memberof GuildResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GuildResponse
     */
    'name': string;
    /**
     * 
     * @type {Set<string>}
     * @memberof GuildResponse
     */
    'features': Set<string>;
    /**
     * 
     * @type {string}
     * @memberof GuildResponse
     */
    'owner_id': string;
    /**
     * 
     * @type {string}
     * @memberof GuildResponse
     */
    'region': string;
    /**
     * 
     * @type {number}
     * @memberof GuildResponse
     */
    'afk_timeout': number | null;
    /**
     * 
     * @type {number}
     * @memberof GuildResponse
     */
    'system_channel_flags': number;
    /**
     * 
     * @type {boolean}
     * @memberof GuildResponse
     */
    'widget_enabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof GuildResponse
     */
    'verification_level': number;
    /**
     * 
     * @type {Array<GuildRoleResponse>}
     * @memberof GuildResponse
     */
    'roles': Array<GuildRoleResponse>;
    /**
     * 
     * @type {number}
     * @memberof GuildResponse
     */
    'default_message_notifications': number;
    /**
     * 
     * @type {number}
     * @memberof GuildResponse
     */
    'mfa_level': number;
    /**
     * 
     * @type {number}
     * @memberof GuildResponse
     */
    'explicit_content_filter': number;
    /**
     * 
     * @type {number}
     * @memberof GuildResponse
     */
    'premium_tier': number;
    /**
     * 
     * @type {number}
     * @memberof GuildResponse
     */
    'premium_subscription_count': number;
    /**
     * 
     * @type {string}
     * @memberof GuildResponse
     */
    'preferred_locale': string;
    /**
     * 
     * @type {boolean}
     * @memberof GuildResponse
     */
    'premium_progress_bar_enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GuildResponse
     */
    'nsfw': boolean;
    /**
     * 
     * @type {number}
     * @memberof GuildResponse
     */
    'nsfw_level': number | null;
    /**
     * 
     * @type {Array<EmojiResponse>}
     * @memberof GuildResponse
     */
    'emojis': Array<EmojiResponse>;
    /**
     * 
     * @type {Array<GuildStickerResponse>}
     * @memberof GuildResponse
     */
    'stickers': Array<GuildStickerResponse>;
    /**
     * 
     * @type {string}
     * @memberof GuildResponse
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildResponse
     */
    'home_header'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildResponse
     */
    'splash'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildResponse
     */
    'discovery_splash'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildResponse
     */
    'banner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildResponse
     */
    'application_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildResponse
     */
    'afk_channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildResponse
     */
    'system_channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildResponse
     */
    'widget_channel_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof GuildResponse
     */
    'max_presences'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GuildResponse
     */
    'max_members'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GuildResponse
     */
    'max_stage_video_channel_users'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GuildResponse
     */
    'max_video_channel_users'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GuildResponse
     */
    'vanity_url_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildResponse
     */
    'rules_channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildResponse
     */
    'safety_alerts_channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildResponse
     */
    'public_updates_channel_id'?: string;
}
/**
 * 
 * @export
 * @interface GuildRoleResponse
 */
export interface GuildRoleResponse {
    /**
     * 
     * @type {string}
     * @memberof GuildRoleResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GuildRoleResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GuildRoleResponse
     */
    'permissions': string;
    /**
     * 
     * @type {number}
     * @memberof GuildRoleResponse
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof GuildRoleResponse
     */
    'color': number;
    /**
     * 
     * @type {boolean}
     * @memberof GuildRoleResponse
     */
    'hoist': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GuildRoleResponse
     */
    'managed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GuildRoleResponse
     */
    'mentionable': boolean;
    /**
     * 
     * @type {string}
     * @memberof GuildRoleResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildRoleResponse
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildRoleResponse
     */
    'unicode_emoji'?: string | null;
    /**
     * 
     * @type {GuildRoleTagsResponse}
     * @memberof GuildRoleResponse
     */
    'tags'?: GuildRoleTagsResponse | null;
}
/**
 * 
 * @export
 * @interface GuildRoleTagsResponse
 */
export interface GuildRoleTagsResponse {
    /**
     * 
     * @type {any}
     * @memberof GuildRoleTagsResponse
     */
    'premium_subscriber'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof GuildRoleTagsResponse
     */
    'bot_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildRoleTagsResponse
     */
    'integration_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildRoleTagsResponse
     */
    'subscription_listing_id'?: string;
    /**
     * 
     * @type {any}
     * @memberof GuildRoleTagsResponse
     */
    'available_for_purchase'?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GuildRoleTagsResponse
     */
    'guild_connections'?: any | null;
}
/**
 * 
 * @export
 * @interface GuildStickerResponse
 */
export interface GuildStickerResponse {
    /**
     * 
     * @type {string}
     * @memberof GuildStickerResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GuildStickerResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GuildStickerResponse
     */
    'tags': string;
    /**
     * 
     * @type {number}
     * @memberof GuildStickerResponse
     */
    'type': number;
    /**
     * 
     * @type {boolean}
     * @memberof GuildStickerResponse
     */
    'available': boolean;
    /**
     * 
     * @type {string}
     * @memberof GuildStickerResponse
     */
    'guild_id': string;
    /**
     * 
     * @type {number}
     * @memberof GuildStickerResponse
     */
    'format_type'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GuildStickerResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {UserResponse}
     * @memberof GuildStickerResponse
     */
    'user'?: UserResponse | null;
}
/**
 * 
 * @export
 * @interface GuildSubscriptionIntegrationResponse
 */
export interface GuildSubscriptionIntegrationResponse {
    /**
     * 
     * @type {string}
     * @memberof GuildSubscriptionIntegrationResponse
     */
    'type': string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildSubscriptionIntegrationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GuildSubscriptionIntegrationResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {AccountResponse}
     * @memberof GuildSubscriptionIntegrationResponse
     */
    'account'?: AccountResponse | null;
    /**
     * 
     * @type {boolean}
     * @memberof GuildSubscriptionIntegrationResponse
     */
    'enabled'?: boolean | null;
}
/**
 * 
 * @export
 * @interface GuildTemplateChannelResponse
 */
export interface GuildTemplateChannelResponse {
    /**
     * 
     * @type {number}
     * @memberof GuildTemplateChannelResponse
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof GuildTemplateChannelResponse
     */
    'bitrate': number;
    /**
     * 
     * @type {number}
     * @memberof GuildTemplateChannelResponse
     */
    'user_limit': number;
    /**
     * 
     * @type {boolean}
     * @memberof GuildTemplateChannelResponse
     */
    'nsfw': boolean;
    /**
     * 
     * @type {number}
     * @memberof GuildTemplateChannelResponse
     */
    'rate_limit_per_user': number;
    /**
     * 
     * @type {Array<ChannelPermissionOverwriteResponse | null>}
     * @memberof GuildTemplateChannelResponse
     */
    'permission_overwrites': Array<ChannelPermissionOverwriteResponse | null>;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateChannelResponse
     */
    'template': string;
    /**
     * 
     * @type {number}
     * @memberof GuildTemplateChannelResponse
     */
    'id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateChannelResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GuildTemplateChannelResponse
     */
    'position'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateChannelResponse
     */
    'topic'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateChannelResponse
     */
    'parent_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof GuildTemplateChannelResponse
     */
    'default_auto_archive_duration'?: number;
    /**
     * 
     * @type {Array<GuildTemplateChannelTags>}
     * @memberof GuildTemplateChannelResponse
     */
    'available_tags'?: Array<GuildTemplateChannelTags> | null;
    /**
     * 
     * @type {DefaultReactionEmojiResponse}
     * @memberof GuildTemplateChannelResponse
     */
    'default_reaction_emoji'?: DefaultReactionEmojiResponse | null;
    /**
     * 
     * @type {number}
     * @memberof GuildTemplateChannelResponse
     */
    'default_thread_rate_limit_per_user'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GuildTemplateChannelResponse
     */
    'default_sort_order'?: number;
    /**
     * 
     * @type {number}
     * @memberof GuildTemplateChannelResponse
     */
    'default_forum_layout'?: number;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateChannelResponse
     */
    'default_tag_setting'?: string;
    /**
     * 
     * @type {object}
     * @memberof GuildTemplateChannelResponse
     */
    'icon_emoji'?: object;
    /**
     * 
     * @type {number}
     * @memberof GuildTemplateChannelResponse
     */
    'theme_color'?: number | null;
}
/**
 * 
 * @export
 * @interface GuildTemplateChannelTags
 */
export interface GuildTemplateChannelTags {
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateChannelTags
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateChannelTags
     */
    'emoji_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateChannelTags
     */
    'emoji_name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GuildTemplateChannelTags
     */
    'moderated'?: boolean | null;
}
/**
 * 
 * @export
 * @interface GuildTemplateResponse
 */
export interface GuildTemplateResponse {
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateResponse
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GuildTemplateResponse
     */
    'usage_count': number;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateResponse
     */
    'creator_id': string;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateResponse
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateResponse
     */
    'source_guild_id': string;
    /**
     * 
     * @type {GuildTemplateSnapshotResponse}
     * @memberof GuildTemplateResponse
     */
    'serialized_source_guild': GuildTemplateSnapshotResponse;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {UserResponse}
     * @memberof GuildTemplateResponse
     */
    'creator'?: UserResponse | null;
    /**
     * 
     * @type {boolean}
     * @memberof GuildTemplateResponse
     */
    'is_dirty'?: boolean | null;
}
/**
 * 
 * @export
 * @interface GuildTemplateRoleResponse
 */
export interface GuildTemplateRoleResponse {
    /**
     * 
     * @type {number}
     * @memberof GuildTemplateRoleResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateRoleResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateRoleResponse
     */
    'permissions': string;
    /**
     * 
     * @type {number}
     * @memberof GuildTemplateRoleResponse
     */
    'color': number;
    /**
     * 
     * @type {boolean}
     * @memberof GuildTemplateRoleResponse
     */
    'hoist': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GuildTemplateRoleResponse
     */
    'mentionable': boolean;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateRoleResponse
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateRoleResponse
     */
    'unicode_emoji'?: string | null;
}
/**
 * 
 * @export
 * @interface GuildTemplateSnapshotResponse
 */
export interface GuildTemplateSnapshotResponse {
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateSnapshotResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GuildTemplateSnapshotResponse
     */
    'verification_level': number;
    /**
     * 
     * @type {number}
     * @memberof GuildTemplateSnapshotResponse
     */
    'default_message_notifications': number;
    /**
     * 
     * @type {number}
     * @memberof GuildTemplateSnapshotResponse
     */
    'explicit_content_filter': number;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateSnapshotResponse
     */
    'preferred_locale': string;
    /**
     * 
     * @type {number}
     * @memberof GuildTemplateSnapshotResponse
     */
    'afk_timeout': number | null;
    /**
     * 
     * @type {number}
     * @memberof GuildTemplateSnapshotResponse
     */
    'system_channel_flags': number;
    /**
     * 
     * @type {Array<GuildTemplateRoleResponse>}
     * @memberof GuildTemplateSnapshotResponse
     */
    'roles': Array<GuildTemplateRoleResponse>;
    /**
     * 
     * @type {Array<GuildTemplateChannelResponse>}
     * @memberof GuildTemplateSnapshotResponse
     */
    'channels': Array<GuildTemplateChannelResponse>;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateSnapshotResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateSnapshotResponse
     */
    'region'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateSnapshotResponse
     */
    'afk_channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildTemplateSnapshotResponse
     */
    'system_channel_id'?: string;
}
/**
 * 
 * @export
 * @interface GuildWelcomeChannel
 */
export interface GuildWelcomeChannel {
    /**
     * 
     * @type {string}
     * @memberof GuildWelcomeChannel
     */
    'channel_id': string;
    /**
     * 
     * @type {string}
     * @memberof GuildWelcomeChannel
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof GuildWelcomeChannel
     */
    'emoji_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildWelcomeChannel
     */
    'emoji_name'?: string | null;
}
/**
 * 
 * @export
 * @interface GuildWelcomeScreenChannelResponse
 */
export interface GuildWelcomeScreenChannelResponse {
    /**
     * 
     * @type {string}
     * @memberof GuildWelcomeScreenChannelResponse
     */
    'channel_id': string;
    /**
     * 
     * @type {string}
     * @memberof GuildWelcomeScreenChannelResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof GuildWelcomeScreenChannelResponse
     */
    'emoji_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildWelcomeScreenChannelResponse
     */
    'emoji_name'?: string | null;
}
/**
 * 
 * @export
 * @interface GuildWelcomeScreenResponse
 */
export interface GuildWelcomeScreenResponse {
    /**
     * 
     * @type {Array<GuildWelcomeScreenChannelResponse>}
     * @memberof GuildWelcomeScreenResponse
     */
    'welcome_channels': Array<GuildWelcomeScreenChannelResponse>;
    /**
     * 
     * @type {string}
     * @memberof GuildWelcomeScreenResponse
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface GuildWithCountsResponse
 */
export interface GuildWithCountsResponse {
    /**
     * 
     * @type {string}
     * @memberof GuildWithCountsResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GuildWithCountsResponse
     */
    'name': string;
    /**
     * 
     * @type {Set<string>}
     * @memberof GuildWithCountsResponse
     */
    'features': Set<string>;
    /**
     * 
     * @type {string}
     * @memberof GuildWithCountsResponse
     */
    'owner_id': string;
    /**
     * 
     * @type {string}
     * @memberof GuildWithCountsResponse
     */
    'region': string;
    /**
     * 
     * @type {number}
     * @memberof GuildWithCountsResponse
     */
    'afk_timeout': number | null;
    /**
     * 
     * @type {number}
     * @memberof GuildWithCountsResponse
     */
    'system_channel_flags': number;
    /**
     * 
     * @type {boolean}
     * @memberof GuildWithCountsResponse
     */
    'widget_enabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof GuildWithCountsResponse
     */
    'verification_level': number;
    /**
     * 
     * @type {Array<GuildRoleResponse>}
     * @memberof GuildWithCountsResponse
     */
    'roles': Array<GuildRoleResponse>;
    /**
     * 
     * @type {number}
     * @memberof GuildWithCountsResponse
     */
    'default_message_notifications': number;
    /**
     * 
     * @type {number}
     * @memberof GuildWithCountsResponse
     */
    'mfa_level': number;
    /**
     * 
     * @type {number}
     * @memberof GuildWithCountsResponse
     */
    'explicit_content_filter': number;
    /**
     * 
     * @type {number}
     * @memberof GuildWithCountsResponse
     */
    'premium_tier': number;
    /**
     * 
     * @type {number}
     * @memberof GuildWithCountsResponse
     */
    'premium_subscription_count': number;
    /**
     * 
     * @type {string}
     * @memberof GuildWithCountsResponse
     */
    'preferred_locale': string;
    /**
     * 
     * @type {boolean}
     * @memberof GuildWithCountsResponse
     */
    'premium_progress_bar_enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GuildWithCountsResponse
     */
    'nsfw': boolean;
    /**
     * 
     * @type {number}
     * @memberof GuildWithCountsResponse
     */
    'nsfw_level': number | null;
    /**
     * 
     * @type {Array<EmojiResponse>}
     * @memberof GuildWithCountsResponse
     */
    'emojis': Array<EmojiResponse>;
    /**
     * 
     * @type {Array<GuildStickerResponse>}
     * @memberof GuildWithCountsResponse
     */
    'stickers': Array<GuildStickerResponse>;
    /**
     * 
     * @type {string}
     * @memberof GuildWithCountsResponse
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildWithCountsResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildWithCountsResponse
     */
    'home_header'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildWithCountsResponse
     */
    'splash'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildWithCountsResponse
     */
    'discovery_splash'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildWithCountsResponse
     */
    'banner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildWithCountsResponse
     */
    'application_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildWithCountsResponse
     */
    'afk_channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildWithCountsResponse
     */
    'system_channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildWithCountsResponse
     */
    'widget_channel_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof GuildWithCountsResponse
     */
    'max_presences'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GuildWithCountsResponse
     */
    'max_members'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GuildWithCountsResponse
     */
    'max_stage_video_channel_users'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GuildWithCountsResponse
     */
    'max_video_channel_users'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GuildWithCountsResponse
     */
    'vanity_url_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GuildWithCountsResponse
     */
    'rules_channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildWithCountsResponse
     */
    'safety_alerts_channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildWithCountsResponse
     */
    'public_updates_channel_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof GuildWithCountsResponse
     */
    'approximate_member_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GuildWithCountsResponse
     */
    'approximate_presence_count'?: number | null;
}
/**
 * 
 * @export
 * @interface IncomingWebhookInteractionRequest
 */
export interface IncomingWebhookInteractionRequest {
    /**
     * 
     * @type {string}
     * @memberof IncomingWebhookInteractionRequest
     */
    'content'?: string | null;
    /**
     * 
     * @type {Array<RichEmbed>}
     * @memberof IncomingWebhookInteractionRequest
     */
    'embeds'?: Array<RichEmbed> | null;
    /**
     * 
     * @type {MessageAllowedMentionsRequest}
     * @memberof IncomingWebhookInteractionRequest
     */
    'allowed_mentions'?: MessageAllowedMentionsRequest | null;
    /**
     * 
     * @type {Array<BaseCreateMessageCreateRequestComponentsInner>}
     * @memberof IncomingWebhookInteractionRequest
     */
    'components'?: Array<BaseCreateMessageCreateRequestComponentsInner> | null;
    /**
     * 
     * @type {Array<MessageAttachmentRequest>}
     * @memberof IncomingWebhookInteractionRequest
     */
    'attachments'?: Array<MessageAttachmentRequest> | null;
    /**
     * 
     * @type {PollCreateRequest}
     * @memberof IncomingWebhookInteractionRequest
     */
    'poll'?: PollCreateRequest | null;
    /**
     * 
     * @type {boolean}
     * @memberof IncomingWebhookInteractionRequest
     */
    'tts'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof IncomingWebhookInteractionRequest
     */
    'flags'?: number | null;
}
/**
 * 
 * @export
 * @interface IncomingWebhookRequestPartial
 */
export interface IncomingWebhookRequestPartial {
    /**
     * 
     * @type {string}
     * @memberof IncomingWebhookRequestPartial
     */
    'content'?: string | null;
    /**
     * 
     * @type {Array<RichEmbed>}
     * @memberof IncomingWebhookRequestPartial
     */
    'embeds'?: Array<RichEmbed> | null;
    /**
     * 
     * @type {MessageAllowedMentionsRequest}
     * @memberof IncomingWebhookRequestPartial
     */
    'allowed_mentions'?: MessageAllowedMentionsRequest | null;
    /**
     * 
     * @type {Array<BaseCreateMessageCreateRequestComponentsInner>}
     * @memberof IncomingWebhookRequestPartial
     */
    'components'?: Array<BaseCreateMessageCreateRequestComponentsInner> | null;
    /**
     * 
     * @type {Array<MessageAttachmentRequest>}
     * @memberof IncomingWebhookRequestPartial
     */
    'attachments'?: Array<MessageAttachmentRequest> | null;
    /**
     * 
     * @type {PollCreateRequest}
     * @memberof IncomingWebhookRequestPartial
     */
    'poll'?: PollCreateRequest | null;
    /**
     * 
     * @type {boolean}
     * @memberof IncomingWebhookRequestPartial
     */
    'tts'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof IncomingWebhookRequestPartial
     */
    'flags'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof IncomingWebhookRequestPartial
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IncomingWebhookRequestPartial
     */
    'avatar_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IncomingWebhookRequestPartial
     */
    'thread_name'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof IncomingWebhookRequestPartial
     */
    'applied_tags'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface IncomingWebhookUpdateForInteractionCallbackRequestPartial
 */
export interface IncomingWebhookUpdateForInteractionCallbackRequestPartial {
    /**
     * 
     * @type {string}
     * @memberof IncomingWebhookUpdateForInteractionCallbackRequestPartial
     */
    'content'?: string | null;
    /**
     * 
     * @type {Array<RichEmbed>}
     * @memberof IncomingWebhookUpdateForInteractionCallbackRequestPartial
     */
    'embeds'?: Array<RichEmbed> | null;
    /**
     * 
     * @type {MessageAllowedMentionsRequest}
     * @memberof IncomingWebhookUpdateForInteractionCallbackRequestPartial
     */
    'allowed_mentions'?: MessageAllowedMentionsRequest | null;
    /**
     * 
     * @type {Array<BaseCreateMessageCreateRequestComponentsInner>}
     * @memberof IncomingWebhookUpdateForInteractionCallbackRequestPartial
     */
    'components'?: Array<BaseCreateMessageCreateRequestComponentsInner> | null;
    /**
     * 
     * @type {Array<MessageAttachmentRequest>}
     * @memberof IncomingWebhookUpdateForInteractionCallbackRequestPartial
     */
    'attachments'?: Array<MessageAttachmentRequest> | null;
    /**
     * 
     * @type {number}
     * @memberof IncomingWebhookUpdateForInteractionCallbackRequestPartial
     */
    'flags'?: number | null;
}
/**
 * 
 * @export
 * @interface IncomingWebhookUpdateRequestPartial
 */
export interface IncomingWebhookUpdateRequestPartial {
    /**
     * 
     * @type {string}
     * @memberof IncomingWebhookUpdateRequestPartial
     */
    'content'?: string | null;
    /**
     * 
     * @type {Array<RichEmbed>}
     * @memberof IncomingWebhookUpdateRequestPartial
     */
    'embeds'?: Array<RichEmbed> | null;
    /**
     * 
     * @type {MessageAllowedMentionsRequest}
     * @memberof IncomingWebhookUpdateRequestPartial
     */
    'allowed_mentions'?: MessageAllowedMentionsRequest | null;
    /**
     * 
     * @type {Array<BaseCreateMessageCreateRequestComponentsInner>}
     * @memberof IncomingWebhookUpdateRequestPartial
     */
    'components'?: Array<BaseCreateMessageCreateRequestComponentsInner> | null;
    /**
     * 
     * @type {Array<MessageAttachmentRequest>}
     * @memberof IncomingWebhookUpdateRequestPartial
     */
    'attachments'?: Array<MessageAttachmentRequest> | null;
    /**
     * 
     * @type {PollCreateRequest}
     * @memberof IncomingWebhookUpdateRequestPartial
     */
    'poll'?: PollCreateRequest | null;
    /**
     * 
     * @type {number}
     * @memberof IncomingWebhookUpdateRequestPartial
     */
    'flags'?: number | null;
}
/**
 * 
 * @export
 * @interface InnerErrors
 */
export interface InnerErrors {
    /**
     * The list of errors for this field
     * @type {Array<Error>}
     * @memberof InnerErrors
     */
    '_errors': Array<Error>;
}
/**
 * 
 * @export
 * @interface IntegrationApplicationResponse
 */
export interface IntegrationApplicationResponse {
    /**
     * 
     * @type {string}
     * @memberof IntegrationApplicationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationApplicationResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationApplicationResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationApplicationResponse
     */
    'icon'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IntegrationApplicationResponse
     */
    'type'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof IntegrationApplicationResponse
     */
    'cover_image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IntegrationApplicationResponse
     */
    'primary_sku_id'?: string;
    /**
     * 
     * @type {UserResponse}
     * @memberof IntegrationApplicationResponse
     */
    'bot'?: UserResponse | null;
}
/**
 * 
 * @export
 * @interface InteractionApplicationCommandAutocompleteCallbackIntegerData
 */
export interface InteractionApplicationCommandAutocompleteCallbackIntegerData {
    /**
     * 
     * @type {Array<ApplicationCommandOptionIntegerChoice | null>}
     * @memberof InteractionApplicationCommandAutocompleteCallbackIntegerData
     */
    'choices'?: Array<ApplicationCommandOptionIntegerChoice | null> | null;
}
/**
 * 
 * @export
 * @interface InteractionApplicationCommandAutocompleteCallbackNumberData
 */
export interface InteractionApplicationCommandAutocompleteCallbackNumberData {
    /**
     * 
     * @type {Array<ApplicationCommandOptionNumberChoice | null>}
     * @memberof InteractionApplicationCommandAutocompleteCallbackNumberData
     */
    'choices'?: Array<ApplicationCommandOptionNumberChoice | null> | null;
}
/**
 * 
 * @export
 * @interface InteractionApplicationCommandAutocompleteCallbackStringData
 */
export interface InteractionApplicationCommandAutocompleteCallbackStringData {
    /**
     * 
     * @type {Array<ApplicationCommandOptionStringChoice | null>}
     * @memberof InteractionApplicationCommandAutocompleteCallbackStringData
     */
    'choices'?: Array<ApplicationCommandOptionStringChoice | null> | null;
}
/**
 * 
 * @export
 * @interface InteractionCallbackResponse
 */
export interface InteractionCallbackResponse {
    /**
     * 
     * @type {InteractionResponse}
     * @memberof InteractionCallbackResponse
     */
    'interaction': InteractionResponse;
    /**
     * 
     * @type {InteractionCallbackResponseResource}
     * @memberof InteractionCallbackResponse
     */
    'resource'?: InteractionCallbackResponseResource | null;
}
/**
 * @type InteractionCallbackResponseResource
 * @export
 */
export type InteractionCallbackResponseResource = CreateMessageInteractionCallbackResponse | LaunchActivityInteractionCallbackResponse | UpdateMessageInteractionCallbackResponse;

/**
 * 
 * @export
 * @interface InteractionResponse
 */
export interface InteractionResponse {
    /**
     * 
     * @type {string}
     * @memberof InteractionResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof InteractionResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof InteractionResponse
     */
    'response_message_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InteractionResponse
     */
    'response_message_loading'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InteractionResponse
     */
    'response_message_ephemeral'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof InteractionResponse
     */
    'channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InteractionResponse
     */
    'guild_id'?: string;
}
/**
 * 
 * @export
 * @interface InviteApplicationResponse
 */
export interface InviteApplicationResponse {
    /**
     * 
     * @type {string}
     * @memberof InviteApplicationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InviteApplicationResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof InviteApplicationResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof InviteApplicationResponse
     */
    'verify_key': string;
    /**
     * 
     * @type {number}
     * @memberof InviteApplicationResponse
     */
    'flags': number;
    /**
     * 
     * @type {string}
     * @memberof InviteApplicationResponse
     */
    'icon'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InviteApplicationResponse
     */
    'type'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof InviteApplicationResponse
     */
    'cover_image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InviteApplicationResponse
     */
    'primary_sku_id'?: string;
    /**
     * 
     * @type {UserResponse}
     * @memberof InviteApplicationResponse
     */
    'bot'?: UserResponse | null;
    /**
     * 
     * @type {string}
     * @memberof InviteApplicationResponse
     */
    'slug'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InviteApplicationResponse
     */
    'guild_id'?: string;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof InviteApplicationResponse
     */
    'rpc_origins'?: Array<string | null> | null;
    /**
     * 
     * @type {boolean}
     * @memberof InviteApplicationResponse
     */
    'bot_public'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InviteApplicationResponse
     */
    'bot_require_code_grant'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof InviteApplicationResponse
     */
    'terms_of_service_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InviteApplicationResponse
     */
    'privacy_policy_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InviteApplicationResponse
     */
    'custom_install_url'?: string | null;
    /**
     * 
     * @type {ApplicationOAuth2InstallParamsResponse}
     * @memberof InviteApplicationResponse
     */
    'install_params'?: ApplicationOAuth2InstallParamsResponse | null;
    /**
     * 
     * @type {{ [key: string]: ApplicationIntegrationTypeConfigurationResponse; }}
     * @memberof InviteApplicationResponse
     */
    'integration_types_config'?: { [key: string]: ApplicationIntegrationTypeConfigurationResponse; };
    /**
     * 
     * @type {number}
     * @memberof InviteApplicationResponse
     */
    'max_participants'?: number | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof InviteApplicationResponse
     */
    'tags'?: Set<string> | null;
}
/**
 * 
 * @export
 * @interface InviteChannelRecipientResponse
 */
export interface InviteChannelRecipientResponse {
    /**
     * 
     * @type {string}
     * @memberof InviteChannelRecipientResponse
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface InviteChannelResponse
 */
export interface InviteChannelResponse {
    /**
     * 
     * @type {string}
     * @memberof InviteChannelResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof InviteChannelResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof InviteChannelResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InviteChannelResponse
     */
    'icon'?: string | null;
    /**
     * 
     * @type {Array<InviteChannelRecipientResponse>}
     * @memberof InviteChannelResponse
     */
    'recipients'?: Array<InviteChannelRecipientResponse> | null;
}
/**
 * 
 * @export
 * @interface InviteGuildResponse
 */
export interface InviteGuildResponse {
    /**
     * 
     * @type {string}
     * @memberof InviteGuildResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InviteGuildResponse
     */
    'name': string;
    /**
     * 
     * @type {Set<string>}
     * @memberof InviteGuildResponse
     */
    'features': Set<string>;
    /**
     * 
     * @type {string}
     * @memberof InviteGuildResponse
     */
    'splash'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InviteGuildResponse
     */
    'banner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InviteGuildResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InviteGuildResponse
     */
    'icon'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InviteGuildResponse
     */
    'verification_level'?: number;
    /**
     * 
     * @type {string}
     * @memberof InviteGuildResponse
     */
    'vanity_url_code'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InviteGuildResponse
     */
    'nsfw_level'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof InviteGuildResponse
     */
    'nsfw'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof InviteGuildResponse
     */
    'premium_subscription_count'?: number | null;
}
/**
 * 
 * @export
 * @interface KeywordRuleResponse
 */
export interface KeywordRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof KeywordRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof KeywordRuleResponse
     */
    'guild_id': string;
    /**
     * 
     * @type {string}
     * @memberof KeywordRuleResponse
     */
    'creator_id': string;
    /**
     * 
     * @type {string}
     * @memberof KeywordRuleResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof KeywordRuleResponse
     */
    'event_type': number;
    /**
     * 
     * @type {Array<DefaultKeywordRuleResponseActionsInner>}
     * @memberof KeywordRuleResponse
     */
    'actions': Array<DefaultKeywordRuleResponseActionsInner>;
    /**
     * 
     * @type {number}
     * @memberof KeywordRuleResponse
     */
    'trigger_type': number;
    /**
     * 
     * @type {KeywordTriggerMetadataResponse}
     * @memberof KeywordRuleResponse
     */
    'trigger_metadata': KeywordTriggerMetadataResponse;
    /**
     * 
     * @type {boolean}
     * @memberof KeywordRuleResponse
     */
    'enabled'?: boolean | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof KeywordRuleResponse
     */
    'exempt_roles'?: Set<string> | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof KeywordRuleResponse
     */
    'exempt_channels'?: Set<string> | null;
}
/**
 * 
 * @export
 * @interface KeywordTriggerMetadata
 */
export interface KeywordTriggerMetadata {
    /**
     * 
     * @type {Array<string>}
     * @memberof KeywordTriggerMetadata
     */
    'keyword_filter'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof KeywordTriggerMetadata
     */
    'regex_patterns'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof KeywordTriggerMetadata
     */
    'allow_list'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface KeywordTriggerMetadataResponse
 */
export interface KeywordTriggerMetadataResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof KeywordTriggerMetadataResponse
     */
    'keyword_filter': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof KeywordTriggerMetadataResponse
     */
    'regex_patterns': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof KeywordTriggerMetadataResponse
     */
    'allow_list': Array<string>;
}
/**
 * 
 * @export
 * @interface KeywordUpsertRequest
 */
export interface KeywordUpsertRequest {
    /**
     * 
     * @type {string}
     * @memberof KeywordUpsertRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof KeywordUpsertRequest
     */
    'event_type': number;
    /**
     * 
     * @type {number}
     * @memberof KeywordUpsertRequest
     */
    'trigger_type': number;
    /**
     * 
     * @type {Array<DefaultKeywordListUpsertRequestActionsInner>}
     * @memberof KeywordUpsertRequest
     */
    'actions'?: Array<DefaultKeywordListUpsertRequestActionsInner> | null;
    /**
     * 
     * @type {boolean}
     * @memberof KeywordUpsertRequest
     */
    'enabled'?: boolean | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof KeywordUpsertRequest
     */
    'exempt_roles'?: Set<string> | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof KeywordUpsertRequest
     */
    'exempt_channels'?: Set<string> | null;
    /**
     * 
     * @type {KeywordTriggerMetadata}
     * @memberof KeywordUpsertRequest
     */
    'trigger_metadata'?: KeywordTriggerMetadata | null;
}
/**
 * 
 * @export
 * @interface KeywordUpsertRequestPartial
 */
export interface KeywordUpsertRequestPartial {
    /**
     * 
     * @type {string}
     * @memberof KeywordUpsertRequestPartial
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof KeywordUpsertRequestPartial
     */
    'event_type'?: number;
    /**
     * 
     * @type {Array<DefaultKeywordListUpsertRequestActionsInner>}
     * @memberof KeywordUpsertRequestPartial
     */
    'actions'?: Array<DefaultKeywordListUpsertRequestActionsInner> | null;
    /**
     * 
     * @type {boolean}
     * @memberof KeywordUpsertRequestPartial
     */
    'enabled'?: boolean | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof KeywordUpsertRequestPartial
     */
    'exempt_roles'?: Set<string> | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof KeywordUpsertRequestPartial
     */
    'exempt_channels'?: Set<string> | null;
    /**
     * 
     * @type {number}
     * @memberof KeywordUpsertRequestPartial
     */
    'trigger_type'?: number;
    /**
     * 
     * @type {KeywordTriggerMetadata}
     * @memberof KeywordUpsertRequestPartial
     */
    'trigger_metadata'?: KeywordTriggerMetadata | null;
}
/**
 * 
 * @export
 * @interface LaunchActivityInteractionCallbackRequest
 */
export interface LaunchActivityInteractionCallbackRequest {
    /**
     * 
     * @type {number}
     * @memberof LaunchActivityInteractionCallbackRequest
     */
    'type': number | null;
}
/**
 * 
 * @export
 * @interface LaunchActivityInteractionCallbackResponse
 */
export interface LaunchActivityInteractionCallbackResponse {
    /**
     * 
     * @type {number}
     * @memberof LaunchActivityInteractionCallbackResponse
     */
    'type': number | null;
}
/**
 * 
 * @export
 * @interface ListApplicationEmojisResponse
 */
export interface ListApplicationEmojisResponse {
    /**
     * 
     * @type {Array<EmojiResponse>}
     * @memberof ListApplicationEmojisResponse
     */
    'items': Array<EmojiResponse>;
}
/**
 * @type ListAutoModerationRules200ResponseInner
 * @export
 */
export type ListAutoModerationRules200ResponseInner = DefaultKeywordRuleResponse | KeywordRuleResponse | MLSpamRuleResponse | MentionSpamRuleResponse | SpamLinkRuleResponse;

/**
 * 
 * @export
 * @interface ListChannelInvites200ResponseInner
 */
export interface ListChannelInvites200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListChannelInvites200ResponseInner
     */
    'code': string;
    /**
     * 
     * @type {number}
     * @memberof ListChannelInvites200ResponseInner
     */
    'type'?: number | null;
    /**
     * 
     * @type {UserResponse}
     * @memberof ListChannelInvites200ResponseInner
     */
    'inviter'?: UserResponse;
    /**
     * 
     * @type {number}
     * @memberof ListChannelInvites200ResponseInner
     */
    'max_age'?: number;
    /**
     * 
     * @type {string}
     * @memberof ListChannelInvites200ResponseInner
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListChannelInvites200ResponseInner
     */
    'expires_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof ListChannelInvites200ResponseInner
     */
    'friends_count'?: number;
    /**
     * 
     * @type {InviteChannelResponse}
     * @memberof ListChannelInvites200ResponseInner
     */
    'channel'?: InviteChannelResponse;
    /**
     * 
     * @type {boolean}
     * @memberof ListChannelInvites200ResponseInner
     */
    'is_contact'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ListChannelInvites200ResponseInner
     */
    'uses'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListChannelInvites200ResponseInner
     */
    'max_uses'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListChannelInvites200ResponseInner
     */
    'flags'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListChannelInvites200ResponseInner
     */
    'approximate_member_count'?: number;
    /**
     * 
     * @type {InviteGuildResponse}
     * @memberof ListChannelInvites200ResponseInner
     */
    'guild'?: InviteGuildResponse;
    /**
     * 
     * @type {string}
     * @memberof ListChannelInvites200ResponseInner
     */
    'guild_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ListChannelInvites200ResponseInner
     */
    'target_type'?: number;
    /**
     * 
     * @type {UserResponse}
     * @memberof ListChannelInvites200ResponseInner
     */
    'target_user'?: UserResponse;
    /**
     * 
     * @type {InviteApplicationResponse}
     * @memberof ListChannelInvites200ResponseInner
     */
    'target_application'?: InviteApplicationResponse;
    /**
     * 
     * @type {ScheduledEventResponse}
     * @memberof ListChannelInvites200ResponseInner
     */
    'guild_scheduled_event'?: ScheduledEventResponse;
    /**
     * 
     * @type {boolean}
     * @memberof ListChannelInvites200ResponseInner
     */
    'temporary'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ListChannelInvites200ResponseInner
     */
    'approximate_presence_count'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ListChannelInvites200ResponseInner
     */
    'is_nickname_changeable'?: boolean;
}
/**
 * @type ListChannelWebhooks200ResponseInner
 * @export
 */
export type ListChannelWebhooks200ResponseInner = ApplicationIncomingWebhookResponse | ChannelFollowerWebhookResponse | GuildIncomingWebhookResponse;

/**
 * @type ListGuildIntegrations200ResponseInner
 * @export
 */
export type ListGuildIntegrations200ResponseInner = DiscordIntegrationResponse | ExternalConnectionIntegrationResponse | GuildSubscriptionIntegrationResponse;

/**
 * @type ListGuildScheduledEvents200ResponseInner
 * @export
 */
export type ListGuildScheduledEvents200ResponseInner = ExternalScheduledEventResponse | StageScheduledEventResponse | VoiceScheduledEventResponse;

/**
 * 
 * @export
 * @interface ListGuildSoundboardSoundsResponse
 */
export interface ListGuildSoundboardSoundsResponse {
    /**
     * 
     * @type {Array<SoundboardSoundResponse>}
     * @memberof ListGuildSoundboardSoundsResponse
     */
    'items': Array<SoundboardSoundResponse>;
}
/**
 * 
 * @export
 * @interface LobbyMemberRequest
 */
export interface LobbyMemberRequest {
    /**
     * 
     * @type {string}
     * @memberof LobbyMemberRequest
     */
    'id': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof LobbyMemberRequest
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof LobbyMemberRequest
     */
    'flags'?: LobbyMemberRequestFlagsEnum | null;
}

export const LobbyMemberRequestFlagsEnum = {
    NUMBER_1: 1
} as const;

export type LobbyMemberRequestFlagsEnum = typeof LobbyMemberRequestFlagsEnum[keyof typeof LobbyMemberRequestFlagsEnum];

/**
 * 
 * @export
 * @interface LobbyMemberResponse
 */
export interface LobbyMemberResponse {
    /**
     * 
     * @type {string}
     * @memberof LobbyMemberResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof LobbyMemberResponse
     */
    'flags': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof LobbyMemberResponse
     */
    'metadata'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface LobbyMessageResponse
 */
export interface LobbyMessageResponse {
    /**
     * 
     * @type {string}
     * @memberof LobbyMessageResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof LobbyMessageResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof LobbyMessageResponse
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof LobbyMessageResponse
     */
    'lobby_id': string;
    /**
     * 
     * @type {string}
     * @memberof LobbyMessageResponse
     */
    'channel_id': string;
    /**
     * 
     * @type {UserResponse}
     * @memberof LobbyMessageResponse
     */
    'author': UserResponse;
    /**
     * 
     * @type {number}
     * @memberof LobbyMessageResponse
     */
    'flags': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof LobbyMessageResponse
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof LobbyMessageResponse
     */
    'application_id'?: string;
}
/**
 * 
 * @export
 * @interface LobbyResponse
 */
export interface LobbyResponse {
    /**
     * 
     * @type {string}
     * @memberof LobbyResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LobbyResponse
     */
    'application_id': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof LobbyResponse
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<LobbyMemberResponse>}
     * @memberof LobbyResponse
     */
    'members'?: Array<LobbyMemberResponse> | null;
    /**
     * 
     * @type {GuildChannelResponse}
     * @memberof LobbyResponse
     */
    'linked_channel'?: GuildChannelResponse | null;
}
/**
 * 
 * @export
 * @interface MLSpamRuleResponse
 */
export interface MLSpamRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof MLSpamRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MLSpamRuleResponse
     */
    'guild_id': string;
    /**
     * 
     * @type {string}
     * @memberof MLSpamRuleResponse
     */
    'creator_id': string;
    /**
     * 
     * @type {string}
     * @memberof MLSpamRuleResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof MLSpamRuleResponse
     */
    'event_type': number;
    /**
     * 
     * @type {Array<DefaultKeywordRuleResponseActionsInner>}
     * @memberof MLSpamRuleResponse
     */
    'actions': Array<DefaultKeywordRuleResponseActionsInner>;
    /**
     * 
     * @type {number}
     * @memberof MLSpamRuleResponse
     */
    'trigger_type': number;
    /**
     * 
     * @type {object}
     * @memberof MLSpamRuleResponse
     */
    'trigger_metadata': object;
    /**
     * 
     * @type {boolean}
     * @memberof MLSpamRuleResponse
     */
    'enabled'?: boolean | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof MLSpamRuleResponse
     */
    'exempt_roles'?: Set<string> | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof MLSpamRuleResponse
     */
    'exempt_channels'?: Set<string> | null;
}
/**
 * 
 * @export
 * @interface MLSpamUpsertRequest
 */
export interface MLSpamUpsertRequest {
    /**
     * 
     * @type {string}
     * @memberof MLSpamUpsertRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof MLSpamUpsertRequest
     */
    'event_type': number;
    /**
     * 
     * @type {number}
     * @memberof MLSpamUpsertRequest
     */
    'trigger_type': number;
    /**
     * 
     * @type {Array<DefaultKeywordListUpsertRequestActionsInner>}
     * @memberof MLSpamUpsertRequest
     */
    'actions'?: Array<DefaultKeywordListUpsertRequestActionsInner> | null;
    /**
     * 
     * @type {boolean}
     * @memberof MLSpamUpsertRequest
     */
    'enabled'?: boolean | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof MLSpamUpsertRequest
     */
    'exempt_roles'?: Set<string> | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof MLSpamUpsertRequest
     */
    'exempt_channels'?: Set<string> | null;
    /**
     * 
     * @type {object}
     * @memberof MLSpamUpsertRequest
     */
    'trigger_metadata'?: object;
}
/**
 * 
 * @export
 * @interface MLSpamUpsertRequestPartial
 */
export interface MLSpamUpsertRequestPartial {
    /**
     * 
     * @type {string}
     * @memberof MLSpamUpsertRequestPartial
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof MLSpamUpsertRequestPartial
     */
    'event_type'?: number;
    /**
     * 
     * @type {Array<DefaultKeywordListUpsertRequestActionsInner>}
     * @memberof MLSpamUpsertRequestPartial
     */
    'actions'?: Array<DefaultKeywordListUpsertRequestActionsInner> | null;
    /**
     * 
     * @type {boolean}
     * @memberof MLSpamUpsertRequestPartial
     */
    'enabled'?: boolean | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof MLSpamUpsertRequestPartial
     */
    'exempt_roles'?: Set<string> | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof MLSpamUpsertRequestPartial
     */
    'exempt_channels'?: Set<string> | null;
    /**
     * 
     * @type {number}
     * @memberof MLSpamUpsertRequestPartial
     */
    'trigger_type'?: number;
    /**
     * 
     * @type {object}
     * @memberof MLSpamUpsertRequestPartial
     */
    'trigger_metadata'?: object;
}
/**
 * 
 * @export
 * @interface MediaGalleryComponentForMessageRequest
 */
export interface MediaGalleryComponentForMessageRequest {
    /**
     * 
     * @type {number}
     * @memberof MediaGalleryComponentForMessageRequest
     */
    'type': number;
    /**
     * 
     * @type {Array<MediaGalleryItemRequest>}
     * @memberof MediaGalleryComponentForMessageRequest
     */
    'items': Array<MediaGalleryItemRequest>;
}
/**
 * 
 * @export
 * @interface MediaGalleryComponentResponse
 */
export interface MediaGalleryComponentResponse {
    /**
     * 
     * @type {number}
     * @memberof MediaGalleryComponentResponse
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof MediaGalleryComponentResponse
     */
    'id': number;
    /**
     * 
     * @type {Array<MediaGalleryItemResponse>}
     * @memberof MediaGalleryComponentResponse
     */
    'items': Array<MediaGalleryItemResponse>;
}
/**
 * 
 * @export
 * @interface MediaGalleryItemRequest
 */
export interface MediaGalleryItemRequest {
    /**
     * 
     * @type {UnfurledMediaRequest}
     * @memberof MediaGalleryItemRequest
     */
    'media': UnfurledMediaRequest;
    /**
     * 
     * @type {string}
     * @memberof MediaGalleryItemRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaGalleryItemRequest
     */
    'spoiler'?: boolean | null;
}
/**
 * 
 * @export
 * @interface MediaGalleryItemResponse
 */
export interface MediaGalleryItemResponse {
    /**
     * 
     * @type {UnfurledMediaResponse}
     * @memberof MediaGalleryItemResponse
     */
    'media': UnfurledMediaResponse;
    /**
     * 
     * @type {boolean}
     * @memberof MediaGalleryItemResponse
     */
    'spoiler': boolean;
    /**
     * 
     * @type {string}
     * @memberof MediaGalleryItemResponse
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface MentionSpamRuleResponse
 */
export interface MentionSpamRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof MentionSpamRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MentionSpamRuleResponse
     */
    'guild_id': string;
    /**
     * 
     * @type {string}
     * @memberof MentionSpamRuleResponse
     */
    'creator_id': string;
    /**
     * 
     * @type {string}
     * @memberof MentionSpamRuleResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof MentionSpamRuleResponse
     */
    'event_type': number;
    /**
     * 
     * @type {Array<DefaultKeywordRuleResponseActionsInner>}
     * @memberof MentionSpamRuleResponse
     */
    'actions': Array<DefaultKeywordRuleResponseActionsInner>;
    /**
     * 
     * @type {number}
     * @memberof MentionSpamRuleResponse
     */
    'trigger_type': number;
    /**
     * 
     * @type {MentionSpamTriggerMetadataResponse}
     * @memberof MentionSpamRuleResponse
     */
    'trigger_metadata': MentionSpamTriggerMetadataResponse;
    /**
     * 
     * @type {boolean}
     * @memberof MentionSpamRuleResponse
     */
    'enabled'?: boolean | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof MentionSpamRuleResponse
     */
    'exempt_roles'?: Set<string> | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof MentionSpamRuleResponse
     */
    'exempt_channels'?: Set<string> | null;
}
/**
 * 
 * @export
 * @interface MentionSpamTriggerMetadata
 */
export interface MentionSpamTriggerMetadata {
    /**
     * 
     * @type {number}
     * @memberof MentionSpamTriggerMetadata
     */
    'mention_total_limit': number;
    /**
     * 
     * @type {boolean}
     * @memberof MentionSpamTriggerMetadata
     */
    'mention_raid_protection_enabled'?: boolean | null;
}
/**
 * 
 * @export
 * @interface MentionSpamTriggerMetadataResponse
 */
export interface MentionSpamTriggerMetadataResponse {
    /**
     * 
     * @type {number}
     * @memberof MentionSpamTriggerMetadataResponse
     */
    'mention_total_limit': number;
    /**
     * 
     * @type {boolean}
     * @memberof MentionSpamTriggerMetadataResponse
     */
    'mention_raid_protection_enabled'?: boolean | null;
}
/**
 * 
 * @export
 * @interface MentionSpamUpsertRequest
 */
export interface MentionSpamUpsertRequest {
    /**
     * 
     * @type {string}
     * @memberof MentionSpamUpsertRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof MentionSpamUpsertRequest
     */
    'event_type': number;
    /**
     * 
     * @type {number}
     * @memberof MentionSpamUpsertRequest
     */
    'trigger_type': number;
    /**
     * 
     * @type {Array<DefaultKeywordListUpsertRequestActionsInner>}
     * @memberof MentionSpamUpsertRequest
     */
    'actions'?: Array<DefaultKeywordListUpsertRequestActionsInner> | null;
    /**
     * 
     * @type {boolean}
     * @memberof MentionSpamUpsertRequest
     */
    'enabled'?: boolean | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof MentionSpamUpsertRequest
     */
    'exempt_roles'?: Set<string> | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof MentionSpamUpsertRequest
     */
    'exempt_channels'?: Set<string> | null;
    /**
     * 
     * @type {MentionSpamTriggerMetadata}
     * @memberof MentionSpamUpsertRequest
     */
    'trigger_metadata'?: MentionSpamTriggerMetadata | null;
}
/**
 * 
 * @export
 * @interface MentionSpamUpsertRequestPartial
 */
export interface MentionSpamUpsertRequestPartial {
    /**
     * 
     * @type {string}
     * @memberof MentionSpamUpsertRequestPartial
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof MentionSpamUpsertRequestPartial
     */
    'event_type'?: number;
    /**
     * 
     * @type {Array<DefaultKeywordListUpsertRequestActionsInner>}
     * @memberof MentionSpamUpsertRequestPartial
     */
    'actions'?: Array<DefaultKeywordListUpsertRequestActionsInner> | null;
    /**
     * 
     * @type {boolean}
     * @memberof MentionSpamUpsertRequestPartial
     */
    'enabled'?: boolean | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof MentionSpamUpsertRequestPartial
     */
    'exempt_roles'?: Set<string> | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof MentionSpamUpsertRequestPartial
     */
    'exempt_channels'?: Set<string> | null;
    /**
     * 
     * @type {number}
     * @memberof MentionSpamUpsertRequestPartial
     */
    'trigger_type'?: number;
    /**
     * 
     * @type {MentionSpamTriggerMetadata}
     * @memberof MentionSpamUpsertRequestPartial
     */
    'trigger_metadata'?: MentionSpamTriggerMetadata | null;
}
/**
 * 
 * @export
 * @interface MentionableSelectComponentForMessageRequest
 */
export interface MentionableSelectComponentForMessageRequest {
    /**
     * 
     * @type {number}
     * @memberof MentionableSelectComponentForMessageRequest
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof MentionableSelectComponentForMessageRequest
     */
    'custom_id': string;
    /**
     * 
     * @type {string}
     * @memberof MentionableSelectComponentForMessageRequest
     */
    'placeholder'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MentionableSelectComponentForMessageRequest
     */
    'min_values'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MentionableSelectComponentForMessageRequest
     */
    'max_values'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof MentionableSelectComponentForMessageRequest
     */
    'disabled'?: boolean | null;
    /**
     * 
     * @type {Array<MentionableSelectComponentForMessageRequestDefaultValuesInner>}
     * @memberof MentionableSelectComponentForMessageRequest
     */
    'default_values'?: Array<MentionableSelectComponentForMessageRequestDefaultValuesInner> | null;
}
/**
 * @type MentionableSelectComponentForMessageRequestDefaultValuesInner
 * @export
 */
export type MentionableSelectComponentForMessageRequestDefaultValuesInner = RoleSelectDefaultValue | UserSelectDefaultValue;

/**
 * 
 * @export
 * @interface MentionableSelectComponentResponse
 */
export interface MentionableSelectComponentResponse {
    /**
     * 
     * @type {number}
     * @memberof MentionableSelectComponentResponse
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof MentionableSelectComponentResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof MentionableSelectComponentResponse
     */
    'custom_id': string;
    /**
     * 
     * @type {string}
     * @memberof MentionableSelectComponentResponse
     */
    'placeholder'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MentionableSelectComponentResponse
     */
    'min_values'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MentionableSelectComponentResponse
     */
    'max_values'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof MentionableSelectComponentResponse
     */
    'disabled'?: boolean | null;
    /**
     * 
     * @type {Array<MentionableSelectComponentResponseDefaultValuesInner>}
     * @memberof MentionableSelectComponentResponse
     */
    'default_values'?: Array<MentionableSelectComponentResponseDefaultValuesInner> | null;
}
/**
 * @type MentionableSelectComponentResponseDefaultValuesInner
 * @export
 */
export type MentionableSelectComponentResponseDefaultValuesInner = RoleSelectDefaultValueResponse | UserSelectDefaultValueResponse;

/**
 * 
 * @export
 * @interface MessageAllowedMentionsRequest
 */
export interface MessageAllowedMentionsRequest {
    /**
     * 
     * @type {Set<string | null>}
     * @memberof MessageAllowedMentionsRequest
     */
    'parse'?: Set<string | null> | null;
    /**
     * 
     * @type {Set<string | null>}
     * @memberof MessageAllowedMentionsRequest
     */
    'users'?: Set<string | null> | null;
    /**
     * 
     * @type {Set<string | null>}
     * @memberof MessageAllowedMentionsRequest
     */
    'roles'?: Set<string | null> | null;
    /**
     * 
     * @type {boolean}
     * @memberof MessageAllowedMentionsRequest
     */
    'replied_user'?: boolean | null;
}
/**
 * 
 * @export
 * @interface MessageAttachmentRequest
 */
export interface MessageAttachmentRequest {
    /**
     * 
     * @type {string}
     * @memberof MessageAttachmentRequest
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MessageAttachmentRequest
     */
    'filename'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MessageAttachmentRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MessageAttachmentRequest
     */
    'duration_secs'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof MessageAttachmentRequest
     */
    'waveform'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MessageAttachmentRequest
     */
    'title'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MessageAttachmentRequest
     */
    'is_remix'?: boolean | null;
}
/**
 * 
 * @export
 * @interface MessageAttachmentResponse
 */
export interface MessageAttachmentResponse {
    /**
     * 
     * @type {string}
     * @memberof MessageAttachmentResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MessageAttachmentResponse
     */
    'filename': string;
    /**
     * 
     * @type {number}
     * @memberof MessageAttachmentResponse
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof MessageAttachmentResponse
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof MessageAttachmentResponse
     */
    'proxy_url': string;
    /**
     * 
     * @type {number}
     * @memberof MessageAttachmentResponse
     */
    'width'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MessageAttachmentResponse
     */
    'height'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MessageAttachmentResponse
     */
    'duration_secs'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof MessageAttachmentResponse
     */
    'waveform'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MessageAttachmentResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MessageAttachmentResponse
     */
    'content_type'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MessageAttachmentResponse
     */
    'ephemeral'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof MessageAttachmentResponse
     */
    'title'?: string | null;
    /**
     * 
     * @type {ApplicationResponse}
     * @memberof MessageAttachmentResponse
     */
    'application'?: ApplicationResponse | null;
    /**
     * 
     * @type {string}
     * @memberof MessageAttachmentResponse
     */
    'clip_created_at'?: string | null;
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof MessageAttachmentResponse
     */
    'clip_participants'?: Array<UserResponse> | null;
}
/**
 * 
 * @export
 * @interface MessageCallResponse
 */
export interface MessageCallResponse {
    /**
     * 
     * @type {Set<string>}
     * @memberof MessageCallResponse
     */
    'participants': Set<string>;
    /**
     * 
     * @type {string}
     * @memberof MessageCallResponse
     */
    'ended_timestamp'?: string | null;
}
/**
 * 
 * @export
 * @interface MessageComponentInteractionMetadataResponse
 */
export interface MessageComponentInteractionMetadataResponse {
    /**
     * 
     * @type {string}
     * @memberof MessageComponentInteractionMetadataResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof MessageComponentInteractionMetadataResponse
     */
    'type': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MessageComponentInteractionMetadataResponse
     */
    'authorizing_integration_owners': { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof MessageComponentInteractionMetadataResponse
     */
    'interacted_message_id': string;
    /**
     * 
     * @type {UserResponse}
     * @memberof MessageComponentInteractionMetadataResponse
     */
    'user'?: UserResponse | null;
    /**
     * 
     * @type {string}
     * @memberof MessageComponentInteractionMetadataResponse
     */
    'original_response_message_id'?: string;
}
/**
 * 
 * @export
 * @interface MessageCreateRequest
 */
export interface MessageCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof MessageCreateRequest
     */
    'content'?: string | null;
    /**
     * 
     * @type {Array<RichEmbed>}
     * @memberof MessageCreateRequest
     */
    'embeds'?: Array<RichEmbed> | null;
    /**
     * 
     * @type {MessageAllowedMentionsRequest}
     * @memberof MessageCreateRequest
     */
    'allowed_mentions'?: MessageAllowedMentionsRequest | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageCreateRequest
     */
    'sticker_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<BaseCreateMessageCreateRequestComponentsInner>}
     * @memberof MessageCreateRequest
     */
    'components'?: Array<BaseCreateMessageCreateRequestComponentsInner> | null;
    /**
     * 
     * @type {number}
     * @memberof MessageCreateRequest
     */
    'flags'?: number | null;
    /**
     * 
     * @type {Array<MessageAttachmentRequest>}
     * @memberof MessageCreateRequest
     */
    'attachments'?: Array<MessageAttachmentRequest> | null;
    /**
     * 
     * @type {PollCreateRequest}
     * @memberof MessageCreateRequest
     */
    'poll'?: PollCreateRequest | null;
    /**
     * 
     * @type {object}
     * @memberof MessageCreateRequest
     */
    'confetti_potion'?: object;
    /**
     * 
     * @type {MessageReferenceRequest}
     * @memberof MessageCreateRequest
     */
    'message_reference'?: MessageReferenceRequest | null;
    /**
     * 
     * @type {BasicMessageResponseNonce}
     * @memberof MessageCreateRequest
     */
    'nonce'?: BasicMessageResponseNonce | null;
    /**
     * 
     * @type {boolean}
     * @memberof MessageCreateRequest
     */
    'enforce_nonce'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof MessageCreateRequest
     */
    'tts'?: boolean | null;
}
/**
 * 
 * @export
 * @interface MessageEditRequestPartial
 */
export interface MessageEditRequestPartial {
    /**
     * 
     * @type {string}
     * @memberof MessageEditRequestPartial
     */
    'content'?: string | null;
    /**
     * 
     * @type {Array<RichEmbed>}
     * @memberof MessageEditRequestPartial
     */
    'embeds'?: Array<RichEmbed> | null;
    /**
     * 
     * @type {number}
     * @memberof MessageEditRequestPartial
     */
    'flags'?: number | null;
    /**
     * 
     * @type {MessageAllowedMentionsRequest}
     * @memberof MessageEditRequestPartial
     */
    'allowed_mentions'?: MessageAllowedMentionsRequest | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageEditRequestPartial
     */
    'sticker_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<BaseCreateMessageCreateRequestComponentsInner>}
     * @memberof MessageEditRequestPartial
     */
    'components'?: Array<BaseCreateMessageCreateRequestComponentsInner> | null;
    /**
     * 
     * @type {Array<MessageAttachmentRequest>}
     * @memberof MessageEditRequestPartial
     */
    'attachments'?: Array<MessageAttachmentRequest> | null;
}
/**
 * 
 * @export
 * @interface MessageEmbedAuthorResponse
 */
export interface MessageEmbedAuthorResponse {
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedAuthorResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedAuthorResponse
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedAuthorResponse
     */
    'icon_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedAuthorResponse
     */
    'proxy_icon_url'?: string | null;
}
/**
 * 
 * @export
 * @interface MessageEmbedFieldResponse
 */
export interface MessageEmbedFieldResponse {
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedFieldResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedFieldResponse
     */
    'value': string;
    /**
     * 
     * @type {boolean}
     * @memberof MessageEmbedFieldResponse
     */
    'inline': boolean;
}
/**
 * 
 * @export
 * @interface MessageEmbedFooterResponse
 */
export interface MessageEmbedFooterResponse {
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedFooterResponse
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedFooterResponse
     */
    'icon_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedFooterResponse
     */
    'proxy_icon_url'?: string | null;
}
/**
 * 
 * @export
 * @interface MessageEmbedImageResponse
 */
export interface MessageEmbedImageResponse {
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedImageResponse
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedImageResponse
     */
    'proxy_url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MessageEmbedImageResponse
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof MessageEmbedImageResponse
     */
    'height'?: number;
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedImageResponse
     */
    'content_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedImageResponse
     */
    'placeholder'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MessageEmbedImageResponse
     */
    'placeholder_version'?: number;
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedImageResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MessageEmbedImageResponse
     */
    'flags'?: number;
}
/**
 * 
 * @export
 * @interface MessageEmbedProviderResponse
 */
export interface MessageEmbedProviderResponse {
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedProviderResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedProviderResponse
     */
    'url'?: string | null;
}
/**
 * 
 * @export
 * @interface MessageEmbedResponse
 */
export interface MessageEmbedResponse {
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedResponse
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedResponse
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedResponse
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MessageEmbedResponse
     */
    'color'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedResponse
     */
    'timestamp'?: string | null;
    /**
     * 
     * @type {Array<MessageEmbedFieldResponse>}
     * @memberof MessageEmbedResponse
     */
    'fields'?: Array<MessageEmbedFieldResponse> | null;
    /**
     * 
     * @type {MessageEmbedAuthorResponse}
     * @memberof MessageEmbedResponse
     */
    'author'?: MessageEmbedAuthorResponse | null;
    /**
     * 
     * @type {MessageEmbedProviderResponse}
     * @memberof MessageEmbedResponse
     */
    'provider'?: MessageEmbedProviderResponse | null;
    /**
     * 
     * @type {MessageEmbedImageResponse}
     * @memberof MessageEmbedResponse
     */
    'image'?: MessageEmbedImageResponse | null;
    /**
     * 
     * @type {MessageEmbedImageResponse}
     * @memberof MessageEmbedResponse
     */
    'thumbnail'?: MessageEmbedImageResponse | null;
    /**
     * 
     * @type {MessageEmbedVideoResponse}
     * @memberof MessageEmbedResponse
     */
    'video'?: MessageEmbedVideoResponse | null;
    /**
     * 
     * @type {MessageEmbedFooterResponse}
     * @memberof MessageEmbedResponse
     */
    'footer'?: MessageEmbedFooterResponse | null;
}
/**
 * 
 * @export
 * @interface MessageEmbedVideoResponse
 */
export interface MessageEmbedVideoResponse {
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedVideoResponse
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedVideoResponse
     */
    'proxy_url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MessageEmbedVideoResponse
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof MessageEmbedVideoResponse
     */
    'height'?: number;
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedVideoResponse
     */
    'content_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedVideoResponse
     */
    'placeholder'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MessageEmbedVideoResponse
     */
    'placeholder_version'?: number;
    /**
     * 
     * @type {string}
     * @memberof MessageEmbedVideoResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MessageEmbedVideoResponse
     */
    'flags'?: number;
}
/**
 * 
 * @export
 * @interface MessageInteractionResponse
 */
export interface MessageInteractionResponse {
    /**
     * 
     * @type {string}
     * @memberof MessageInteractionResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof MessageInteractionResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof MessageInteractionResponse
     */
    'name': string;
    /**
     * 
     * @type {UserResponse}
     * @memberof MessageInteractionResponse
     */
    'user'?: UserResponse | null;
    /**
     * 
     * @type {string}
     * @memberof MessageInteractionResponse
     */
    'name_localized'?: string | null;
}
/**
 * 
 * @export
 * @interface MessageMentionChannelResponse
 */
export interface MessageMentionChannelResponse {
    /**
     * 
     * @type {string}
     * @memberof MessageMentionChannelResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MessageMentionChannelResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof MessageMentionChannelResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof MessageMentionChannelResponse
     */
    'guild_id': string;
}
/**
 * 
 * @export
 * @interface MessageReactionCountDetailsResponse
 */
export interface MessageReactionCountDetailsResponse {
    /**
     * 
     * @type {number}
     * @memberof MessageReactionCountDetailsResponse
     */
    'burst': number;
    /**
     * 
     * @type {number}
     * @memberof MessageReactionCountDetailsResponse
     */
    'normal': number;
}
/**
 * 
 * @export
 * @interface MessageReactionEmojiResponse
 */
export interface MessageReactionEmojiResponse {
    /**
     * 
     * @type {string}
     * @memberof MessageReactionEmojiResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageReactionEmojiResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MessageReactionEmojiResponse
     */
    'animated'?: boolean | null;
}
/**
 * 
 * @export
 * @interface MessageReactionResponse
 */
export interface MessageReactionResponse {
    /**
     * 
     * @type {MessageReactionEmojiResponse}
     * @memberof MessageReactionResponse
     */
    'emoji': MessageReactionEmojiResponse;
    /**
     * 
     * @type {number}
     * @memberof MessageReactionResponse
     */
    'count': number;
    /**
     * 
     * @type {MessageReactionCountDetailsResponse}
     * @memberof MessageReactionResponse
     */
    'count_details': MessageReactionCountDetailsResponse;
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageReactionResponse
     */
    'burst_colors': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof MessageReactionResponse
     */
    'me_burst': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MessageReactionResponse
     */
    'me': boolean;
}
/**
 * 
 * @export
 * @interface MessageReferenceRequest
 */
export interface MessageReferenceRequest {
    /**
     * 
     * @type {string}
     * @memberof MessageReferenceRequest
     */
    'message_id': string;
    /**
     * 
     * @type {string}
     * @memberof MessageReferenceRequest
     */
    'guild_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageReferenceRequest
     */
    'channel_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MessageReferenceRequest
     */
    'fail_if_not_exists'?: boolean | null;
    /**
     * 
     * @type {any}
     * @memberof MessageReferenceRequest
     */
    'type'?: any;
}
/**
 * 
 * @export
 * @interface MessageReferenceResponse
 */
export interface MessageReferenceResponse {
    /**
     * 
     * @type {string}
     * @memberof MessageReferenceResponse
     */
    'channel_id': string;
    /**
     * 
     * @type {any}
     * @memberof MessageReferenceResponse
     */
    'type'?: any;
    /**
     * 
     * @type {string}
     * @memberof MessageReferenceResponse
     */
    'message_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageReferenceResponse
     */
    'guild_id'?: string;
}
/**
 * 
 * @export
 * @interface MessageResponse
 */
export interface MessageResponse {
    /**
     * 
     * @type {number}
     * @memberof MessageResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof MessageResponse
     */
    'content': string;
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof MessageResponse
     */
    'mentions': Array<UserResponse>;
    /**
     * 
     * @type {Set<string>}
     * @memberof MessageResponse
     */
    'mention_roles': Set<string>;
    /**
     * 
     * @type {Array<MessageAttachmentResponse>}
     * @memberof MessageResponse
     */
    'attachments': Array<MessageAttachmentResponse>;
    /**
     * 
     * @type {Array<MessageEmbedResponse>}
     * @memberof MessageResponse
     */
    'embeds': Array<MessageEmbedResponse>;
    /**
     * 
     * @type {string}
     * @memberof MessageResponse
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof MessageResponse
     */
    'flags': number;
    /**
     * 
     * @type {Array<BasicMessageResponseComponentsInner>}
     * @memberof MessageResponse
     */
    'components': Array<BasicMessageResponseComponentsInner>;
    /**
     * 
     * @type {string}
     * @memberof MessageResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MessageResponse
     */
    'channel_id': string;
    /**
     * 
     * @type {UserResponse}
     * @memberof MessageResponse
     */
    'author': UserResponse;
    /**
     * 
     * @type {boolean}
     * @memberof MessageResponse
     */
    'pinned': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MessageResponse
     */
    'mention_everyone': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MessageResponse
     */
    'tts': boolean;
    /**
     * 
     * @type {string}
     * @memberof MessageResponse
     */
    'edited_timestamp'?: string | null;
    /**
     * 
     * @type {ResolvedObjectsResponse}
     * @memberof MessageResponse
     */
    'resolved'?: ResolvedObjectsResponse | null;
    /**
     * 
     * @type {Array<GetSticker200Response>}
     * @memberof MessageResponse
     */
    'stickers'?: Array<GetSticker200Response> | null;
    /**
     * 
     * @type {Array<MessageStickerItemResponse>}
     * @memberof MessageResponse
     */
    'sticker_items'?: Array<MessageStickerItemResponse> | null;
    /**
     * 
     * @type {MessageCallResponse}
     * @memberof MessageResponse
     */
    'call'?: MessageCallResponse | null;
    /**
     * 
     * @type {object}
     * @memberof MessageResponse
     */
    'activity'?: object;
    /**
     * 
     * @type {BasicApplicationResponse}
     * @memberof MessageResponse
     */
    'application'?: BasicApplicationResponse | null;
    /**
     * 
     * @type {string}
     * @memberof MessageResponse
     */
    'application_id'?: string;
    /**
     * 
     * @type {MessageInteractionResponse}
     * @memberof MessageResponse
     */
    'interaction'?: MessageInteractionResponse | null;
    /**
     * 
     * @type {BasicMessageResponseNonce}
     * @memberof MessageResponse
     */
    'nonce'?: BasicMessageResponseNonce | null;
    /**
     * 
     * @type {string}
     * @memberof MessageResponse
     */
    'webhook_id'?: string;
    /**
     * 
     * @type {MessageReferenceResponse}
     * @memberof MessageResponse
     */
    'message_reference'?: MessageReferenceResponse | null;
    /**
     * 
     * @type {ThreadResponse}
     * @memberof MessageResponse
     */
    'thread'?: ThreadResponse | null;
    /**
     * 
     * @type {Array<MessageMentionChannelResponse | null>}
     * @memberof MessageResponse
     */
    'mention_channels'?: Array<MessageMentionChannelResponse | null> | null;
    /**
     * 
     * @type {MessageRoleSubscriptionDataResponse}
     * @memberof MessageResponse
     */
    'role_subscription_data'?: MessageRoleSubscriptionDataResponse | null;
    /**
     * 
     * @type {PurchaseNotificationResponse}
     * @memberof MessageResponse
     */
    'purchase_notification'?: PurchaseNotificationResponse | null;
    /**
     * 
     * @type {number}
     * @memberof MessageResponse
     */
    'position'?: number | null;
    /**
     * 
     * @type {PollResponse}
     * @memberof MessageResponse
     */
    'poll'?: PollResponse | null;
    /**
     * 
     * @type {BasicMessageResponseInteractionMetadata}
     * @memberof MessageResponse
     */
    'interaction_metadata'?: BasicMessageResponseInteractionMetadata | null;
    /**
     * 
     * @type {Array<MessageSnapshotResponse>}
     * @memberof MessageResponse
     */
    'message_snapshots'?: Array<MessageSnapshotResponse> | null;
    /**
     * 
     * @type {Array<MessageReactionResponse>}
     * @memberof MessageResponse
     */
    'reactions'?: Array<MessageReactionResponse> | null;
    /**
     * 
     * @type {BasicMessageResponse}
     * @memberof MessageResponse
     */
    'referenced_message'?: BasicMessageResponse | null;
}
/**
 * 
 * @export
 * @interface MessageRoleSubscriptionDataResponse
 */
export interface MessageRoleSubscriptionDataResponse {
    /**
     * 
     * @type {string}
     * @memberof MessageRoleSubscriptionDataResponse
     */
    'role_subscription_listing_id': string;
    /**
     * 
     * @type {string}
     * @memberof MessageRoleSubscriptionDataResponse
     */
    'tier_name': string;
    /**
     * 
     * @type {number}
     * @memberof MessageRoleSubscriptionDataResponse
     */
    'total_months_subscribed': number;
    /**
     * 
     * @type {boolean}
     * @memberof MessageRoleSubscriptionDataResponse
     */
    'is_renewal': boolean;
}
/**
 * 
 * @export
 * @interface MessageSnapshotResponse
 */
export interface MessageSnapshotResponse {
    /**
     * 
     * @type {MinimalContentMessageResponse}
     * @memberof MessageSnapshotResponse
     */
    'message'?: MinimalContentMessageResponse | null;
}
/**
 * 
 * @export
 * @interface MessageStickerItemResponse
 */
export interface MessageStickerItemResponse {
    /**
     * 
     * @type {string}
     * @memberof MessageStickerItemResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MessageStickerItemResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof MessageStickerItemResponse
     */
    'format_type': number | null;
}
/**
 * 
 * @export
 * @interface MinimalContentMessageResponse
 */
export interface MinimalContentMessageResponse {
    /**
     * 
     * @type {number}
     * @memberof MinimalContentMessageResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof MinimalContentMessageResponse
     */
    'content': string;
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof MinimalContentMessageResponse
     */
    'mentions': Array<UserResponse>;
    /**
     * 
     * @type {Set<string>}
     * @memberof MinimalContentMessageResponse
     */
    'mention_roles': Set<string>;
    /**
     * 
     * @type {Array<MessageAttachmentResponse>}
     * @memberof MinimalContentMessageResponse
     */
    'attachments': Array<MessageAttachmentResponse>;
    /**
     * 
     * @type {Array<MessageEmbedResponse>}
     * @memberof MinimalContentMessageResponse
     */
    'embeds': Array<MessageEmbedResponse>;
    /**
     * 
     * @type {string}
     * @memberof MinimalContentMessageResponse
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof MinimalContentMessageResponse
     */
    'flags': number;
    /**
     * 
     * @type {Array<BasicMessageResponseComponentsInner>}
     * @memberof MinimalContentMessageResponse
     */
    'components': Array<BasicMessageResponseComponentsInner>;
    /**
     * 
     * @type {string}
     * @memberof MinimalContentMessageResponse
     */
    'edited_timestamp'?: string | null;
    /**
     * 
     * @type {ResolvedObjectsResponse}
     * @memberof MinimalContentMessageResponse
     */
    'resolved'?: ResolvedObjectsResponse | null;
    /**
     * 
     * @type {Array<GetSticker200Response>}
     * @memberof MinimalContentMessageResponse
     */
    'stickers'?: Array<GetSticker200Response> | null;
    /**
     * 
     * @type {Array<MessageStickerItemResponse>}
     * @memberof MinimalContentMessageResponse
     */
    'sticker_items'?: Array<MessageStickerItemResponse> | null;
}
/**
 * 
 * @export
 * @interface ModalInteractionCallbackRequest
 */
export interface ModalInteractionCallbackRequest {
    /**
     * 
     * @type {number}
     * @memberof ModalInteractionCallbackRequest
     */
    'type': number | null;
    /**
     * 
     * @type {ModalInteractionCallbackRequestData}
     * @memberof ModalInteractionCallbackRequest
     */
    'data': ModalInteractionCallbackRequestData;
}
/**
 * 
 * @export
 * @interface ModalInteractionCallbackRequestData
 */
export interface ModalInteractionCallbackRequestData {
    /**
     * 
     * @type {string}
     * @memberof ModalInteractionCallbackRequestData
     */
    'custom_id': string;
    /**
     * 
     * @type {string}
     * @memberof ModalInteractionCallbackRequestData
     */
    'title': string;
    /**
     * 
     * @type {Array<ActionRowComponentForModalRequest>}
     * @memberof ModalInteractionCallbackRequestData
     */
    'components': Array<ActionRowComponentForModalRequest>;
}
/**
 * 
 * @export
 * @interface ModalSubmitInteractionMetadataResponse
 */
export interface ModalSubmitInteractionMetadataResponse {
    /**
     * 
     * @type {string}
     * @memberof ModalSubmitInteractionMetadataResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ModalSubmitInteractionMetadataResponse
     */
    'type': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ModalSubmitInteractionMetadataResponse
     */
    'authorizing_integration_owners': { [key: string]: string; };
    /**
     * 
     * @type {ModalSubmitInteractionMetadataResponseTriggeringInteractionMetadata}
     * @memberof ModalSubmitInteractionMetadataResponse
     */
    'triggering_interaction_metadata': ModalSubmitInteractionMetadataResponseTriggeringInteractionMetadata;
    /**
     * 
     * @type {UserResponse}
     * @memberof ModalSubmitInteractionMetadataResponse
     */
    'user'?: UserResponse | null;
    /**
     * 
     * @type {string}
     * @memberof ModalSubmitInteractionMetadataResponse
     */
    'original_response_message_id'?: string;
}
/**
 * @type ModalSubmitInteractionMetadataResponseTriggeringInteractionMetadata
 * @export
 */
export type ModalSubmitInteractionMetadataResponseTriggeringInteractionMetadata = ApplicationCommandInteractionMetadataResponse | MessageComponentInteractionMetadataResponse;

/**
 * A single error, either for an API response or a specific field.
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Discord internal error code. See error code reference
     * @type {number}
     * @memberof ModelError
     */
    'code': number;
    /**
     * Human-readable error message
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface MyGuildResponse
 */
export interface MyGuildResponse {
    /**
     * 
     * @type {string}
     * @memberof MyGuildResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MyGuildResponse
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof MyGuildResponse
     */
    'owner': boolean;
    /**
     * 
     * @type {string}
     * @memberof MyGuildResponse
     */
    'permissions': string;
    /**
     * 
     * @type {Set<string>}
     * @memberof MyGuildResponse
     */
    'features': Set<string>;
    /**
     * 
     * @type {string}
     * @memberof MyGuildResponse
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MyGuildResponse
     */
    'banner'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MyGuildResponse
     */
    'approximate_member_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MyGuildResponse
     */
    'approximate_presence_count'?: number | null;
}
/**
 * 
 * @export
 * @interface NewMemberActionResponse
 */
export interface NewMemberActionResponse {
    /**
     * 
     * @type {string}
     * @memberof NewMemberActionResponse
     */
    'channel_id': string;
    /**
     * 
     * @type {number}
     * @memberof NewMemberActionResponse
     */
    'action_type': number | null;
    /**
     * 
     * @type {string}
     * @memberof NewMemberActionResponse
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof NewMemberActionResponse
     */
    'description': string;
    /**
     * 
     * @type {SettingsEmojiResponse}
     * @memberof NewMemberActionResponse
     */
    'emoji'?: SettingsEmojiResponse | null;
    /**
     * 
     * @type {string}
     * @memberof NewMemberActionResponse
     */
    'icon'?: string | null;
}
/**
 * 
 * @export
 * @interface OAuth2GetAuthorizationResponse
 */
export interface OAuth2GetAuthorizationResponse {
    /**
     * 
     * @type {ApplicationResponse}
     * @memberof OAuth2GetAuthorizationResponse
     */
    'application': ApplicationResponse;
    /**
     * 
     * @type {string}
     * @memberof OAuth2GetAuthorizationResponse
     */
    'expires': string;
    /**
     * 
     * @type {Set<string>}
     * @memberof OAuth2GetAuthorizationResponse
     */
    'scopes': Set<string>;
    /**
     * 
     * @type {UserResponse}
     * @memberof OAuth2GetAuthorizationResponse
     */
    'user'?: UserResponse | null;
}
/**
 * 
 * @export
 * @interface OAuth2GetKeys
 */
export interface OAuth2GetKeys {
    /**
     * 
     * @type {Array<OAuth2Key>}
     * @memberof OAuth2GetKeys
     */
    'keys': Array<OAuth2Key>;
}
/**
 * 
 * @export
 * @interface OAuth2GetOpenIDConnectUserInfoResponse
 */
export interface OAuth2GetOpenIDConnectUserInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof OAuth2GetOpenIDConnectUserInfoResponse
     */
    'sub': string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2GetOpenIDConnectUserInfoResponse
     */
    'email'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof OAuth2GetOpenIDConnectUserInfoResponse
     */
    'email_verified'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof OAuth2GetOpenIDConnectUserInfoResponse
     */
    'preferred_username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OAuth2GetOpenIDConnectUserInfoResponse
     */
    'nickname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OAuth2GetOpenIDConnectUserInfoResponse
     */
    'picture'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OAuth2GetOpenIDConnectUserInfoResponse
     */
    'locale'?: string | null;
}
/**
 * 
 * @export
 * @interface OAuth2Key
 */
export interface OAuth2Key {
    /**
     * 
     * @type {string}
     * @memberof OAuth2Key
     */
    'kty': string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2Key
     */
    'use': string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2Key
     */
    'kid': string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2Key
     */
    'n': string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2Key
     */
    'e': string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2Key
     */
    'alg': string;
}
/**
 * 
 * @export
 * @interface OnboardingPromptOptionRequest
 */
export interface OnboardingPromptOptionRequest {
    /**
     * 
     * @type {string}
     * @memberof OnboardingPromptOptionRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof OnboardingPromptOptionRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OnboardingPromptOptionRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OnboardingPromptOptionRequest
     */
    'emoji_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OnboardingPromptOptionRequest
     */
    'emoji_name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof OnboardingPromptOptionRequest
     */
    'emoji_animated'?: boolean | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof OnboardingPromptOptionRequest
     */
    'role_ids'?: Set<string> | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof OnboardingPromptOptionRequest
     */
    'channel_ids'?: Set<string> | null;
}
/**
 * 
 * @export
 * @interface OnboardingPromptOptionResponse
 */
export interface OnboardingPromptOptionResponse {
    /**
     * 
     * @type {string}
     * @memberof OnboardingPromptOptionResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OnboardingPromptOptionResponse
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof OnboardingPromptOptionResponse
     */
    'description': string;
    /**
     * 
     * @type {SettingsEmojiResponse}
     * @memberof OnboardingPromptOptionResponse
     */
    'emoji': SettingsEmojiResponse;
    /**
     * 
     * @type {Set<string>}
     * @memberof OnboardingPromptOptionResponse
     */
    'role_ids': Set<string>;
    /**
     * 
     * @type {Set<string>}
     * @memberof OnboardingPromptOptionResponse
     */
    'channel_ids': Set<string>;
}
/**
 * 
 * @export
 * @interface OnboardingPromptResponse
 */
export interface OnboardingPromptResponse {
    /**
     * 
     * @type {string}
     * @memberof OnboardingPromptResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OnboardingPromptResponse
     */
    'title': string;
    /**
     * 
     * @type {Array<OnboardingPromptOptionResponse>}
     * @memberof OnboardingPromptResponse
     */
    'options': Array<OnboardingPromptOptionResponse>;
    /**
     * 
     * @type {boolean}
     * @memberof OnboardingPromptResponse
     */
    'single_select': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OnboardingPromptResponse
     */
    'required': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OnboardingPromptResponse
     */
    'in_onboarding': boolean;
    /**
     * 
     * @type {number}
     * @memberof OnboardingPromptResponse
     */
    'type': number;
}
/**
 * 
 * @export
 * @interface PartialDiscordIntegrationResponse
 */
export interface PartialDiscordIntegrationResponse {
    /**
     * 
     * @type {string}
     * @memberof PartialDiscordIntegrationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PartialDiscordIntegrationResponse
     */
    'type': string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialDiscordIntegrationResponse
     */
    'application_id': string;
    /**
     * 
     * @type {string}
     * @memberof PartialDiscordIntegrationResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {AccountResponse}
     * @memberof PartialDiscordIntegrationResponse
     */
    'account'?: AccountResponse | null;
}
/**
 * 
 * @export
 * @interface PartialExternalConnectionIntegrationResponse
 */
export interface PartialExternalConnectionIntegrationResponse {
    /**
     * 
     * @type {string}
     * @memberof PartialExternalConnectionIntegrationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PartialExternalConnectionIntegrationResponse
     */
    'type': string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialExternalConnectionIntegrationResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {AccountResponse}
     * @memberof PartialExternalConnectionIntegrationResponse
     */
    'account'?: AccountResponse | null;
}
/**
 * 
 * @export
 * @interface PartialGuildSubscriptionIntegrationResponse
 */
export interface PartialGuildSubscriptionIntegrationResponse {
    /**
     * 
     * @type {string}
     * @memberof PartialGuildSubscriptionIntegrationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PartialGuildSubscriptionIntegrationResponse
     */
    'type': string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialGuildSubscriptionIntegrationResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {AccountResponse}
     * @memberof PartialGuildSubscriptionIntegrationResponse
     */
    'account'?: AccountResponse | null;
}
/**
 * 
 * @export
 * @interface PartnerSdkUnmergeProvisionalAccountRequest
 */
export interface PartnerSdkUnmergeProvisionalAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof PartnerSdkUnmergeProvisionalAccountRequest
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof PartnerSdkUnmergeProvisionalAccountRequest
     */
    'external_auth_token': string;
    /**
     * 
     * @type {string}
     * @memberof PartnerSdkUnmergeProvisionalAccountRequest
     */
    'external_auth_type': string | null;
    /**
     * 
     * @type {string}
     * @memberof PartnerSdkUnmergeProvisionalAccountRequest
     */
    'client_secret'?: string | null;
}
/**
 * 
 * @export
 * @interface PinnedMessageResponse
 */
export interface PinnedMessageResponse {
    /**
     * 
     * @type {string}
     * @memberof PinnedMessageResponse
     */
    'pinned_at': string;
    /**
     * 
     * @type {MessageResponse}
     * @memberof PinnedMessageResponse
     */
    'message': MessageResponse;
}
/**
 * 
 * @export
 * @interface PinnedMessagesResponse
 */
export interface PinnedMessagesResponse {
    /**
     * 
     * @type {boolean}
     * @memberof PinnedMessagesResponse
     */
    'has_more': boolean;
    /**
     * 
     * @type {Array<PinnedMessageResponse>}
     * @memberof PinnedMessagesResponse
     */
    'items'?: Array<PinnedMessageResponse> | null;
}
/**
 * 
 * @export
 * @interface PollAnswerCreateRequest
 */
export interface PollAnswerCreateRequest {
    /**
     * 
     * @type {PollMediaCreateRequest}
     * @memberof PollAnswerCreateRequest
     */
    'poll_media': PollMediaCreateRequest;
}
/**
 * 
 * @export
 * @interface PollAnswerDetailsResponse
 */
export interface PollAnswerDetailsResponse {
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof PollAnswerDetailsResponse
     */
    'users'?: Array<UserResponse> | null;
}
/**
 * 
 * @export
 * @interface PollAnswerResponse
 */
export interface PollAnswerResponse {
    /**
     * 
     * @type {number}
     * @memberof PollAnswerResponse
     */
    'answer_id': number;
    /**
     * 
     * @type {PollMediaResponse}
     * @memberof PollAnswerResponse
     */
    'poll_media': PollMediaResponse;
}
/**
 * 
 * @export
 * @interface PollCreateRequest
 */
export interface PollCreateRequest {
    /**
     * 
     * @type {PollMedia}
     * @memberof PollCreateRequest
     */
    'question': PollMedia;
    /**
     * 
     * @type {Array<PollAnswerCreateRequest>}
     * @memberof PollCreateRequest
     */
    'answers': Array<PollAnswerCreateRequest>;
    /**
     * 
     * @type {boolean}
     * @memberof PollCreateRequest
     */
    'allow_multiselect'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PollCreateRequest
     */
    'layout_type'?: number;
    /**
     * 
     * @type {number}
     * @memberof PollCreateRequest
     */
    'duration'?: number | null;
}
/**
 * 
 * @export
 * @interface PollEmoji
 */
export interface PollEmoji {
    /**
     * 
     * @type {string}
     * @memberof PollEmoji
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PollEmoji
     */
    'name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PollEmoji
     */
    'animated'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PollEmojiCreateRequest
 */
export interface PollEmojiCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof PollEmojiCreateRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PollEmojiCreateRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PollEmojiCreateRequest
     */
    'animated'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PollMedia
 */
export interface PollMedia {
    /**
     * 
     * @type {string}
     * @memberof PollMedia
     */
    'text'?: string | null;
    /**
     * 
     * @type {PollEmoji}
     * @memberof PollMedia
     */
    'emoji'?: PollEmoji | null;
}
/**
 * 
 * @export
 * @interface PollMediaCreateRequest
 */
export interface PollMediaCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof PollMediaCreateRequest
     */
    'text'?: string | null;
    /**
     * 
     * @type {PollEmojiCreateRequest}
     * @memberof PollMediaCreateRequest
     */
    'emoji'?: PollEmojiCreateRequest | null;
}
/**
 * 
 * @export
 * @interface PollMediaResponse
 */
export interface PollMediaResponse {
    /**
     * 
     * @type {string}
     * @memberof PollMediaResponse
     */
    'text'?: string | null;
    /**
     * 
     * @type {MessageReactionEmojiResponse}
     * @memberof PollMediaResponse
     */
    'emoji'?: MessageReactionEmojiResponse | null;
}
/**
 * 
 * @export
 * @interface PollResponse
 */
export interface PollResponse {
    /**
     * 
     * @type {PollMediaResponse}
     * @memberof PollResponse
     */
    'question': PollMediaResponse;
    /**
     * 
     * @type {Array<PollAnswerResponse>}
     * @memberof PollResponse
     */
    'answers': Array<PollAnswerResponse>;
    /**
     * 
     * @type {string}
     * @memberof PollResponse
     */
    'expiry': string;
    /**
     * 
     * @type {boolean}
     * @memberof PollResponse
     */
    'allow_multiselect': boolean;
    /**
     * 
     * @type {number}
     * @memberof PollResponse
     */
    'layout_type': number;
    /**
     * 
     * @type {PollResultsResponse}
     * @memberof PollResponse
     */
    'results': PollResultsResponse;
}
/**
 * 
 * @export
 * @interface PollResultsEntryResponse
 */
export interface PollResultsEntryResponse {
    /**
     * 
     * @type {number}
     * @memberof PollResultsEntryResponse
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof PollResultsEntryResponse
     */
    'count': number;
    /**
     * 
     * @type {boolean}
     * @memberof PollResultsEntryResponse
     */
    'me_voted'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PollResultsResponse
 */
export interface PollResultsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof PollResultsResponse
     */
    'is_finalized': boolean;
    /**
     * 
     * @type {Array<PollResultsEntryResponse>}
     * @memberof PollResultsResponse
     */
    'answer_counts'?: Array<PollResultsEntryResponse> | null;
}
/**
 * 
 * @export
 * @interface PongInteractionCallbackRequest
 */
export interface PongInteractionCallbackRequest {
    /**
     * 
     * @type {number}
     * @memberof PongInteractionCallbackRequest
     */
    'type': number | null;
}
/**
 * 
 * @export
 * @interface PrivateApplicationResponse
 */
export interface PrivateApplicationResponse {
    /**
     * 
     * @type {string}
     * @memberof PrivateApplicationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PrivateApplicationResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PrivateApplicationResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof PrivateApplicationResponse
     */
    'verify_key': string;
    /**
     * 
     * @type {number}
     * @memberof PrivateApplicationResponse
     */
    'flags': number;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PrivateApplicationResponse
     */
    'redirect_uris': Array<string | null>;
    /**
     * 
     * @type {UserResponse}
     * @memberof PrivateApplicationResponse
     */
    'owner': UserResponse;
    /**
     * 
     * @type {number}
     * @memberof PrivateApplicationResponse
     */
    'approximate_user_install_count': number;
    /**
     * 
     * @type {number}
     * @memberof PrivateApplicationResponse
     */
    'approximate_user_authorization_count': number;
    /**
     * 
     * @type {number}
     * @memberof PrivateApplicationResponse
     */
    'explicit_content_filter': number;
    /**
     * 
     * @type {string}
     * @memberof PrivateApplicationResponse
     */
    'icon'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PrivateApplicationResponse
     */
    'type'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PrivateApplicationResponse
     */
    'cover_image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PrivateApplicationResponse
     */
    'primary_sku_id'?: string;
    /**
     * 
     * @type {UserResponse}
     * @memberof PrivateApplicationResponse
     */
    'bot'?: UserResponse | null;
    /**
     * 
     * @type {string}
     * @memberof PrivateApplicationResponse
     */
    'slug'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PrivateApplicationResponse
     */
    'guild_id'?: string;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PrivateApplicationResponse
     */
    'rpc_origins'?: Array<string | null> | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrivateApplicationResponse
     */
    'bot_public'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrivateApplicationResponse
     */
    'bot_require_code_grant'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PrivateApplicationResponse
     */
    'terms_of_service_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PrivateApplicationResponse
     */
    'privacy_policy_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PrivateApplicationResponse
     */
    'custom_install_url'?: string | null;
    /**
     * 
     * @type {ApplicationOAuth2InstallParamsResponse}
     * @memberof PrivateApplicationResponse
     */
    'install_params'?: ApplicationOAuth2InstallParamsResponse | null;
    /**
     * 
     * @type {{ [key: string]: ApplicationIntegrationTypeConfigurationResponse; }}
     * @memberof PrivateApplicationResponse
     */
    'integration_types_config'?: { [key: string]: ApplicationIntegrationTypeConfigurationResponse; };
    /**
     * 
     * @type {number}
     * @memberof PrivateApplicationResponse
     */
    'max_participants'?: number | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof PrivateApplicationResponse
     */
    'tags'?: Set<string> | null;
    /**
     * 
     * @type {string}
     * @memberof PrivateApplicationResponse
     */
    'interactions_endpoint_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PrivateApplicationResponse
     */
    'role_connections_verification_url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PrivateApplicationResponse
     */
    'approximate_guild_count'?: number | null;
    /**
     * 
     * @type {TeamResponse}
     * @memberof PrivateApplicationResponse
     */
    'team'?: TeamResponse | null;
}
/**
 * 
 * @export
 * @interface PrivateChannelLocation
 */
export interface PrivateChannelLocation {
    /**
     * 
     * @type {string}
     * @memberof PrivateChannelLocation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PrivateChannelLocation
     */
    'kind': string;
    /**
     * 
     * @type {string}
     * @memberof PrivateChannelLocation
     */
    'channel_id': string;
}
/**
 * 
 * @export
 * @interface PrivateChannelResponse
 */
export interface PrivateChannelResponse {
    /**
     * 
     * @type {string}
     * @memberof PrivateChannelResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof PrivateChannelResponse
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof PrivateChannelResponse
     */
    'flags': number;
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof PrivateChannelResponse
     */
    'recipients': Array<UserResponse>;
    /**
     * 
     * @type {string}
     * @memberof PrivateChannelResponse
     */
    'last_message_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrivateChannelResponse
     */
    'last_pin_timestamp'?: string | null;
}
/**
 * 
 * @export
 * @interface PrivateGroupChannelResponse
 */
export interface PrivateGroupChannelResponse {
    /**
     * 
     * @type {string}
     * @memberof PrivateGroupChannelResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof PrivateGroupChannelResponse
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof PrivateGroupChannelResponse
     */
    'flags': number;
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof PrivateGroupChannelResponse
     */
    'recipients': Array<UserResponse>;
    /**
     * 
     * @type {string}
     * @memberof PrivateGroupChannelResponse
     */
    'last_message_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrivateGroupChannelResponse
     */
    'last_pin_timestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PrivateGroupChannelResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PrivateGroupChannelResponse
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PrivateGroupChannelResponse
     */
    'owner_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PrivateGroupChannelResponse
     */
    'managed'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PrivateGroupChannelResponse
     */
    'application_id'?: string;
}
/**
 * 
 * @export
 * @interface PrivateGuildMemberResponse
 */
export interface PrivateGuildMemberResponse {
    /**
     * 
     * @type {number}
     * @memberof PrivateGuildMemberResponse
     */
    'flags': number;
    /**
     * 
     * @type {string}
     * @memberof PrivateGuildMemberResponse
     */
    'joined_at': string;
    /**
     * 
     * @type {boolean}
     * @memberof PrivateGuildMemberResponse
     */
    'pending': boolean;
    /**
     * 
     * @type {Set<string>}
     * @memberof PrivateGuildMemberResponse
     */
    'roles': Set<string>;
    /**
     * 
     * @type {UserResponse}
     * @memberof PrivateGuildMemberResponse
     */
    'user': UserResponse;
    /**
     * 
     * @type {boolean}
     * @memberof PrivateGuildMemberResponse
     */
    'mute': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PrivateGuildMemberResponse
     */
    'deaf': boolean;
    /**
     * 
     * @type {string}
     * @memberof PrivateGuildMemberResponse
     */
    'avatar'?: string | null;
    /**
     * 
     * @type {UserAvatarDecorationResponse}
     * @memberof PrivateGuildMemberResponse
     */
    'avatar_decoration_data'?: UserAvatarDecorationResponse | null;
    /**
     * 
     * @type {string}
     * @memberof PrivateGuildMemberResponse
     */
    'banner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PrivateGuildMemberResponse
     */
    'communication_disabled_until'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PrivateGuildMemberResponse
     */
    'nick'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PrivateGuildMemberResponse
     */
    'premium_since'?: string | null;
}
/**
 * 
 * @export
 * @interface ProvisionalTokenResponse
 */
export interface ProvisionalTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof ProvisionalTokenResponse
     */
    'token_type': string;
    /**
     * 
     * @type {string}
     * @memberof ProvisionalTokenResponse
     */
    'access_token': string;
    /**
     * 
     * @type {number}
     * @memberof ProvisionalTokenResponse
     */
    'expires_in': number;
    /**
     * 
     * @type {string}
     * @memberof ProvisionalTokenResponse
     */
    'scope': string;
    /**
     * 
     * @type {string}
     * @memberof ProvisionalTokenResponse
     */
    'id_token': string;
    /**
     * 
     * @type {string}
     * @memberof ProvisionalTokenResponse
     */
    'refresh_token'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProvisionalTokenResponse
     */
    'scopes'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof ProvisionalTokenResponse
     */
    'expires_at_s'?: number | null;
}
/**
 * 
 * @export
 * @interface PruneGuildRequest
 */
export interface PruneGuildRequest {
    /**
     * 
     * @type {number}
     * @memberof PruneGuildRequest
     */
    'days'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PruneGuildRequest
     */
    'compute_prune_count'?: boolean | null;
    /**
     * 
     * @type {PruneGuildRequestIncludeRoles}
     * @memberof PruneGuildRequest
     */
    'include_roles'?: PruneGuildRequestIncludeRoles | null;
}
/**
 * @type PruneGuildRequestIncludeRoles
 * @export
 */
export type PruneGuildRequestIncludeRoles = Set<string | null> | string;

/**
 * 
 * @export
 * @interface PurchaseNotificationResponse
 */
export interface PurchaseNotificationResponse {
    /**
     * 
     * @type {number}
     * @memberof PurchaseNotificationResponse
     */
    'type': number | null;
    /**
     * 
     * @type {GuildProductPurchaseResponse}
     * @memberof PurchaseNotificationResponse
     */
    'guild_product_purchase'?: GuildProductPurchaseResponse | null;
}
/**
 * 
 * @export
 * @interface QuarantineUserAction
 */
export interface QuarantineUserAction {
    /**
     * 
     * @type {number}
     * @memberof QuarantineUserAction
     */
    'type': number;
    /**
     * 
     * @type {object}
     * @memberof QuarantineUserAction
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface QuarantineUserActionResponse
 */
export interface QuarantineUserActionResponse {
    /**
     * 
     * @type {number}
     * @memberof QuarantineUserActionResponse
     */
    'type': number;
    /**
     * 
     * @type {object}
     * @memberof QuarantineUserActionResponse
     */
    'metadata': object;
}
/**
 * 
 * @export
 * @interface ResolvedObjectsResponse
 */
export interface ResolvedObjectsResponse {
    /**
     * 
     * @type {{ [key: string]: UserResponse; }}
     * @memberof ResolvedObjectsResponse
     */
    'users': { [key: string]: UserResponse; };
    /**
     * 
     * @type {{ [key: string]: GuildMemberResponse; }}
     * @memberof ResolvedObjectsResponse
     */
    'members': { [key: string]: GuildMemberResponse; };
    /**
     * 
     * @type {{ [key: string]: GetChannel200Response; }}
     * @memberof ResolvedObjectsResponse
     */
    'channels': { [key: string]: GetChannel200Response; };
    /**
     * 
     * @type {{ [key: string]: GuildRoleResponse; }}
     * @memberof ResolvedObjectsResponse
     */
    'roles': { [key: string]: GuildRoleResponse; };
}
/**
 * 
 * @export
 * @interface ResourceChannelResponse
 */
export interface ResourceChannelResponse {
    /**
     * 
     * @type {string}
     * @memberof ResourceChannelResponse
     */
    'channel_id': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceChannelResponse
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceChannelResponse
     */
    'description': string;
    /**
     * 
     * @type {SettingsEmojiResponse}
     * @memberof ResourceChannelResponse
     */
    'emoji'?: SettingsEmojiResponse | null;
    /**
     * 
     * @type {string}
     * @memberof ResourceChannelResponse
     */
    'icon'?: string | null;
}
/**
 * 
 * @export
 * @interface RichEmbed
 */
export interface RichEmbed {
    /**
     * 
     * @type {string}
     * @memberof RichEmbed
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RichEmbed
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RichEmbed
     */
    'title'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RichEmbed
     */
    'color'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RichEmbed
     */
    'timestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RichEmbed
     */
    'description'?: string | null;
    /**
     * 
     * @type {RichEmbedAuthor}
     * @memberof RichEmbed
     */
    'author'?: RichEmbedAuthor | null;
    /**
     * 
     * @type {RichEmbedImage}
     * @memberof RichEmbed
     */
    'image'?: RichEmbedImage | null;
    /**
     * 
     * @type {RichEmbedThumbnail}
     * @memberof RichEmbed
     */
    'thumbnail'?: RichEmbedThumbnail | null;
    /**
     * 
     * @type {RichEmbedFooter}
     * @memberof RichEmbed
     */
    'footer'?: RichEmbedFooter | null;
    /**
     * 
     * @type {Array<RichEmbedField>}
     * @memberof RichEmbed
     */
    'fields'?: Array<RichEmbedField> | null;
    /**
     * 
     * @type {RichEmbedProvider}
     * @memberof RichEmbed
     */
    'provider'?: RichEmbedProvider | null;
    /**
     * 
     * @type {RichEmbedVideo}
     * @memberof RichEmbed
     */
    'video'?: RichEmbedVideo | null;
}
/**
 * 
 * @export
 * @interface RichEmbedAuthor
 */
export interface RichEmbedAuthor {
    /**
     * 
     * @type {string}
     * @memberof RichEmbedAuthor
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RichEmbedAuthor
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RichEmbedAuthor
     */
    'icon_url'?: string | null;
}
/**
 * 
 * @export
 * @interface RichEmbedField
 */
export interface RichEmbedField {
    /**
     * 
     * @type {string}
     * @memberof RichEmbedField
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RichEmbedField
     */
    'value': string;
    /**
     * 
     * @type {boolean}
     * @memberof RichEmbedField
     */
    'inline'?: boolean | null;
}
/**
 * 
 * @export
 * @interface RichEmbedFooter
 */
export interface RichEmbedFooter {
    /**
     * 
     * @type {string}
     * @memberof RichEmbedFooter
     */
    'text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RichEmbedFooter
     */
    'icon_url'?: string | null;
}
/**
 * 
 * @export
 * @interface RichEmbedImage
 */
export interface RichEmbedImage {
    /**
     * 
     * @type {string}
     * @memberof RichEmbedImage
     */
    'url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RichEmbedImage
     */
    'width'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RichEmbedImage
     */
    'height'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RichEmbedImage
     */
    'placeholder'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RichEmbedImage
     */
    'placeholder_version'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof RichEmbedImage
     */
    'is_animated'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof RichEmbedImage
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface RichEmbedProvider
 */
export interface RichEmbedProvider {
    /**
     * 
     * @type {string}
     * @memberof RichEmbedProvider
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RichEmbedProvider
     */
    'url'?: string | null;
}
/**
 * 
 * @export
 * @interface RichEmbedThumbnail
 */
export interface RichEmbedThumbnail {
    /**
     * 
     * @type {string}
     * @memberof RichEmbedThumbnail
     */
    'url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RichEmbedThumbnail
     */
    'width'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RichEmbedThumbnail
     */
    'height'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RichEmbedThumbnail
     */
    'placeholder'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RichEmbedThumbnail
     */
    'placeholder_version'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof RichEmbedThumbnail
     */
    'is_animated'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof RichEmbedThumbnail
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface RichEmbedVideo
 */
export interface RichEmbedVideo {
    /**
     * 
     * @type {string}
     * @memberof RichEmbedVideo
     */
    'url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RichEmbedVideo
     */
    'width'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RichEmbedVideo
     */
    'height'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RichEmbedVideo
     */
    'placeholder'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RichEmbedVideo
     */
    'placeholder_version'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof RichEmbedVideo
     */
    'is_animated'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof RichEmbedVideo
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface RoleSelectComponentForMessageRequest
 */
export interface RoleSelectComponentForMessageRequest {
    /**
     * 
     * @type {number}
     * @memberof RoleSelectComponentForMessageRequest
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof RoleSelectComponentForMessageRequest
     */
    'custom_id': string;
    /**
     * 
     * @type {string}
     * @memberof RoleSelectComponentForMessageRequest
     */
    'placeholder'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RoleSelectComponentForMessageRequest
     */
    'min_values'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RoleSelectComponentForMessageRequest
     */
    'max_values'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof RoleSelectComponentForMessageRequest
     */
    'disabled'?: boolean | null;
    /**
     * 
     * @type {Array<RoleSelectDefaultValue>}
     * @memberof RoleSelectComponentForMessageRequest
     */
    'default_values'?: Array<RoleSelectDefaultValue> | null;
}
/**
 * 
 * @export
 * @interface RoleSelectComponentResponse
 */
export interface RoleSelectComponentResponse {
    /**
     * 
     * @type {number}
     * @memberof RoleSelectComponentResponse
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof RoleSelectComponentResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof RoleSelectComponentResponse
     */
    'custom_id': string;
    /**
     * 
     * @type {string}
     * @memberof RoleSelectComponentResponse
     */
    'placeholder'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RoleSelectComponentResponse
     */
    'min_values'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RoleSelectComponentResponse
     */
    'max_values'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof RoleSelectComponentResponse
     */
    'disabled'?: boolean | null;
    /**
     * 
     * @type {Array<RoleSelectDefaultValueResponse>}
     * @memberof RoleSelectComponentResponse
     */
    'default_values'?: Array<RoleSelectDefaultValueResponse> | null;
}
/**
 * 
 * @export
 * @interface RoleSelectDefaultValue
 */
export interface RoleSelectDefaultValue {
    /**
     * 
     * @type {string}
     * @memberof RoleSelectDefaultValue
     */
    'type': string | null;
    /**
     * 
     * @type {string}
     * @memberof RoleSelectDefaultValue
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface RoleSelectDefaultValueResponse
 */
export interface RoleSelectDefaultValueResponse {
    /**
     * 
     * @type {string}
     * @memberof RoleSelectDefaultValueResponse
     */
    'type': string | null;
    /**
     * 
     * @type {string}
     * @memberof RoleSelectDefaultValueResponse
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface SDKMessageRequest
 */
export interface SDKMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof SDKMessageRequest
     */
    'content'?: string | null;
    /**
     * 
     * @type {Array<RichEmbed>}
     * @memberof SDKMessageRequest
     */
    'embeds'?: Array<RichEmbed> | null;
    /**
     * 
     * @type {MessageAllowedMentionsRequest}
     * @memberof SDKMessageRequest
     */
    'allowed_mentions'?: MessageAllowedMentionsRequest | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof SDKMessageRequest
     */
    'sticker_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<BaseCreateMessageCreateRequestComponentsInner>}
     * @memberof SDKMessageRequest
     */
    'components'?: Array<BaseCreateMessageCreateRequestComponentsInner> | null;
    /**
     * 
     * @type {number}
     * @memberof SDKMessageRequest
     */
    'flags'?: number | null;
    /**
     * 
     * @type {Array<MessageAttachmentRequest>}
     * @memberof SDKMessageRequest
     */
    'attachments'?: Array<MessageAttachmentRequest> | null;
    /**
     * 
     * @type {PollCreateRequest}
     * @memberof SDKMessageRequest
     */
    'poll'?: PollCreateRequest | null;
    /**
     * 
     * @type {object}
     * @memberof SDKMessageRequest
     */
    'confetti_potion'?: object;
    /**
     * 
     * @type {MessageReferenceRequest}
     * @memberof SDKMessageRequest
     */
    'message_reference'?: MessageReferenceRequest | null;
    /**
     * 
     * @type {BasicMessageResponseNonce}
     * @memberof SDKMessageRequest
     */
    'nonce'?: BasicMessageResponseNonce | null;
    /**
     * 
     * @type {boolean}
     * @memberof SDKMessageRequest
     */
    'enforce_nonce'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof SDKMessageRequest
     */
    'tts'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ScheduledEventResponse
 */
export interface ScheduledEventResponse {
    /**
     * 
     * @type {string}
     * @memberof ScheduledEventResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledEventResponse
     */
    'guild_id': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledEventResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledEventResponse
     */
    'scheduled_start_time': string;
    /**
     * 
     * @type {number}
     * @memberof ScheduledEventResponse
     */
    'status': number | null;
    /**
     * 
     * @type {number}
     * @memberof ScheduledEventResponse
     */
    'entity_type': number | null;
    /**
     * 
     * @type {any}
     * @memberof ScheduledEventResponse
     */
    'privacy_level': any;
    /**
     * 
     * @type {string}
     * @memberof ScheduledEventResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduledEventResponse
     */
    'channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledEventResponse
     */
    'creator_id'?: string;
    /**
     * 
     * @type {UserResponse}
     * @memberof ScheduledEventResponse
     */
    'creator'?: UserResponse | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduledEventResponse
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduledEventResponse
     */
    'scheduled_end_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduledEventResponse
     */
    'entity_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScheduledEventResponse
     */
    'user_count'?: number | null;
    /**
     * 
     * @type {ScheduledEventUserResponse}
     * @memberof ScheduledEventResponse
     */
    'user_rsvp'?: ScheduledEventUserResponse | null;
}
/**
 * 
 * @export
 * @interface ScheduledEventUserResponse
 */
export interface ScheduledEventUserResponse {
    /**
     * 
     * @type {string}
     * @memberof ScheduledEventUserResponse
     */
    'guild_scheduled_event_id': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledEventUserResponse
     */
    'user_id': string;
    /**
     * 
     * @type {UserResponse}
     * @memberof ScheduledEventUserResponse
     */
    'user'?: UserResponse | null;
    /**
     * 
     * @type {GuildMemberResponse}
     * @memberof ScheduledEventUserResponse
     */
    'member'?: GuildMemberResponse | null;
}
/**
 * 
 * @export
 * @interface SectionComponentForMessageRequest
 */
export interface SectionComponentForMessageRequest {
    /**
     * 
     * @type {number}
     * @memberof SectionComponentForMessageRequest
     */
    'type': number;
    /**
     * 
     * @type {Array<TextDisplayComponentForMessageRequest>}
     * @memberof SectionComponentForMessageRequest
     */
    'components': Array<TextDisplayComponentForMessageRequest>;
    /**
     * 
     * @type {SectionComponentForMessageRequestAccessory}
     * @memberof SectionComponentForMessageRequest
     */
    'accessory': SectionComponentForMessageRequestAccessory;
}
/**
 * @type SectionComponentForMessageRequestAccessory
 * @export
 */
export type SectionComponentForMessageRequestAccessory = ButtonComponentForMessageRequest | ThumbnailComponentForMessageRequest;

/**
 * 
 * @export
 * @interface SectionComponentResponse
 */
export interface SectionComponentResponse {
    /**
     * 
     * @type {number}
     * @memberof SectionComponentResponse
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof SectionComponentResponse
     */
    'id': number;
    /**
     * 
     * @type {Array<TextDisplayComponentResponse>}
     * @memberof SectionComponentResponse
     */
    'components': Array<TextDisplayComponentResponse>;
    /**
     * 
     * @type {SectionComponentResponseAccessory}
     * @memberof SectionComponentResponse
     */
    'accessory': SectionComponentResponseAccessory;
}
/**
 * @type SectionComponentResponseAccessory
 * @export
 */
export type SectionComponentResponseAccessory = ButtonComponentResponse | ThumbnailComponentResponse;

/**
 * 
 * @export
 * @interface SeparatorComponentForMessageRequest
 */
export interface SeparatorComponentForMessageRequest {
    /**
     * 
     * @type {number}
     * @memberof SeparatorComponentForMessageRequest
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof SeparatorComponentForMessageRequest
     */
    'spacing'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SeparatorComponentForMessageRequest
     */
    'divider'?: boolean | null;
}
/**
 * 
 * @export
 * @interface SeparatorComponentResponse
 */
export interface SeparatorComponentResponse {
    /**
     * 
     * @type {number}
     * @memberof SeparatorComponentResponse
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof SeparatorComponentResponse
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof SeparatorComponentResponse
     */
    'spacing': number;
    /**
     * 
     * @type {boolean}
     * @memberof SeparatorComponentResponse
     */
    'divider': boolean;
}
/**
 * 
 * @export
 * @interface SetChannelPermissionOverwriteRequest
 */
export interface SetChannelPermissionOverwriteRequest {
    /**
     * 
     * @type {number}
     * @memberof SetChannelPermissionOverwriteRequest
     */
    'type'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SetChannelPermissionOverwriteRequest
     */
    'allow'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SetChannelPermissionOverwriteRequest
     */
    'deny'?: number | null;
}
/**
 * 
 * @export
 * @interface SetGuildApplicationCommandPermissionsRequest
 */
export interface SetGuildApplicationCommandPermissionsRequest {
    /**
     * 
     * @type {Array<ApplicationCommandPermission>}
     * @memberof SetGuildApplicationCommandPermissionsRequest
     */
    'permissions'?: Array<ApplicationCommandPermission> | null;
}
/**
 * 
 * @export
 * @interface SetGuildMfaLevelRequest
 */
export interface SetGuildMfaLevelRequest {
    /**
     * 
     * @type {number}
     * @memberof SetGuildMfaLevelRequest
     */
    'level': number;
}
/**
 * 
 * @export
 * @interface SettingsEmojiResponse
 */
export interface SettingsEmojiResponse {
    /**
     * 
     * @type {string}
     * @memberof SettingsEmojiResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingsEmojiResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SettingsEmojiResponse
     */
    'animated'?: boolean | null;
}
/**
 * 
 * @export
 * @interface SlackWebhook
 */
export interface SlackWebhook {
    /**
     * 
     * @type {string}
     * @memberof SlackWebhook
     */
    'text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SlackWebhook
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SlackWebhook
     */
    'icon_url'?: string | null;
    /**
     * 
     * @type {Array<WebhookSlackEmbed>}
     * @memberof SlackWebhook
     */
    'attachments'?: Array<WebhookSlackEmbed> | null;
}
/**
 * 
 * @export
 * @interface SoundboardCreateRequest
 */
export interface SoundboardCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof SoundboardCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SoundboardCreateRequest
     */
    'sound': string;
    /**
     * 
     * @type {number}
     * @memberof SoundboardCreateRequest
     */
    'volume'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SoundboardCreateRequest
     */
    'emoji_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SoundboardCreateRequest
     */
    'emoji_name'?: string | null;
}
/**
 * 
 * @export
 * @interface SoundboardPatchRequestPartial
 */
export interface SoundboardPatchRequestPartial {
    /**
     * 
     * @type {string}
     * @memberof SoundboardPatchRequestPartial
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof SoundboardPatchRequestPartial
     */
    'volume'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SoundboardPatchRequestPartial
     */
    'emoji_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SoundboardPatchRequestPartial
     */
    'emoji_name'?: string | null;
}
/**
 * 
 * @export
 * @interface SoundboardSoundResponse
 */
export interface SoundboardSoundResponse {
    /**
     * 
     * @type {string}
     * @memberof SoundboardSoundResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SoundboardSoundResponse
     */
    'sound_id': string;
    /**
     * 
     * @type {number}
     * @memberof SoundboardSoundResponse
     */
    'volume': number;
    /**
     * 
     * @type {boolean}
     * @memberof SoundboardSoundResponse
     */
    'available': boolean;
    /**
     * 
     * @type {string}
     * @memberof SoundboardSoundResponse
     */
    'emoji_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SoundboardSoundResponse
     */
    'emoji_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SoundboardSoundResponse
     */
    'guild_id'?: string;
    /**
     * 
     * @type {UserResponse}
     * @memberof SoundboardSoundResponse
     */
    'user'?: UserResponse | null;
}
/**
 * 
 * @export
 * @interface SoundboardSoundSendRequest
 */
export interface SoundboardSoundSendRequest {
    /**
     * 
     * @type {string}
     * @memberof SoundboardSoundSendRequest
     */
    'sound_id': string;
    /**
     * 
     * @type {string}
     * @memberof SoundboardSoundSendRequest
     */
    'source_guild_id'?: string;
}
/**
 * 
 * @export
 * @interface SpamLinkRuleResponse
 */
export interface SpamLinkRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof SpamLinkRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SpamLinkRuleResponse
     */
    'guild_id': string;
    /**
     * 
     * @type {string}
     * @memberof SpamLinkRuleResponse
     */
    'creator_id': string;
    /**
     * 
     * @type {string}
     * @memberof SpamLinkRuleResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof SpamLinkRuleResponse
     */
    'event_type': number;
    /**
     * 
     * @type {Array<DefaultKeywordRuleResponseActionsInner>}
     * @memberof SpamLinkRuleResponse
     */
    'actions': Array<DefaultKeywordRuleResponseActionsInner>;
    /**
     * 
     * @type {number}
     * @memberof SpamLinkRuleResponse
     */
    'trigger_type': number;
    /**
     * 
     * @type {object}
     * @memberof SpamLinkRuleResponse
     */
    'trigger_metadata': object;
    /**
     * 
     * @type {boolean}
     * @memberof SpamLinkRuleResponse
     */
    'enabled'?: boolean | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof SpamLinkRuleResponse
     */
    'exempt_roles'?: Set<string> | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof SpamLinkRuleResponse
     */
    'exempt_channels'?: Set<string> | null;
}
/**
 * 
 * @export
 * @interface StageInstanceResponse
 */
export interface StageInstanceResponse {
    /**
     * 
     * @type {string}
     * @memberof StageInstanceResponse
     */
    'guild_id': string;
    /**
     * 
     * @type {string}
     * @memberof StageInstanceResponse
     */
    'channel_id': string;
    /**
     * 
     * @type {string}
     * @memberof StageInstanceResponse
     */
    'topic': string;
    /**
     * 
     * @type {number}
     * @memberof StageInstanceResponse
     */
    'privacy_level': number;
    /**
     * 
     * @type {string}
     * @memberof StageInstanceResponse
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof StageInstanceResponse
     */
    'discoverable_disabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof StageInstanceResponse
     */
    'guild_scheduled_event_id'?: string;
}
/**
 * 
 * @export
 * @interface StageScheduledEventCreateRequest
 */
export interface StageScheduledEventCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventCreateRequest
     */
    'scheduled_start_time': string;
    /**
     * 
     * @type {any}
     * @memberof StageScheduledEventCreateRequest
     */
    'privacy_level': any;
    /**
     * 
     * @type {number}
     * @memberof StageScheduledEventCreateRequest
     */
    'entity_type': number | null;
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventCreateRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventCreateRequest
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventCreateRequest
     */
    'scheduled_end_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventCreateRequest
     */
    'channel_id'?: string;
    /**
     * 
     * @type {object}
     * @memberof StageScheduledEventCreateRequest
     */
    'entity_metadata'?: object;
}
/**
 * 
 * @export
 * @interface StageScheduledEventPatchRequestPartial
 */
export interface StageScheduledEventPatchRequestPartial {
    /**
     * 
     * @type {number}
     * @memberof StageScheduledEventPatchRequestPartial
     */
    'status'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventPatchRequestPartial
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventPatchRequestPartial
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventPatchRequestPartial
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventPatchRequestPartial
     */
    'scheduled_start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventPatchRequestPartial
     */
    'scheduled_end_time'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof StageScheduledEventPatchRequestPartial
     */
    'entity_type'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof StageScheduledEventPatchRequestPartial
     */
    'privacy_level'?: any;
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventPatchRequestPartial
     */
    'channel_id'?: string;
    /**
     * 
     * @type {object}
     * @memberof StageScheduledEventPatchRequestPartial
     */
    'entity_metadata'?: object;
}
/**
 * 
 * @export
 * @interface StageScheduledEventResponse
 */
export interface StageScheduledEventResponse {
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventResponse
     */
    'guild_id': string;
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventResponse
     */
    'scheduled_start_time': string;
    /**
     * 
     * @type {number}
     * @memberof StageScheduledEventResponse
     */
    'status': number | null;
    /**
     * 
     * @type {number}
     * @memberof StageScheduledEventResponse
     */
    'entity_type': number | null;
    /**
     * 
     * @type {any}
     * @memberof StageScheduledEventResponse
     */
    'privacy_level': any;
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventResponse
     */
    'channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventResponse
     */
    'creator_id'?: string;
    /**
     * 
     * @type {UserResponse}
     * @memberof StageScheduledEventResponse
     */
    'creator'?: UserResponse | null;
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventResponse
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventResponse
     */
    'scheduled_end_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StageScheduledEventResponse
     */
    'entity_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof StageScheduledEventResponse
     */
    'user_count'?: number | null;
    /**
     * 
     * @type {ScheduledEventUserResponse}
     * @memberof StageScheduledEventResponse
     */
    'user_rsvp'?: ScheduledEventUserResponse | null;
    /**
     * 
     * @type {object}
     * @memberof StageScheduledEventResponse
     */
    'entity_metadata'?: object;
}
/**
 * 
 * @export
 * @interface StandardStickerResponse
 */
export interface StandardStickerResponse {
    /**
     * 
     * @type {string}
     * @memberof StandardStickerResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StandardStickerResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StandardStickerResponse
     */
    'tags': string;
    /**
     * 
     * @type {number}
     * @memberof StandardStickerResponse
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof StandardStickerResponse
     */
    'pack_id': string;
    /**
     * 
     * @type {number}
     * @memberof StandardStickerResponse
     */
    'sort_value': number;
    /**
     * 
     * @type {number}
     * @memberof StandardStickerResponse
     */
    'format_type'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof StandardStickerResponse
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface StickerPackCollectionResponse
 */
export interface StickerPackCollectionResponse {
    /**
     * 
     * @type {Array<StickerPackResponse>}
     * @memberof StickerPackCollectionResponse
     */
    'sticker_packs': Array<StickerPackResponse>;
}
/**
 * 
 * @export
 * @interface StickerPackResponse
 */
export interface StickerPackResponse {
    /**
     * 
     * @type {string}
     * @memberof StickerPackResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StickerPackResponse
     */
    'sku_id': string;
    /**
     * 
     * @type {string}
     * @memberof StickerPackResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<StandardStickerResponse>}
     * @memberof StickerPackResponse
     */
    'stickers': Array<StandardStickerResponse>;
    /**
     * 
     * @type {string}
     * @memberof StickerPackResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StickerPackResponse
     */
    'cover_sticker_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StickerPackResponse
     */
    'banner_asset_id'?: string;
}
/**
 * 
 * @export
 * @interface StringSelectComponentForMessageRequest
 */
export interface StringSelectComponentForMessageRequest {
    /**
     * 
     * @type {number}
     * @memberof StringSelectComponentForMessageRequest
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof StringSelectComponentForMessageRequest
     */
    'custom_id': string;
    /**
     * 
     * @type {Array<StringSelectOptionForMessageRequest>}
     * @memberof StringSelectComponentForMessageRequest
     */
    'options': Array<StringSelectOptionForMessageRequest>;
    /**
     * 
     * @type {string}
     * @memberof StringSelectComponentForMessageRequest
     */
    'placeholder'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof StringSelectComponentForMessageRequest
     */
    'min_values'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof StringSelectComponentForMessageRequest
     */
    'max_values'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof StringSelectComponentForMessageRequest
     */
    'disabled'?: boolean | null;
}
/**
 * 
 * @export
 * @interface StringSelectComponentResponse
 */
export interface StringSelectComponentResponse {
    /**
     * 
     * @type {number}
     * @memberof StringSelectComponentResponse
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof StringSelectComponentResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof StringSelectComponentResponse
     */
    'custom_id': string;
    /**
     * 
     * @type {Array<StringSelectOptionResponse>}
     * @memberof StringSelectComponentResponse
     */
    'options': Array<StringSelectOptionResponse>;
    /**
     * 
     * @type {string}
     * @memberof StringSelectComponentResponse
     */
    'placeholder'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof StringSelectComponentResponse
     */
    'min_values'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof StringSelectComponentResponse
     */
    'max_values'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof StringSelectComponentResponse
     */
    'disabled'?: boolean | null;
}
/**
 * 
 * @export
 * @interface StringSelectOptionForMessageRequest
 */
export interface StringSelectOptionForMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof StringSelectOptionForMessageRequest
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof StringSelectOptionForMessageRequest
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof StringSelectOptionForMessageRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof StringSelectOptionForMessageRequest
     */
    'default'?: boolean | null;
    /**
     * 
     * @type {ComponentEmojiForMessageRequest}
     * @memberof StringSelectOptionForMessageRequest
     */
    'emoji'?: ComponentEmojiForMessageRequest | null;
}
/**
 * 
 * @export
 * @interface StringSelectOptionResponse
 */
export interface StringSelectOptionResponse {
    /**
     * 
     * @type {string}
     * @memberof StringSelectOptionResponse
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof StringSelectOptionResponse
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof StringSelectOptionResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {ComponentEmojiResponse}
     * @memberof StringSelectOptionResponse
     */
    'emoji'?: ComponentEmojiResponse | null;
    /**
     * 
     * @type {boolean}
     * @memberof StringSelectOptionResponse
     */
    'default'?: boolean | null;
}
/**
 * 
 * @export
 * @interface TeamMemberResponse
 */
export interface TeamMemberResponse {
    /**
     * 
     * @type {UserResponse}
     * @memberof TeamMemberResponse
     */
    'user': UserResponse;
    /**
     * 
     * @type {string}
     * @memberof TeamMemberResponse
     */
    'team_id': string;
    /**
     * 
     * @type {number}
     * @memberof TeamMemberResponse
     */
    'membership_state': number;
}
/**
 * 
 * @export
 * @interface TeamResponse
 */
export interface TeamResponse {
    /**
     * 
     * @type {string}
     * @memberof TeamResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TeamResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TeamResponse
     */
    'owner_user_id': string;
    /**
     * 
     * @type {Array<TeamMemberResponse>}
     * @memberof TeamResponse
     */
    'members': Array<TeamMemberResponse>;
    /**
     * 
     * @type {string}
     * @memberof TeamResponse
     */
    'icon'?: string | null;
}
/**
 * 
 * @export
 * @interface TextDisplayComponentForMessageRequest
 */
export interface TextDisplayComponentForMessageRequest {
    /**
     * 
     * @type {number}
     * @memberof TextDisplayComponentForMessageRequest
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof TextDisplayComponentForMessageRequest
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface TextDisplayComponentResponse
 */
export interface TextDisplayComponentResponse {
    /**
     * 
     * @type {number}
     * @memberof TextDisplayComponentResponse
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof TextDisplayComponentResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TextDisplayComponentResponse
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface TextInputComponentForModalRequest
 */
export interface TextInputComponentForModalRequest {
    /**
     * 
     * @type {number}
     * @memberof TextInputComponentForModalRequest
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof TextInputComponentForModalRequest
     */
    'custom_id': string;
    /**
     * 
     * @type {number}
     * @memberof TextInputComponentForModalRequest
     */
    'style': number;
    /**
     * 
     * @type {string}
     * @memberof TextInputComponentForModalRequest
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof TextInputComponentForModalRequest
     */
    'value'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TextInputComponentForModalRequest
     */
    'placeholder'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TextInputComponentForModalRequest
     */
    'required'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof TextInputComponentForModalRequest
     */
    'min_length'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TextInputComponentForModalRequest
     */
    'max_length'?: number | null;
}
/**
 * 
 * @export
 * @interface TextInputComponentResponse
 */
export interface TextInputComponentResponse {
    /**
     * 
     * @type {number}
     * @memberof TextInputComponentResponse
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof TextInputComponentResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TextInputComponentResponse
     */
    'custom_id': string;
    /**
     * 
     * @type {number}
     * @memberof TextInputComponentResponse
     */
    'style': number;
    /**
     * 
     * @type {string}
     * @memberof TextInputComponentResponse
     */
    'label'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TextInputComponentResponse
     */
    'value'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TextInputComponentResponse
     */
    'placeholder'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TextInputComponentResponse
     */
    'required'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof TextInputComponentResponse
     */
    'min_length'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TextInputComponentResponse
     */
    'max_length'?: number | null;
}
/**
 * 
 * @export
 * @interface ThreadMemberResponse
 */
export interface ThreadMemberResponse {
    /**
     * 
     * @type {string}
     * @memberof ThreadMemberResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ThreadMemberResponse
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof ThreadMemberResponse
     */
    'join_timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof ThreadMemberResponse
     */
    'flags': number;
    /**
     * 
     * @type {GuildMemberResponse}
     * @memberof ThreadMemberResponse
     */
    'member'?: GuildMemberResponse | null;
}
/**
 * 
 * @export
 * @interface ThreadMetadataResponse
 */
export interface ThreadMetadataResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ThreadMetadataResponse
     */
    'archived': boolean;
    /**
     * 
     * @type {number}
     * @memberof ThreadMetadataResponse
     */
    'auto_archive_duration': number;
    /**
     * 
     * @type {boolean}
     * @memberof ThreadMetadataResponse
     */
    'locked': boolean;
    /**
     * 
     * @type {string}
     * @memberof ThreadMetadataResponse
     */
    'archive_timestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ThreadMetadataResponse
     */
    'create_timestamp'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ThreadMetadataResponse
     */
    'invitable'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ThreadResponse
 */
export interface ThreadResponse {
    /**
     * 
     * @type {string}
     * @memberof ThreadResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ThreadResponse
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof ThreadResponse
     */
    'flags': number;
    /**
     * 
     * @type {string}
     * @memberof ThreadResponse
     */
    'guild_id': string;
    /**
     * 
     * @type {string}
     * @memberof ThreadResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ThreadResponse
     */
    'owner_id': string;
    /**
     * 
     * @type {number}
     * @memberof ThreadResponse
     */
    'message_count': number;
    /**
     * 
     * @type {number}
     * @memberof ThreadResponse
     */
    'member_count': number;
    /**
     * 
     * @type {number}
     * @memberof ThreadResponse
     */
    'total_message_sent': number;
    /**
     * 
     * @type {string}
     * @memberof ThreadResponse
     */
    'last_message_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThreadResponse
     */
    'last_pin_timestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ThreadResponse
     */
    'parent_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ThreadResponse
     */
    'rate_limit_per_user'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ThreadResponse
     */
    'bitrate'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ThreadResponse
     */
    'user_limit'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ThreadResponse
     */
    'rtc_region'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ThreadResponse
     */
    'video_quality_mode'?: number;
    /**
     * 
     * @type {string}
     * @memberof ThreadResponse
     */
    'permissions'?: string | null;
    /**
     * 
     * @type {ThreadMetadataResponse}
     * @memberof ThreadResponse
     */
    'thread_metadata'?: ThreadMetadataResponse | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ThreadResponse
     */
    'applied_tags'?: Array<string> | null;
    /**
     * 
     * @type {ThreadMemberResponse}
     * @memberof ThreadResponse
     */
    'member'?: ThreadMemberResponse | null;
}
/**
 * 
 * @export
 * @interface ThreadSearchResponse
 */
export interface ThreadSearchResponse {
    /**
     * 
     * @type {Array<ThreadResponse>}
     * @memberof ThreadSearchResponse
     */
    'threads': Array<ThreadResponse>;
    /**
     * 
     * @type {Array<ThreadMemberResponse>}
     * @memberof ThreadSearchResponse
     */
    'members': Array<ThreadMemberResponse>;
    /**
     * 
     * @type {boolean}
     * @memberof ThreadSearchResponse
     */
    'has_more'?: boolean | null;
    /**
     * 
     * @type {Array<MessageResponse>}
     * @memberof ThreadSearchResponse
     */
    'first_messages'?: Array<MessageResponse> | null;
    /**
     * 
     * @type {number}
     * @memberof ThreadSearchResponse
     */
    'total_results'?: number | null;
}
/**
 * @type ThreadSearchTagParameter
 * @export
 */
export type ThreadSearchTagParameter = Set<string> | string;

/**
 * 
 * @export
 * @interface ThreadsResponse
 */
export interface ThreadsResponse {
    /**
     * 
     * @type {Array<ThreadResponse>}
     * @memberof ThreadsResponse
     */
    'threads': Array<ThreadResponse>;
    /**
     * 
     * @type {Array<ThreadMemberResponse>}
     * @memberof ThreadsResponse
     */
    'members': Array<ThreadMemberResponse>;
    /**
     * 
     * @type {boolean}
     * @memberof ThreadsResponse
     */
    'has_more'?: boolean | null;
    /**
     * 
     * @type {Array<MessageResponse>}
     * @memberof ThreadsResponse
     */
    'first_messages'?: Array<MessageResponse> | null;
}
/**
 * 
 * @export
 * @interface ThumbnailComponentForMessageRequest
 */
export interface ThumbnailComponentForMessageRequest {
    /**
     * 
     * @type {number}
     * @memberof ThumbnailComponentForMessageRequest
     */
    'type': number;
    /**
     * 
     * @type {UnfurledMediaRequest}
     * @memberof ThumbnailComponentForMessageRequest
     */
    'media': UnfurledMediaRequest;
    /**
     * 
     * @type {string}
     * @memberof ThumbnailComponentForMessageRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ThumbnailComponentForMessageRequest
     */
    'spoiler'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ThumbnailComponentResponse
 */
export interface ThumbnailComponentResponse {
    /**
     * 
     * @type {number}
     * @memberof ThumbnailComponentResponse
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof ThumbnailComponentResponse
     */
    'id': number;
    /**
     * 
     * @type {UnfurledMediaResponse}
     * @memberof ThumbnailComponentResponse
     */
    'media': UnfurledMediaResponse;
    /**
     * 
     * @type {boolean}
     * @memberof ThumbnailComponentResponse
     */
    'spoiler': boolean;
    /**
     * 
     * @type {string}
     * @memberof ThumbnailComponentResponse
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface UnfurledMediaRequest
 */
export interface UnfurledMediaRequest {
    /**
     * 
     * @type {string}
     * @memberof UnfurledMediaRequest
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface UnfurledMediaRequestWithAttachmentReferenceRequired
 */
export interface UnfurledMediaRequestWithAttachmentReferenceRequired {
    /**
     * 
     * @type {string}
     * @memberof UnfurledMediaRequestWithAttachmentReferenceRequired
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface UnfurledMediaResponse
 */
export interface UnfurledMediaResponse {
    /**
     * 
     * @type {string}
     * @memberof UnfurledMediaResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UnfurledMediaResponse
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof UnfurledMediaResponse
     */
    'proxy_url': string;
    /**
     * 
     * @type {number}
     * @memberof UnfurledMediaResponse
     */
    'width'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UnfurledMediaResponse
     */
    'height'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UnfurledMediaResponse
     */
    'content_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UnfurledMediaResponse
     */
    'attachment_id'?: string;
}
/**
 * 
 * @export
 * @interface UpdateApplicationEmojiRequest
 */
export interface UpdateApplicationEmojiRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationEmojiRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UpdateApplicationUserRoleConnectionRequest
 */
export interface UpdateApplicationUserRoleConnectionRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationUserRoleConnectionRequest
     */
    'platform_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationUserRoleConnectionRequest
     */
    'platform_username'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateApplicationUserRoleConnectionRequest
     */
    'metadata'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface UpdateAutoModerationRuleRequest
 */
export interface UpdateAutoModerationRuleRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateAutoModerationRuleRequest
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateAutoModerationRuleRequest
     */
    'event_type'?: number;
    /**
     * 
     * @type {Array<DefaultKeywordListUpsertRequestActionsInner>}
     * @memberof UpdateAutoModerationRuleRequest
     */
    'actions'?: Array<DefaultKeywordListUpsertRequestActionsInner>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAutoModerationRuleRequest
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Set<string>}
     * @memberof UpdateAutoModerationRuleRequest
     */
    'exempt_roles'?: Set<string>;
    /**
     * 
     * @type {Set<string>}
     * @memberof UpdateAutoModerationRuleRequest
     */
    'exempt_channels'?: Set<string>;
    /**
     * 
     * @type {number}
     * @memberof UpdateAutoModerationRuleRequest
     */
    'trigger_type'?: number;
    /**
     * 
     * @type {MentionSpamTriggerMetadata}
     * @memberof UpdateAutoModerationRuleRequest
     */
    'trigger_metadata'?: MentionSpamTriggerMetadata;
}
/**
 * 
 * @export
 * @interface UpdateChannelRequest
 */
export interface UpdateChannelRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateChannelRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateChannelRequest
     */
    'icon'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateChannelRequest
     */
    'type'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateChannelRequest
     */
    'position'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateChannelRequest
     */
    'topic'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateChannelRequest
     */
    'bitrate'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateChannelRequest
     */
    'user_limit'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateChannelRequest
     */
    'nsfw'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateChannelRequest
     */
    'rate_limit_per_user'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateChannelRequest
     */
    'parent_id'?: string;
    /**
     * 
     * @type {Array<ChannelPermissionOverwriteRequest>}
     * @memberof UpdateChannelRequest
     */
    'permission_overwrites'?: Array<ChannelPermissionOverwriteRequest>;
    /**
     * 
     * @type {string}
     * @memberof UpdateChannelRequest
     */
    'rtc_region'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateChannelRequest
     */
    'video_quality_mode'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateChannelRequest
     */
    'default_auto_archive_duration'?: number;
    /**
     * 
     * @type {UpdateDefaultReactionEmojiRequest}
     * @memberof UpdateChannelRequest
     */
    'default_reaction_emoji'?: UpdateDefaultReactionEmojiRequest;
    /**
     * 
     * @type {number}
     * @memberof UpdateChannelRequest
     */
    'default_thread_rate_limit_per_user'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateChannelRequest
     */
    'default_sort_order'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateChannelRequest
     */
    'default_forum_layout'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateChannelRequest
     */
    'default_tag_setting'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateChannelRequest
     */
    'flags'?: number;
    /**
     * 
     * @type {Array<UpdateThreadTagRequest>}
     * @memberof UpdateChannelRequest
     */
    'available_tags'?: Array<UpdateThreadTagRequest>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateChannelRequest
     */
    'archived'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateChannelRequest
     */
    'locked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateChannelRequest
     */
    'invitable'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateChannelRequest
     */
    'auto_archive_duration'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateChannelRequest
     */
    'applied_tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateDMRequestPartial
 */
export interface UpdateDMRequestPartial {
    /**
     * 
     * @type {string}
     * @memberof UpdateDMRequestPartial
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateDefaultReactionEmojiRequest
 */
export interface UpdateDefaultReactionEmojiRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateDefaultReactionEmojiRequest
     */
    'emoji_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDefaultReactionEmojiRequest
     */
    'emoji_name'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateGroupDMRequestPartial
 */
export interface UpdateGroupDMRequestPartial {
    /**
     * 
     * @type {string}
     * @memberof UpdateGroupDMRequestPartial
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateGroupDMRequestPartial
     */
    'icon'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateGuildChannelRequestPartial
 */
export interface UpdateGuildChannelRequestPartial {
    /**
     * 
     * @type {number}
     * @memberof UpdateGuildChannelRequestPartial
     */
    'type'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateGuildChannelRequestPartial
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateGuildChannelRequestPartial
     */
    'position'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateGuildChannelRequestPartial
     */
    'topic'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateGuildChannelRequestPartial
     */
    'bitrate'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateGuildChannelRequestPartial
     */
    'user_limit'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateGuildChannelRequestPartial
     */
    'nsfw'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateGuildChannelRequestPartial
     */
    'rate_limit_per_user'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateGuildChannelRequestPartial
     */
    'parent_id'?: string;
    /**
     * 
     * @type {Array<ChannelPermissionOverwriteRequest>}
     * @memberof UpdateGuildChannelRequestPartial
     */
    'permission_overwrites'?: Array<ChannelPermissionOverwriteRequest> | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateGuildChannelRequestPartial
     */
    'rtc_region'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateGuildChannelRequestPartial
     */
    'video_quality_mode'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateGuildChannelRequestPartial
     */
    'default_auto_archive_duration'?: number;
    /**
     * 
     * @type {UpdateDefaultReactionEmojiRequest}
     * @memberof UpdateGuildChannelRequestPartial
     */
    'default_reaction_emoji'?: UpdateDefaultReactionEmojiRequest | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateGuildChannelRequestPartial
     */
    'default_thread_rate_limit_per_user'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateGuildChannelRequestPartial
     */
    'default_sort_order'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateGuildChannelRequestPartial
     */
    'default_forum_layout'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateGuildChannelRequestPartial
     */
    'default_tag_setting'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateGuildChannelRequestPartial
     */
    'flags'?: number | null;
    /**
     * 
     * @type {Array<UpdateThreadTagRequest>}
     * @memberof UpdateGuildChannelRequestPartial
     */
    'available_tags'?: Array<UpdateThreadTagRequest> | null;
}
/**
 * 
 * @export
 * @interface UpdateGuildEmojiRequest
 */
export interface UpdateGuildEmojiRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateGuildEmojiRequest
     */
    'name'?: string;
    /**
     * 
     * @type {Set<string | null>}
     * @memberof UpdateGuildEmojiRequest
     */
    'roles'?: Set<string | null> | null;
}
/**
 * 
 * @export
 * @interface UpdateGuildMemberRequest
 */
export interface UpdateGuildMemberRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateGuildMemberRequest
     */
    'nick'?: string | null;
    /**
     * 
     * @type {Set<string | null>}
     * @memberof UpdateGuildMemberRequest
     */
    'roles'?: Set<string | null> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateGuildMemberRequest
     */
    'mute'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateGuildMemberRequest
     */
    'deaf'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateGuildMemberRequest
     */
    'channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGuildMemberRequest
     */
    'communication_disabled_until'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateGuildMemberRequest
     */
    'flags'?: number | null;
}
/**
 * 
 * @export
 * @interface UpdateGuildOnboardingRequest
 */
export interface UpdateGuildOnboardingRequest {
    /**
     * 
     * @type {Array<UpdateOnboardingPromptRequest>}
     * @memberof UpdateGuildOnboardingRequest
     */
    'prompts'?: Array<UpdateOnboardingPromptRequest> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateGuildOnboardingRequest
     */
    'enabled'?: boolean | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof UpdateGuildOnboardingRequest
     */
    'default_channel_ids'?: Set<string> | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateGuildOnboardingRequest
     */
    'mode'?: number;
}
/**
 * 
 * @export
 * @interface UpdateGuildScheduledEventRequest
 */
export interface UpdateGuildScheduledEventRequest {
    /**
     * 
     * @type {number}
     * @memberof UpdateGuildScheduledEventRequest
     */
    'status'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateGuildScheduledEventRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGuildScheduledEventRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGuildScheduledEventRequest
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGuildScheduledEventRequest
     */
    'scheduled_start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGuildScheduledEventRequest
     */
    'scheduled_end_time'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateGuildScheduledEventRequest
     */
    'entity_type'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof UpdateGuildScheduledEventRequest
     */
    'privacy_level'?: any;
    /**
     * 
     * @type {string}
     * @memberof UpdateGuildScheduledEventRequest
     */
    'channel_id'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateGuildScheduledEventRequest
     */
    'entity_metadata'?: object;
}
/**
 * 
 * @export
 * @interface UpdateGuildStickerRequest
 */
export interface UpdateGuildStickerRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateGuildStickerRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGuildStickerRequest
     */
    'tags'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGuildStickerRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateGuildTemplateRequest
 */
export interface UpdateGuildTemplateRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateGuildTemplateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGuildTemplateRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateGuildWidgetSettingsRequest
 */
export interface UpdateGuildWidgetSettingsRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateGuildWidgetSettingsRequest
     */
    'channel_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateGuildWidgetSettingsRequest
     */
    'enabled'?: boolean | null;
}
/**
 * 
 * @export
 * @interface UpdateMessageInteractionCallbackRequest
 */
export interface UpdateMessageInteractionCallbackRequest {
    /**
     * 
     * @type {number}
     * @memberof UpdateMessageInteractionCallbackRequest
     */
    'type': number | null;
    /**
     * 
     * @type {IncomingWebhookUpdateForInteractionCallbackRequestPartial}
     * @memberof UpdateMessageInteractionCallbackRequest
     */
    'data'?: IncomingWebhookUpdateForInteractionCallbackRequestPartial | null;
}
/**
 * 
 * @export
 * @interface UpdateMessageInteractionCallbackResponse
 */
export interface UpdateMessageInteractionCallbackResponse {
    /**
     * 
     * @type {number}
     * @memberof UpdateMessageInteractionCallbackResponse
     */
    'type': number | null;
    /**
     * 
     * @type {MessageResponse}
     * @memberof UpdateMessageInteractionCallbackResponse
     */
    'message': MessageResponse;
}
/**
 * 
 * @export
 * @interface UpdateMyGuildMemberRequest
 */
export interface UpdateMyGuildMemberRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateMyGuildMemberRequest
     */
    'nick'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateOnboardingPromptRequest
 */
export interface UpdateOnboardingPromptRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateOnboardingPromptRequest
     */
    'title': string;
    /**
     * 
     * @type {Array<OnboardingPromptOptionRequest>}
     * @memberof UpdateOnboardingPromptRequest
     */
    'options': Array<OnboardingPromptOptionRequest>;
    /**
     * 
     * @type {string}
     * @memberof UpdateOnboardingPromptRequest
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateOnboardingPromptRequest
     */
    'single_select'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateOnboardingPromptRequest
     */
    'required'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateOnboardingPromptRequest
     */
    'in_onboarding'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateOnboardingPromptRequest
     */
    'type'?: number;
}
/**
 * 
 * @export
 * @interface UpdateSelfVoiceStateRequest
 */
export interface UpdateSelfVoiceStateRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateSelfVoiceStateRequest
     */
    'request_to_speak_timestamp'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateSelfVoiceStateRequest
     */
    'suppress'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSelfVoiceStateRequest
     */
    'channel_id'?: string;
}
/**
 * 
 * @export
 * @interface UpdateStageInstanceRequest
 */
export interface UpdateStageInstanceRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateStageInstanceRequest
     */
    'topic'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateStageInstanceRequest
     */
    'privacy_level'?: number;
}
/**
 * 
 * @export
 * @interface UpdateThreadRequestPartial
 */
export interface UpdateThreadRequestPartial {
    /**
     * 
     * @type {string}
     * @memberof UpdateThreadRequestPartial
     */
    'name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateThreadRequestPartial
     */
    'archived'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateThreadRequestPartial
     */
    'locked'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateThreadRequestPartial
     */
    'invitable'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateThreadRequestPartial
     */
    'auto_archive_duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateThreadRequestPartial
     */
    'rate_limit_per_user'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateThreadRequestPartial
     */
    'flags'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateThreadRequestPartial
     */
    'applied_tags'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateThreadRequestPartial
     */
    'bitrate'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateThreadRequestPartial
     */
    'user_limit'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateThreadRequestPartial
     */
    'rtc_region'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateThreadRequestPartial
     */
    'video_quality_mode'?: number;
}
/**
 * 
 * @export
 * @interface UpdateThreadTagRequest
 */
export interface UpdateThreadTagRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateThreadTagRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateThreadTagRequest
     */
    'emoji_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateThreadTagRequest
     */
    'emoji_name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateThreadTagRequest
     */
    'moderated'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateThreadTagRequest
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface UpdateVoiceStateRequest
 */
export interface UpdateVoiceStateRequest {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateVoiceStateRequest
     */
    'suppress'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateVoiceStateRequest
     */
    'channel_id'?: string;
}
/**
 * 
 * @export
 * @interface UpdateWebhookByTokenRequest
 */
export interface UpdateWebhookByTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookByTokenRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookByTokenRequest
     */
    'avatar'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateWebhookRequest
 */
export interface UpdateWebhookRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookRequest
     */
    'avatar'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookRequest
     */
    'channel_id'?: string;
}
/**
 * 
 * @export
 * @interface UserAvatarDecorationResponse
 */
export interface UserAvatarDecorationResponse {
    /**
     * 
     * @type {string}
     * @memberof UserAvatarDecorationResponse
     */
    'asset': string;
    /**
     * 
     * @type {string}
     * @memberof UserAvatarDecorationResponse
     */
    'sku_id'?: string;
}
/**
 * 
 * @export
 * @interface UserCollectiblesResponse
 */
export interface UserCollectiblesResponse {
    /**
     * 
     * @type {UserNameplateResponse}
     * @memberof UserCollectiblesResponse
     */
    'nameplate'?: UserNameplateResponse | null;
}
/**
 * 
 * @export
 * @interface UserCommunicationDisabledAction
 */
export interface UserCommunicationDisabledAction {
    /**
     * 
     * @type {number}
     * @memberof UserCommunicationDisabledAction
     */
    'type': number;
    /**
     * 
     * @type {UserCommunicationDisabledActionMetadata}
     * @memberof UserCommunicationDisabledAction
     */
    'metadata': UserCommunicationDisabledActionMetadata;
}
/**
 * 
 * @export
 * @interface UserCommunicationDisabledActionMetadata
 */
export interface UserCommunicationDisabledActionMetadata {
    /**
     * 
     * @type {number}
     * @memberof UserCommunicationDisabledActionMetadata
     */
    'duration_seconds'?: number | null;
}
/**
 * 
 * @export
 * @interface UserCommunicationDisabledActionMetadataResponse
 */
export interface UserCommunicationDisabledActionMetadataResponse {
    /**
     * 
     * @type {number}
     * @memberof UserCommunicationDisabledActionMetadataResponse
     */
    'duration_seconds': number;
}
/**
 * 
 * @export
 * @interface UserCommunicationDisabledActionResponse
 */
export interface UserCommunicationDisabledActionResponse {
    /**
     * 
     * @type {number}
     * @memberof UserCommunicationDisabledActionResponse
     */
    'type': number;
    /**
     * 
     * @type {UserCommunicationDisabledActionMetadataResponse}
     * @memberof UserCommunicationDisabledActionResponse
     */
    'metadata': UserCommunicationDisabledActionMetadataResponse;
}
/**
 * 
 * @export
 * @interface UserGuildOnboardingResponse
 */
export interface UserGuildOnboardingResponse {
    /**
     * 
     * @type {string}
     * @memberof UserGuildOnboardingResponse
     */
    'guild_id': string;
    /**
     * 
     * @type {Array<OnboardingPromptResponse>}
     * @memberof UserGuildOnboardingResponse
     */
    'prompts': Array<OnboardingPromptResponse>;
    /**
     * 
     * @type {Set<string>}
     * @memberof UserGuildOnboardingResponse
     */
    'default_channel_ids': Set<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UserGuildOnboardingResponse
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface UserNameplateResponse
 */
export interface UserNameplateResponse {
    /**
     * 
     * @type {string}
     * @memberof UserNameplateResponse
     */
    'sku_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserNameplateResponse
     */
    'asset'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserNameplateResponse
     */
    'label'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserNameplateResponse
     */
    'palette'?: string;
}
/**
 * 
 * @export
 * @interface UserPIIResponse
 */
export interface UserPIIResponse {
    /**
     * 
     * @type {string}
     * @memberof UserPIIResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserPIIResponse
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserPIIResponse
     */
    'discriminator': string;
    /**
     * 
     * @type {number}
     * @memberof UserPIIResponse
     */
    'public_flags': number;
    /**
     * 
     * @type {number}
     * @memberof UserPIIResponse
     */
    'flags': number;
    /**
     * 
     * @type {boolean}
     * @memberof UserPIIResponse
     */
    'mfa_enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserPIIResponse
     */
    'locale': string;
    /**
     * 
     * @type {string}
     * @memberof UserPIIResponse
     */
    'avatar'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPIIResponse
     */
    'bot'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPIIResponse
     */
    'system'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof UserPIIResponse
     */
    'banner'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserPIIResponse
     */
    'accent_color'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UserPIIResponse
     */
    'global_name'?: string | null;
    /**
     * 
     * @type {UserAvatarDecorationResponse}
     * @memberof UserPIIResponse
     */
    'avatar_decoration_data'?: UserAvatarDecorationResponse | null;
    /**
     * 
     * @type {UserCollectiblesResponse}
     * @memberof UserPIIResponse
     */
    'collectibles'?: UserCollectiblesResponse | null;
    /**
     * 
     * @type {UserPrimaryGuildResponse}
     * @memberof UserPIIResponse
     */
    'primary_guild'?: UserPrimaryGuildResponse | null;
    /**
     * 
     * @type {number}
     * @memberof UserPIIResponse
     */
    'premium_type'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserPIIResponse
     */
    'email'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPIIResponse
     */
    'verified'?: boolean | null;
}
/**
 * 
 * @export
 * @interface UserPrimaryGuildResponse
 */
export interface UserPrimaryGuildResponse {
    /**
     * 
     * @type {string}
     * @memberof UserPrimaryGuildResponse
     */
    'identity_guild_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserPrimaryGuildResponse
     */
    'identity_enabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof UserPrimaryGuildResponse
     */
    'tag'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserPrimaryGuildResponse
     */
    'badge'?: string | null;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'discriminator': string;
    /**
     * 
     * @type {number}
     * @memberof UserResponse
     */
    'public_flags': number;
    /**
     * 
     * @type {number}
     * @memberof UserResponse
     */
    'flags': number;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'avatar'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponse
     */
    'bot'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponse
     */
    'system'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'banner'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserResponse
     */
    'accent_color'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'global_name'?: string | null;
    /**
     * 
     * @type {UserAvatarDecorationResponse}
     * @memberof UserResponse
     */
    'avatar_decoration_data'?: UserAvatarDecorationResponse | null;
    /**
     * 
     * @type {UserCollectiblesResponse}
     * @memberof UserResponse
     */
    'collectibles'?: UserCollectiblesResponse | null;
    /**
     * 
     * @type {UserPrimaryGuildResponse}
     * @memberof UserResponse
     */
    'primary_guild'?: UserPrimaryGuildResponse | null;
}
/**
 * 
 * @export
 * @interface UserSelectComponentForMessageRequest
 */
export interface UserSelectComponentForMessageRequest {
    /**
     * 
     * @type {number}
     * @memberof UserSelectComponentForMessageRequest
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof UserSelectComponentForMessageRequest
     */
    'custom_id': string;
    /**
     * 
     * @type {string}
     * @memberof UserSelectComponentForMessageRequest
     */
    'placeholder'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserSelectComponentForMessageRequest
     */
    'min_values'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UserSelectComponentForMessageRequest
     */
    'max_values'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserSelectComponentForMessageRequest
     */
    'disabled'?: boolean | null;
    /**
     * 
     * @type {Array<UserSelectDefaultValue>}
     * @memberof UserSelectComponentForMessageRequest
     */
    'default_values'?: Array<UserSelectDefaultValue> | null;
}
/**
 * 
 * @export
 * @interface UserSelectComponentResponse
 */
export interface UserSelectComponentResponse {
    /**
     * 
     * @type {number}
     * @memberof UserSelectComponentResponse
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof UserSelectComponentResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserSelectComponentResponse
     */
    'custom_id': string;
    /**
     * 
     * @type {string}
     * @memberof UserSelectComponentResponse
     */
    'placeholder'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserSelectComponentResponse
     */
    'min_values'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UserSelectComponentResponse
     */
    'max_values'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserSelectComponentResponse
     */
    'disabled'?: boolean | null;
    /**
     * 
     * @type {Array<UserSelectDefaultValueResponse>}
     * @memberof UserSelectComponentResponse
     */
    'default_values'?: Array<UserSelectDefaultValueResponse> | null;
}
/**
 * 
 * @export
 * @interface UserSelectDefaultValue
 */
export interface UserSelectDefaultValue {
    /**
     * 
     * @type {string}
     * @memberof UserSelectDefaultValue
     */
    'type': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSelectDefaultValue
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface UserSelectDefaultValueResponse
 */
export interface UserSelectDefaultValueResponse {
    /**
     * 
     * @type {string}
     * @memberof UserSelectDefaultValueResponse
     */
    'type': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSelectDefaultValueResponse
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface VanityURLErrorResponse
 */
export interface VanityURLErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof VanityURLErrorResponse
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof VanityURLErrorResponse
     */
    'code': number;
}
/**
 * 
 * @export
 * @interface VanityURLResponse
 */
export interface VanityURLResponse {
    /**
     * 
     * @type {number}
     * @memberof VanityURLResponse
     */
    'uses': number;
    /**
     * 
     * @type {string}
     * @memberof VanityURLResponse
     */
    'code'?: string | null;
    /**
     * 
     * @type {VanityURLErrorResponse}
     * @memberof VanityURLResponse
     */
    'error'?: VanityURLErrorResponse | null;
}
/**
 * 
 * @export
 * @interface VoiceRegionResponse
 */
export interface VoiceRegionResponse {
    /**
     * 
     * @type {string}
     * @memberof VoiceRegionResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof VoiceRegionResponse
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof VoiceRegionResponse
     */
    'custom': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VoiceRegionResponse
     */
    'deprecated': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VoiceRegionResponse
     */
    'optimal': boolean;
}
/**
 * 
 * @export
 * @interface VoiceScheduledEventCreateRequest
 */
export interface VoiceScheduledEventCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventCreateRequest
     */
    'scheduled_start_time': string;
    /**
     * 
     * @type {any}
     * @memberof VoiceScheduledEventCreateRequest
     */
    'privacy_level': any;
    /**
     * 
     * @type {number}
     * @memberof VoiceScheduledEventCreateRequest
     */
    'entity_type': number | null;
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventCreateRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventCreateRequest
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventCreateRequest
     */
    'scheduled_end_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventCreateRequest
     */
    'channel_id'?: string;
    /**
     * 
     * @type {object}
     * @memberof VoiceScheduledEventCreateRequest
     */
    'entity_metadata'?: object;
}
/**
 * 
 * @export
 * @interface VoiceScheduledEventPatchRequestPartial
 */
export interface VoiceScheduledEventPatchRequestPartial {
    /**
     * 
     * @type {number}
     * @memberof VoiceScheduledEventPatchRequestPartial
     */
    'status'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventPatchRequestPartial
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventPatchRequestPartial
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventPatchRequestPartial
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventPatchRequestPartial
     */
    'scheduled_start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventPatchRequestPartial
     */
    'scheduled_end_time'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof VoiceScheduledEventPatchRequestPartial
     */
    'entity_type'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof VoiceScheduledEventPatchRequestPartial
     */
    'privacy_level'?: any;
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventPatchRequestPartial
     */
    'channel_id'?: string;
    /**
     * 
     * @type {object}
     * @memberof VoiceScheduledEventPatchRequestPartial
     */
    'entity_metadata'?: object;
}
/**
 * 
 * @export
 * @interface VoiceScheduledEventResponse
 */
export interface VoiceScheduledEventResponse {
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventResponse
     */
    'guild_id': string;
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventResponse
     */
    'scheduled_start_time': string;
    /**
     * 
     * @type {number}
     * @memberof VoiceScheduledEventResponse
     */
    'status': number | null;
    /**
     * 
     * @type {number}
     * @memberof VoiceScheduledEventResponse
     */
    'entity_type': number | null;
    /**
     * 
     * @type {any}
     * @memberof VoiceScheduledEventResponse
     */
    'privacy_level': any;
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventResponse
     */
    'channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventResponse
     */
    'creator_id'?: string;
    /**
     * 
     * @type {UserResponse}
     * @memberof VoiceScheduledEventResponse
     */
    'creator'?: UserResponse | null;
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventResponse
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventResponse
     */
    'scheduled_end_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VoiceScheduledEventResponse
     */
    'entity_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof VoiceScheduledEventResponse
     */
    'user_count'?: number | null;
    /**
     * 
     * @type {ScheduledEventUserResponse}
     * @memberof VoiceScheduledEventResponse
     */
    'user_rsvp'?: ScheduledEventUserResponse | null;
    /**
     * 
     * @type {object}
     * @memberof VoiceScheduledEventResponse
     */
    'entity_metadata'?: object;
}
/**
 * 
 * @export
 * @interface VoiceStateResponse
 */
export interface VoiceStateResponse {
    /**
     * 
     * @type {boolean}
     * @memberof VoiceStateResponse
     */
    'deaf': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VoiceStateResponse
     */
    'mute': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VoiceStateResponse
     */
    'suppress': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VoiceStateResponse
     */
    'self_deaf': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VoiceStateResponse
     */
    'self_mute': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VoiceStateResponse
     */
    'self_video': boolean;
    /**
     * 
     * @type {string}
     * @memberof VoiceStateResponse
     */
    'session_id': string;
    /**
     * 
     * @type {string}
     * @memberof VoiceStateResponse
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof VoiceStateResponse
     */
    'channel_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VoiceStateResponse
     */
    'guild_id'?: string;
    /**
     * 
     * @type {GuildMemberResponse}
     * @memberof VoiceStateResponse
     */
    'member'?: GuildMemberResponse | null;
    /**
     * 
     * @type {string}
     * @memberof VoiceStateResponse
     */
    'request_to_speak_timestamp'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof VoiceStateResponse
     */
    'self_stream'?: boolean | null;
}
/**
 * 
 * @export
 * @interface WebhookSlackEmbed
 */
export interface WebhookSlackEmbed {
    /**
     * 
     * @type {string}
     * @memberof WebhookSlackEmbed
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookSlackEmbed
     */
    'title_link'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookSlackEmbed
     */
    'text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookSlackEmbed
     */
    'color'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WebhookSlackEmbed
     */
    'ts'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookSlackEmbed
     */
    'pretext'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookSlackEmbed
     */
    'footer'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookSlackEmbed
     */
    'footer_icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookSlackEmbed
     */
    'author_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookSlackEmbed
     */
    'author_link'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookSlackEmbed
     */
    'author_icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookSlackEmbed
     */
    'image_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookSlackEmbed
     */
    'thumb_url'?: string | null;
    /**
     * 
     * @type {Array<WebhookSlackEmbedField>}
     * @memberof WebhookSlackEmbed
     */
    'fields'?: Array<WebhookSlackEmbedField> | null;
}
/**
 * 
 * @export
 * @interface WebhookSlackEmbedField
 */
export interface WebhookSlackEmbedField {
    /**
     * 
     * @type {string}
     * @memberof WebhookSlackEmbedField
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookSlackEmbedField
     */
    'value'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookSlackEmbedField
     */
    'inline'?: boolean | null;
}
/**
 * 
 * @export
 * @interface WebhookSourceChannelResponse
 */
export interface WebhookSourceChannelResponse {
    /**
     * 
     * @type {string}
     * @memberof WebhookSourceChannelResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookSourceChannelResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface WebhookSourceGuildResponse
 */
export interface WebhookSourceGuildResponse {
    /**
     * 
     * @type {string}
     * @memberof WebhookSourceGuildResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookSourceGuildResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookSourceGuildResponse
     */
    'icon'?: string | null;
}
/**
 * 
 * @export
 * @interface WelcomeMessageResponse
 */
export interface WelcomeMessageResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof WelcomeMessageResponse
     */
    'author_ids': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface WelcomeScreenPatchRequestPartial
 */
export interface WelcomeScreenPatchRequestPartial {
    /**
     * 
     * @type {string}
     * @memberof WelcomeScreenPatchRequestPartial
     */
    'description'?: string | null;
    /**
     * 
     * @type {Array<GuildWelcomeChannel>}
     * @memberof WelcomeScreenPatchRequestPartial
     */
    'welcome_channels'?: Array<GuildWelcomeChannel> | null;
    /**
     * 
     * @type {boolean}
     * @memberof WelcomeScreenPatchRequestPartial
     */
    'enabled'?: boolean | null;
}
/**
 * 
 * @export
 * @interface WidgetActivity
 */
export interface WidgetActivity {
    /**
     * 
     * @type {string}
     * @memberof WidgetActivity
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface WidgetChannel
 */
export interface WidgetChannel {
    /**
     * 
     * @type {string}
     * @memberof WidgetChannel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetChannel
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof WidgetChannel
     */
    'position': number;
}
/**
 * 
 * @export
 * @interface WidgetMember
 */
export interface WidgetMember {
    /**
     * 
     * @type {string}
     * @memberof WidgetMember
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetMember
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetMember
     */
    'discriminator': string | null;
    /**
     * 
     * @type {string}
     * @memberof WidgetMember
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetMember
     */
    'avatar_url': string;
    /**
     * 
     * @type {any}
     * @memberof WidgetMember
     */
    'avatar'?: any | null;
    /**
     * 
     * @type {WidgetActivity}
     * @memberof WidgetMember
     */
    'activity'?: WidgetActivity | null;
    /**
     * 
     * @type {boolean}
     * @memberof WidgetMember
     */
    'deaf'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof WidgetMember
     */
    'mute'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof WidgetMember
     */
    'self_deaf'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof WidgetMember
     */
    'self_mute'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof WidgetMember
     */
    'suppress'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof WidgetMember
     */
    'channel_id'?: string;
}
/**
 * 
 * @export
 * @interface WidgetResponse
 */
export interface WidgetResponse {
    /**
     * 
     * @type {string}
     * @memberof WidgetResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<WidgetChannel>}
     * @memberof WidgetResponse
     */
    'channels': Array<WidgetChannel>;
    /**
     * 
     * @type {Array<WidgetMember>}
     * @memberof WidgetResponse
     */
    'members': Array<WidgetMember>;
    /**
     * 
     * @type {number}
     * @memberof WidgetResponse
     */
    'presence_count': number;
    /**
     * 
     * @type {string}
     * @memberof WidgetResponse
     */
    'instant_invite'?: string | null;
}
/**
 * 
 * @export
 * @interface WidgetSettingsResponse
 */
export interface WidgetSettingsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof WidgetSettingsResponse
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof WidgetSettingsResponse
     */
    'channel_id'?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} channelId 
         * @param {string} userId 
         * @param {AddGroupDmUserRequest} addGroupDmUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupDmUser: async (channelId: string, userId: string, addGroupDmUserRequest: AddGroupDmUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('addGroupDmUser', 'channelId', channelId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addGroupDmUser', 'userId', userId)
            // verify required parameter 'addGroupDmUserRequest' is not null or undefined
            assertParamExists('addGroupDmUser', 'addGroupDmUserRequest', addGroupDmUserRequest)
            const localVarPath = `/channels/{channel_id}/recipients/{user_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addGroupDmUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {AddGuildMemberRequest} addGuildMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGuildMember: async (guildId: string, userId: string, addGuildMemberRequest: AddGuildMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('addGuildMember', 'guildId', guildId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addGuildMember', 'userId', userId)
            // verify required parameter 'addGuildMemberRequest' is not null or undefined
            assertParamExists('addGuildMember', 'addGuildMemberRequest', addGuildMemberRequest)
            const localVarPath = `/guilds/{guild_id}/members/{user_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addGuildMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGuildMemberRole: async (guildId: string, userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('addGuildMemberRole', 'guildId', guildId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addGuildMemberRole', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('addGuildMemberRole', 'roleId', roleId)
            const localVarPath = `/guilds/{guild_id}/members/{user_id}/roles/{role_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {string} userId 
         * @param {AddLobbyMemberRequest} addLobbyMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLobbyMember: async (lobbyId: string, userId: string, addLobbyMemberRequest: AddLobbyMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lobbyId' is not null or undefined
            assertParamExists('addLobbyMember', 'lobbyId', lobbyId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addLobbyMember', 'userId', userId)
            // verify required parameter 'addLobbyMemberRequest' is not null or undefined
            assertParamExists('addLobbyMember', 'addLobbyMemberRequest', addLobbyMemberRequest)
            const localVarPath = `/lobbies/{lobby_id}/members/{user_id}`
                .replace(`{${"lobby_id"}}`, encodeURIComponent(String(lobbyId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addLobbyMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {string} emojiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMyMessageReaction: async (channelId: string, messageId: string, emojiName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('addMyMessageReaction', 'channelId', channelId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('addMyMessageReaction', 'messageId', messageId)
            // verify required parameter 'emojiName' is not null or undefined
            assertParamExists('addMyMessageReaction', 'emojiName', emojiName)
            const localVarPath = `/channels/{channel_id}/messages/{message_id}/reactions/{emoji_name}/@me`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)))
                .replace(`{${"emoji_name"}}`, encodeURIComponent(String(emojiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addThreadMember: async (channelId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('addThreadMember', 'channelId', channelId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addThreadMember', 'userId', userId)
            const localVarPath = `/channels/{channel_id}/thread-members/{user_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applicationsGetActivityInstance: async (applicationId: string, instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('applicationsGetActivityInstance', 'applicationId', applicationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('applicationsGetActivityInstance', 'instanceId', instanceId)
            const localVarPath = `/applications/{application_id}/activity-instances/{instance_id}`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {BanUserFromGuildRequest} banUserFromGuildRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banUserFromGuild: async (guildId: string, userId: string, banUserFromGuildRequest: BanUserFromGuildRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('banUserFromGuild', 'guildId', guildId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('banUserFromGuild', 'userId', userId)
            // verify required parameter 'banUserFromGuildRequest' is not null or undefined
            assertParamExists('banUserFromGuild', 'banUserFromGuildRequest', banUserFromGuildRequest)
            const localVarPath = `/guilds/{guild_id}/bans/{user_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(banUserFromGuildRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {BulkBanUsersFromGuildRequest} bulkBanUsersFromGuildRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkBanUsersFromGuild: async (guildId: string, bulkBanUsersFromGuildRequest: BulkBanUsersFromGuildRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('bulkBanUsersFromGuild', 'guildId', guildId)
            // verify required parameter 'bulkBanUsersFromGuildRequest' is not null or undefined
            assertParamExists('bulkBanUsersFromGuild', 'bulkBanUsersFromGuildRequest', bulkBanUsersFromGuildRequest)
            const localVarPath = `/guilds/{guild_id}/bulk-ban`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkBanUsersFromGuildRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {BulkDeleteMessagesRequest} bulkDeleteMessagesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteMessages: async (channelId: string, bulkDeleteMessagesRequest: BulkDeleteMessagesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('bulkDeleteMessages', 'channelId', channelId)
            // verify required parameter 'bulkDeleteMessagesRequest' is not null or undefined
            assertParamExists('bulkDeleteMessages', 'bulkDeleteMessagesRequest', bulkDeleteMessagesRequest)
            const localVarPath = `/channels/{channel_id}/messages/bulk-delete`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkDeleteMessagesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {Array<ApplicationCommandUpdateRequest> | null} applicationCommandUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSetApplicationCommands: async (applicationId: string, applicationCommandUpdateRequest: Array<ApplicationCommandUpdateRequest> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('bulkSetApplicationCommands', 'applicationId', applicationId)
            // verify required parameter 'applicationCommandUpdateRequest' is not null or undefined
            assertParamExists('bulkSetApplicationCommands', 'applicationCommandUpdateRequest', applicationCommandUpdateRequest)
            const localVarPath = `/applications/{application_id}/commands`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationCommandUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {Array<ApplicationCommandUpdateRequest> | null} applicationCommandUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSetGuildApplicationCommands: async (applicationId: string, guildId: string, applicationCommandUpdateRequest: Array<ApplicationCommandUpdateRequest> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('bulkSetGuildApplicationCommands', 'applicationId', applicationId)
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('bulkSetGuildApplicationCommands', 'guildId', guildId)
            // verify required parameter 'applicationCommandUpdateRequest' is not null or undefined
            assertParamExists('bulkSetGuildApplicationCommands', 'applicationCommandUpdateRequest', applicationCommandUpdateRequest)
            const localVarPath = `/applications/{application_id}/guilds/{guild_id}/commands`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationCommandUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {Array<BulkUpdateGuildChannelsRequestInner>} bulkUpdateGuildChannelsRequestInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateGuildChannels: async (guildId: string, bulkUpdateGuildChannelsRequestInner: Array<BulkUpdateGuildChannelsRequestInner>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('bulkUpdateGuildChannels', 'guildId', guildId)
            // verify required parameter 'bulkUpdateGuildChannelsRequestInner' is not null or undefined
            assertParamExists('bulkUpdateGuildChannels', 'bulkUpdateGuildChannelsRequestInner', bulkUpdateGuildChannelsRequestInner)
            const localVarPath = `/guilds/{guild_id}/channels`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkUpdateGuildChannelsRequestInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {Array<BulkUpdateGuildRolesRequestInner>} bulkUpdateGuildRolesRequestInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateGuildRoles: async (guildId: string, bulkUpdateGuildRolesRequestInner: Array<BulkUpdateGuildRolesRequestInner>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('bulkUpdateGuildRoles', 'guildId', guildId)
            // verify required parameter 'bulkUpdateGuildRolesRequestInner' is not null or undefined
            assertParamExists('bulkUpdateGuildRoles', 'bulkUpdateGuildRolesRequestInner', bulkUpdateGuildRolesRequestInner)
            const localVarPath = `/guilds/{guild_id}/roles`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkUpdateGuildRolesRequestInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {Array<BulkLobbyMemberRequest> | null} bulkLobbyMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateLobbyMembers: async (lobbyId: string, bulkLobbyMemberRequest: Array<BulkLobbyMemberRequest> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lobbyId' is not null or undefined
            assertParamExists('bulkUpdateLobbyMembers', 'lobbyId', lobbyId)
            // verify required parameter 'bulkLobbyMemberRequest' is not null or undefined
            assertParamExists('bulkUpdateLobbyMembers', 'bulkLobbyMemberRequest', bulkLobbyMemberRequest)
            const localVarPath = `/lobbies/{lobby_id}/members/bulk`
                .replace(`{${"lobby_id"}}`, encodeURIComponent(String(lobbyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkLobbyMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} entitlementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumeEntitlement: async (applicationId: string, entitlementId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('consumeEntitlement', 'applicationId', applicationId)
            // verify required parameter 'entitlementId' is not null or undefined
            assertParamExists('consumeEntitlement', 'entitlementId', entitlementId)
            const localVarPath = `/applications/{application_id}/entitlements/{entitlement_id}/consume`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"entitlement_id"}}`, encodeURIComponent(String(entitlementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.entitlements"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.entitlements"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.entitlements"], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {ApplicationCommandCreateRequest} applicationCommandCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationCommand: async (applicationId: string, applicationCommandCreateRequest: ApplicationCommandCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationCommand', 'applicationId', applicationId)
            // verify required parameter 'applicationCommandCreateRequest' is not null or undefined
            assertParamExists('createApplicationCommand', 'applicationCommandCreateRequest', applicationCommandCreateRequest)
            const localVarPath = `/applications/{application_id}/commands`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationCommandCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {CreateApplicationEmojiRequest} createApplicationEmojiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEmoji: async (applicationId: string, createApplicationEmojiRequest: CreateApplicationEmojiRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationEmoji', 'applicationId', applicationId)
            // verify required parameter 'createApplicationEmojiRequest' is not null or undefined
            assertParamExists('createApplicationEmoji', 'createApplicationEmojiRequest', createApplicationEmojiRequest)
            const localVarPath = `/applications/{application_id}/emojis`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApplicationEmojiRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {CreateAutoModerationRuleRequest} createAutoModerationRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAutoModerationRule: async (guildId: string, createAutoModerationRuleRequest: CreateAutoModerationRuleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('createAutoModerationRule', 'guildId', guildId)
            // verify required parameter 'createAutoModerationRuleRequest' is not null or undefined
            assertParamExists('createAutoModerationRule', 'createAutoModerationRuleRequest', createAutoModerationRuleRequest)
            const localVarPath = `/guilds/{guild_id}/auto-moderation/rules`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAutoModerationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {CreateChannelInviteRequest} createChannelInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannelInvite: async (channelId: string, createChannelInviteRequest: CreateChannelInviteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('createChannelInvite', 'channelId', channelId)
            // verify required parameter 'createChannelInviteRequest' is not null or undefined
            assertParamExists('createChannelInvite', 'createChannelInviteRequest', createChannelInviteRequest)
            const localVarPath = `/channels/{channel_id}/invites`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createChannelInviteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreatePrivateChannelRequest} createPrivateChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDm: async (createPrivateChannelRequest: CreatePrivateChannelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPrivateChannelRequest' is not null or undefined
            assertParamExists('createDm', 'createPrivateChannelRequest', createPrivateChannelRequest)
            const localVarPath = `/users/@me/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPrivateChannelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {CreateEntitlementRequestData} createEntitlementRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntitlement: async (applicationId: string, createEntitlementRequestData: CreateEntitlementRequestData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createEntitlement', 'applicationId', applicationId)
            // verify required parameter 'createEntitlementRequestData' is not null or undefined
            assertParamExists('createEntitlement', 'createEntitlementRequestData', createEntitlementRequestData)
            const localVarPath = `/applications/{application_id}/entitlements`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEntitlementRequestData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GuildCreateRequest} guildCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuild: async (guildCreateRequest: GuildCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildCreateRequest' is not null or undefined
            assertParamExists('createGuild', 'guildCreateRequest', guildCreateRequest)
            const localVarPath = `/guilds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(guildCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {ApplicationCommandCreateRequest} applicationCommandCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuildApplicationCommand: async (applicationId: string, guildId: string, applicationCommandCreateRequest: ApplicationCommandCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createGuildApplicationCommand', 'applicationId', applicationId)
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('createGuildApplicationCommand', 'guildId', guildId)
            // verify required parameter 'applicationCommandCreateRequest' is not null or undefined
            assertParamExists('createGuildApplicationCommand', 'applicationCommandCreateRequest', applicationCommandCreateRequest)
            const localVarPath = `/applications/{application_id}/guilds/{guild_id}/commands`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationCommandCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {CreateGuildChannelRequest} createGuildChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuildChannel: async (guildId: string, createGuildChannelRequest: CreateGuildChannelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('createGuildChannel', 'guildId', guildId)
            // verify required parameter 'createGuildChannelRequest' is not null or undefined
            assertParamExists('createGuildChannel', 'createGuildChannelRequest', createGuildChannelRequest)
            const localVarPath = `/guilds/{guild_id}/channels`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGuildChannelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {CreateGuildEmojiRequest} createGuildEmojiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuildEmoji: async (guildId: string, createGuildEmojiRequest: CreateGuildEmojiRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('createGuildEmoji', 'guildId', guildId)
            // verify required parameter 'createGuildEmojiRequest' is not null or undefined
            assertParamExists('createGuildEmoji', 'createGuildEmojiRequest', createGuildEmojiRequest)
            const localVarPath = `/guilds/{guild_id}/emojis`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGuildEmojiRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} code 
         * @param {CreateGuildFromTemplateRequest} createGuildFromTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuildFromTemplate: async (code: string, createGuildFromTemplateRequest: CreateGuildFromTemplateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('createGuildFromTemplate', 'code', code)
            // verify required parameter 'createGuildFromTemplateRequest' is not null or undefined
            assertParamExists('createGuildFromTemplate', 'createGuildFromTemplateRequest', createGuildFromTemplateRequest)
            const localVarPath = `/guilds/templates/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGuildFromTemplateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {CreateGuildRoleRequest} createGuildRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuildRole: async (guildId: string, createGuildRoleRequest: CreateGuildRoleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('createGuildRole', 'guildId', guildId)
            // verify required parameter 'createGuildRoleRequest' is not null or undefined
            assertParamExists('createGuildRole', 'createGuildRoleRequest', createGuildRoleRequest)
            const localVarPath = `/guilds/{guild_id}/roles`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGuildRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {CreateGuildScheduledEventRequest} createGuildScheduledEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuildScheduledEvent: async (guildId: string, createGuildScheduledEventRequest: CreateGuildScheduledEventRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('createGuildScheduledEvent', 'guildId', guildId)
            // verify required parameter 'createGuildScheduledEventRequest' is not null or undefined
            assertParamExists('createGuildScheduledEvent', 'createGuildScheduledEventRequest', createGuildScheduledEventRequest)
            const localVarPath = `/guilds/{guild_id}/scheduled-events`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGuildScheduledEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {SoundboardCreateRequest} soundboardCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuildSoundboardSound: async (guildId: string, soundboardCreateRequest: SoundboardCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('createGuildSoundboardSound', 'guildId', guildId)
            // verify required parameter 'soundboardCreateRequest' is not null or undefined
            assertParamExists('createGuildSoundboardSound', 'soundboardCreateRequest', soundboardCreateRequest)
            const localVarPath = `/guilds/{guild_id}/soundboard-sounds`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(soundboardCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} name 
         * @param {string} tags 
         * @param {string} file 
         * @param {string | null} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuildSticker: async (guildId: string, name: string, tags: string, file: string, description?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('createGuildSticker', 'guildId', guildId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createGuildSticker', 'name', name)
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('createGuildSticker', 'tags', tags)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createGuildSticker', 'file', file)
            const localVarPath = `/guilds/{guild_id}/stickers`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (tags !== undefined) { 
                localVarFormParams.append('tags', tags as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {CreateGuildTemplateRequest} createGuildTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuildTemplate: async (guildId: string, createGuildTemplateRequest: CreateGuildTemplateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('createGuildTemplate', 'guildId', guildId)
            // verify required parameter 'createGuildTemplateRequest' is not null or undefined
            assertParamExists('createGuildTemplate', 'createGuildTemplateRequest', createGuildTemplateRequest)
            const localVarPath = `/guilds/{guild_id}/templates`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGuildTemplateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} interactionId 
         * @param {string} interactionToken 
         * @param {CreateInteractionResponseRequest} createInteractionResponseRequest 
         * @param {boolean} [withResponse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInteractionResponse: async (interactionId: string, interactionToken: string, createInteractionResponseRequest: CreateInteractionResponseRequest, withResponse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'interactionId' is not null or undefined
            assertParamExists('createInteractionResponse', 'interactionId', interactionId)
            // verify required parameter 'interactionToken' is not null or undefined
            assertParamExists('createInteractionResponse', 'interactionToken', interactionToken)
            // verify required parameter 'createInteractionResponseRequest' is not null or undefined
            assertParamExists('createInteractionResponse', 'createInteractionResponseRequest', createInteractionResponseRequest)
            const localVarPath = `/interactions/{interaction_id}/{interaction_token}/callback`
                .replace(`{${"interaction_id"}}`, encodeURIComponent(String(interactionId)))
                .replace(`{${"interaction_token"}}`, encodeURIComponent(String(interactionToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (withResponse !== undefined) {
                localVarQueryParameter['with_response'] = withResponse;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createInteractionResponseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateLobbyRequest} createLobbyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLobby: async (createLobbyRequest: CreateLobbyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createLobbyRequest' is not null or undefined
            assertParamExists('createLobby', 'createLobbyRequest', createLobbyRequest)
            const localVarPath = `/lobbies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createLobbyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {SDKMessageRequest} sDKMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLobbyMessage: async (lobbyId: string, sDKMessageRequest: SDKMessageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lobbyId' is not null or undefined
            assertParamExists('createLobbyMessage', 'lobbyId', lobbyId)
            // verify required parameter 'sDKMessageRequest' is not null or undefined
            assertParamExists('createLobbyMessage', 'sDKMessageRequest', sDKMessageRequest)
            const localVarPath = `/lobbies/{lobby_id}/messages`
                .replace(`{${"lobby_id"}}`, encodeURIComponent(String(lobbyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sDKMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {MessageCreateRequest} messageCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessage: async (channelId: string, messageCreateRequest: MessageCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('createMessage', 'channelId', channelId)
            // verify required parameter 'messageCreateRequest' is not null or undefined
            assertParamExists('createMessage', 'messageCreateRequest', messageCreateRequest)
            const localVarPath = `/channels/{channel_id}/messages`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messageCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateOrJoinLobbyRequest} createOrJoinLobbyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrJoinLobby: async (createOrJoinLobbyRequest: CreateOrJoinLobbyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrJoinLobbyRequest' is not null or undefined
            assertParamExists('createOrJoinLobby', 'createOrJoinLobbyRequest', createOrJoinLobbyRequest)
            const localVarPath = `/lobbies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrJoinLobbyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPin: async (channelId: string, messageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('createPin', 'channelId', channelId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('createPin', 'messageId', messageId)
            const localVarPath = `/channels/{channel_id}/messages/pins/{message_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateStageInstanceRequest} createStageInstanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStageInstance: async (createStageInstanceRequest: CreateStageInstanceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createStageInstanceRequest' is not null or undefined
            assertParamExists('createStageInstance', 'createStageInstanceRequest', createStageInstanceRequest)
            const localVarPath = `/stage-instances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStageInstanceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {CreateThreadRequest} createThreadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createThread: async (channelId: string, createThreadRequest: CreateThreadRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('createThread', 'channelId', channelId)
            // verify required parameter 'createThreadRequest' is not null or undefined
            assertParamExists('createThread', 'createThreadRequest', createThreadRequest)
            const localVarPath = `/channels/{channel_id}/threads`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createThreadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {CreateTextThreadWithMessageRequest} createTextThreadWithMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createThreadFromMessage: async (channelId: string, messageId: string, createTextThreadWithMessageRequest: CreateTextThreadWithMessageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('createThreadFromMessage', 'channelId', channelId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('createThreadFromMessage', 'messageId', messageId)
            // verify required parameter 'createTextThreadWithMessageRequest' is not null or undefined
            assertParamExists('createThreadFromMessage', 'createTextThreadWithMessageRequest', createTextThreadWithMessageRequest)
            const localVarPath = `/channels/{channel_id}/messages/{message_id}/threads`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTextThreadWithMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {CreateWebhookRequest} createWebhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: async (channelId: string, createWebhookRequest: CreateWebhookRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('createWebhook', 'channelId', channelId)
            // verify required parameter 'createWebhookRequest' is not null or undefined
            assertParamExists('createWebhook', 'createWebhookRequest', createWebhookRequest)
            const localVarPath = `/channels/{channel_id}/webhooks`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crosspostMessage: async (channelId: string, messageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('crosspostMessage', 'channelId', channelId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('crosspostMessage', 'messageId', messageId)
            const localVarPath = `/channels/{channel_id}/messages/{message_id}/crosspost`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllMessageReactions: async (channelId: string, messageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('deleteAllMessageReactions', 'channelId', channelId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deleteAllMessageReactions', 'messageId', messageId)
            const localVarPath = `/channels/{channel_id}/messages/{message_id}/reactions`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {string} emojiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllMessageReactionsByEmoji: async (channelId: string, messageId: string, emojiName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('deleteAllMessageReactionsByEmoji', 'channelId', channelId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deleteAllMessageReactionsByEmoji', 'messageId', messageId)
            // verify required parameter 'emojiName' is not null or undefined
            assertParamExists('deleteAllMessageReactionsByEmoji', 'emojiName', emojiName)
            const localVarPath = `/channels/{channel_id}/messages/{message_id}/reactions/{emoji_name}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)))
                .replace(`{${"emoji_name"}}`, encodeURIComponent(String(emojiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} commandId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationCommand: async (applicationId: string, commandId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationCommand', 'applicationId', applicationId)
            // verify required parameter 'commandId' is not null or undefined
            assertParamExists('deleteApplicationCommand', 'commandId', commandId)
            const localVarPath = `/applications/{application_id}/commands/{command_id}`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"command_id"}}`, encodeURIComponent(String(commandId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} emojiId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationEmoji: async (applicationId: string, emojiId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationEmoji', 'applicationId', applicationId)
            // verify required parameter 'emojiId' is not null or undefined
            assertParamExists('deleteApplicationEmoji', 'emojiId', emojiId)
            const localVarPath = `/applications/{application_id}/emojis/{emoji_id}`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"emoji_id"}}`, encodeURIComponent(String(emojiId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationUserRoleConnection: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationUserRoleConnection', 'applicationId', applicationId)
            const localVarPath = `/users/@me/applications/{application_id}/role-connection`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["role_connections.write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} ruleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAutoModerationRule: async (guildId: string, ruleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('deleteAutoModerationRule', 'guildId', guildId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('deleteAutoModerationRule', 'ruleId', ruleId)
            const localVarPath = `/guilds/{guild_id}/auto-moderation/rules/{rule_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannel: async (channelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('deleteChannel', 'channelId', channelId)
            const localVarPath = `/channels/{channel_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} overwriteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannelPermissionOverwrite: async (channelId: string, overwriteId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('deleteChannelPermissionOverwrite', 'channelId', channelId)
            // verify required parameter 'overwriteId' is not null or undefined
            assertParamExists('deleteChannelPermissionOverwrite', 'overwriteId', overwriteId)
            const localVarPath = `/channels/{channel_id}/permissions/{overwrite_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"overwrite_id"}}`, encodeURIComponent(String(overwriteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} entitlementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntitlement: async (applicationId: string, entitlementId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteEntitlement', 'applicationId', applicationId)
            // verify required parameter 'entitlementId' is not null or undefined
            assertParamExists('deleteEntitlement', 'entitlementId', entitlementId)
            const localVarPath = `/applications/{application_id}/entitlements/{entitlement_id}`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"entitlement_id"}}`, encodeURIComponent(String(entitlementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.entitlements"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.entitlements"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.entitlements"], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupDmUser: async (channelId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('deleteGroupDmUser', 'channelId', channelId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteGroupDmUser', 'userId', userId)
            const localVarPath = `/channels/{channel_id}/recipients/{user_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuild: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('deleteGuild', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {string} commandId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildApplicationCommand: async (applicationId: string, guildId: string, commandId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteGuildApplicationCommand', 'applicationId', applicationId)
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('deleteGuildApplicationCommand', 'guildId', guildId)
            // verify required parameter 'commandId' is not null or undefined
            assertParamExists('deleteGuildApplicationCommand', 'commandId', commandId)
            const localVarPath = `/applications/{application_id}/guilds/{guild_id}/commands/{command_id}`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"command_id"}}`, encodeURIComponent(String(commandId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} emojiId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildEmoji: async (guildId: string, emojiId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('deleteGuildEmoji', 'guildId', guildId)
            // verify required parameter 'emojiId' is not null or undefined
            assertParamExists('deleteGuildEmoji', 'emojiId', emojiId)
            const localVarPath = `/guilds/{guild_id}/emojis/{emoji_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"emoji_id"}}`, encodeURIComponent(String(emojiId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} integrationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildIntegration: async (guildId: string, integrationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('deleteGuildIntegration', 'guildId', guildId)
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('deleteGuildIntegration', 'integrationId', integrationId)
            const localVarPath = `/guilds/{guild_id}/integrations/{integration_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"integration_id"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildMember: async (guildId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('deleteGuildMember', 'guildId', guildId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteGuildMember', 'userId', userId)
            const localVarPath = `/guilds/{guild_id}/members/{user_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildMemberRole: async (guildId: string, userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('deleteGuildMemberRole', 'guildId', guildId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteGuildMemberRole', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('deleteGuildMemberRole', 'roleId', roleId)
            const localVarPath = `/guilds/{guild_id}/members/{user_id}/roles/{role_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildRole: async (guildId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('deleteGuildRole', 'guildId', guildId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('deleteGuildRole', 'roleId', roleId)
            const localVarPath = `/guilds/{guild_id}/roles/{role_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} guildScheduledEventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildScheduledEvent: async (guildId: string, guildScheduledEventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('deleteGuildScheduledEvent', 'guildId', guildId)
            // verify required parameter 'guildScheduledEventId' is not null or undefined
            assertParamExists('deleteGuildScheduledEvent', 'guildScheduledEventId', guildScheduledEventId)
            const localVarPath = `/guilds/{guild_id}/scheduled-events/{guild_scheduled_event_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"guild_scheduled_event_id"}}`, encodeURIComponent(String(guildScheduledEventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} soundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildSoundboardSound: async (guildId: string, soundId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('deleteGuildSoundboardSound', 'guildId', guildId)
            // verify required parameter 'soundId' is not null or undefined
            assertParamExists('deleteGuildSoundboardSound', 'soundId', soundId)
            const localVarPath = `/guilds/{guild_id}/soundboard-sounds/{sound_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"sound_id"}}`, encodeURIComponent(String(soundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} stickerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildSticker: async (guildId: string, stickerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('deleteGuildSticker', 'guildId', guildId)
            // verify required parameter 'stickerId' is not null or undefined
            assertParamExists('deleteGuildSticker', 'stickerId', stickerId)
            const localVarPath = `/guilds/{guild_id}/stickers/{sticker_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"sticker_id"}}`, encodeURIComponent(String(stickerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildTemplate: async (guildId: string, code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('deleteGuildTemplate', 'guildId', guildId)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('deleteGuildTemplate', 'code', code)
            const localVarPath = `/guilds/{guild_id}/templates/{code}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLobbyMember: async (lobbyId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lobbyId' is not null or undefined
            assertParamExists('deleteLobbyMember', 'lobbyId', lobbyId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteLobbyMember', 'userId', userId)
            const localVarPath = `/lobbies/{lobby_id}/members/{user_id}`
                .replace(`{${"lobby_id"}}`, encodeURIComponent(String(lobbyId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage: async (channelId: string, messageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('deleteMessage', 'channelId', channelId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deleteMessage', 'messageId', messageId)
            const localVarPath = `/channels/{channel_id}/messages/{message_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {string} emojiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMyMessageReaction: async (channelId: string, messageId: string, emojiName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('deleteMyMessageReaction', 'channelId', channelId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deleteMyMessageReaction', 'messageId', messageId)
            // verify required parameter 'emojiName' is not null or undefined
            assertParamExists('deleteMyMessageReaction', 'emojiName', emojiName)
            const localVarPath = `/channels/{channel_id}/messages/{message_id}/reactions/{emoji_name}/@me`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)))
                .replace(`{${"emoji_name"}}`, encodeURIComponent(String(emojiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {string} [threadId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOriginalWebhookMessage: async (webhookId: string, webhookToken: string, threadId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteOriginalWebhookMessage', 'webhookId', webhookId)
            // verify required parameter 'webhookToken' is not null or undefined
            assertParamExists('deleteOriginalWebhookMessage', 'webhookToken', webhookToken)
            const localVarPath = `/webhooks/{webhook_id}/{webhook_token}/messages/@original`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
                .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (threadId !== undefined) {
                localVarQueryParameter['thread_id'] = threadId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePin: async (channelId: string, messageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('deletePin', 'channelId', channelId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deletePin', 'messageId', messageId)
            const localVarPath = `/channels/{channel_id}/messages/pins/{message_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStageInstance: async (channelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('deleteStageInstance', 'channelId', channelId)
            const localVarPath = `/stage-instances/{channel_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteThreadMember: async (channelId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('deleteThreadMember', 'channelId', channelId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteThreadMember', 'userId', userId)
            const localVarPath = `/channels/{channel_id}/thread-members/{user_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {string} emojiName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserMessageReaction: async (channelId: string, messageId: string, emojiName: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('deleteUserMessageReaction', 'channelId', channelId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deleteUserMessageReaction', 'messageId', messageId)
            // verify required parameter 'emojiName' is not null or undefined
            assertParamExists('deleteUserMessageReaction', 'emojiName', emojiName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserMessageReaction', 'userId', userId)
            const localVarPath = `/channels/{channel_id}/messages/{message_id}/reactions/{emoji_name}/{user_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)))
                .replace(`{${"emoji_name"}}`, encodeURIComponent(String(emojiName)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteWebhook', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookByToken: async (webhookId: string, webhookToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteWebhookByToken', 'webhookId', webhookId)
            // verify required parameter 'webhookToken' is not null or undefined
            assertParamExists('deleteWebhookByToken', 'webhookToken', webhookToken)
            const localVarPath = `/webhooks/{webhook_id}/{webhook_token}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
                .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {string} messageId 
         * @param {string} [threadId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookMessage: async (webhookId: string, webhookToken: string, messageId: string, threadId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteWebhookMessage', 'webhookId', webhookId)
            // verify required parameter 'webhookToken' is not null or undefined
            assertParamExists('deleteWebhookMessage', 'webhookToken', webhookToken)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deleteWebhookMessage', 'messageId', messageId)
            const localVarPath = `/webhooks/{webhook_id}/{webhook_token}/messages/{message_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
                .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (threadId !== undefined) {
                localVarQueryParameter['thread_id'] = threadId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedCreatePin: async (channelId: string, messageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('deprecatedCreatePin', 'channelId', channelId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deprecatedCreatePin', 'messageId', messageId)
            const localVarPath = `/channels/{channel_id}/pins/{message_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedDeletePin: async (channelId: string, messageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('deprecatedDeletePin', 'channelId', channelId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deprecatedDeletePin', 'messageId', messageId)
            const localVarPath = `/channels/{channel_id}/pins/{message_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedListPins: async (channelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('deprecatedListPins', 'channelId', channelId)
            const localVarPath = `/channels/{channel_id}/pins`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {CreateLobbyRequest} createLobbyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editLobby: async (lobbyId: string, createLobbyRequest: CreateLobbyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lobbyId' is not null or undefined
            assertParamExists('editLobby', 'lobbyId', lobbyId)
            // verify required parameter 'createLobbyRequest' is not null or undefined
            assertParamExists('editLobby', 'createLobbyRequest', createLobbyRequest)
            const localVarPath = `/lobbies/{lobby_id}`
                .replace(`{${"lobby_id"}}`, encodeURIComponent(String(lobbyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createLobbyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {EditLobbyChannelLinkRequest} editLobbyChannelLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editLobbyChannelLink: async (lobbyId: string, editLobbyChannelLinkRequest: EditLobbyChannelLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lobbyId' is not null or undefined
            assertParamExists('editLobbyChannelLink', 'lobbyId', lobbyId)
            // verify required parameter 'editLobbyChannelLinkRequest' is not null or undefined
            assertParamExists('editLobbyChannelLink', 'editLobbyChannelLinkRequest', editLobbyChannelLinkRequest)
            const localVarPath = `/lobbies/{lobby_id}/channel-linking`
                .replace(`{${"lobby_id"}}`, encodeURIComponent(String(lobbyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editLobbyChannelLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {GithubWebhook} githubWebhook 
         * @param {boolean} [wait] 
         * @param {string} [threadId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeGithubCompatibleWebhook: async (webhookId: string, webhookToken: string, githubWebhook: GithubWebhook, wait?: boolean, threadId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('executeGithubCompatibleWebhook', 'webhookId', webhookId)
            // verify required parameter 'webhookToken' is not null or undefined
            assertParamExists('executeGithubCompatibleWebhook', 'webhookToken', webhookToken)
            // verify required parameter 'githubWebhook' is not null or undefined
            assertParamExists('executeGithubCompatibleWebhook', 'githubWebhook', githubWebhook)
            const localVarPath = `/webhooks/{webhook_id}/{webhook_token}/github`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
                .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (threadId !== undefined) {
                localVarQueryParameter['thread_id'] = threadId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(githubWebhook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {SlackWebhook} slackWebhook 
         * @param {boolean} [wait] 
         * @param {string} [threadId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSlackCompatibleWebhook: async (webhookId: string, webhookToken: string, slackWebhook: SlackWebhook, wait?: boolean, threadId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('executeSlackCompatibleWebhook', 'webhookId', webhookId)
            // verify required parameter 'webhookToken' is not null or undefined
            assertParamExists('executeSlackCompatibleWebhook', 'webhookToken', webhookToken)
            // verify required parameter 'slackWebhook' is not null or undefined
            assertParamExists('executeSlackCompatibleWebhook', 'slackWebhook', slackWebhook)
            const localVarPath = `/webhooks/{webhook_id}/{webhook_token}/slack`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
                .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (threadId !== undefined) {
                localVarQueryParameter['thread_id'] = threadId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(slackWebhook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {ExecuteWebhookRequest} executeWebhookRequest 
         * @param {boolean} [wait] 
         * @param {string} [threadId] 
         * @param {boolean} [withComponents] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWebhook: async (webhookId: string, webhookToken: string, executeWebhookRequest: ExecuteWebhookRequest, wait?: boolean, threadId?: string, withComponents?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('executeWebhook', 'webhookId', webhookId)
            // verify required parameter 'webhookToken' is not null or undefined
            assertParamExists('executeWebhook', 'webhookToken', webhookToken)
            // verify required parameter 'executeWebhookRequest' is not null or undefined
            assertParamExists('executeWebhook', 'executeWebhookRequest', executeWebhookRequest)
            const localVarPath = `/webhooks/{webhook_id}/{webhook_token}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
                .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (threadId !== undefined) {
                localVarQueryParameter['thread_id'] = threadId;
            }

            if (withComponents !== undefined) {
                localVarQueryParameter['with_components'] = withComponents;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {FollowChannelRequest} followChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followChannel: async (channelId: string, followChannelRequest: FollowChannelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('followChannel', 'channelId', channelId)
            // verify required parameter 'followChannelRequest' is not null or undefined
            assertParamExists('followChannel', 'followChannelRequest', followChannelRequest)
            const localVarPath = `/channels/{channel_id}/followers`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(followChannelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveGuildThreads: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getActiveGuildThreads', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/threads/active`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {number} answerId 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnswerVoters: async (channelId: string, messageId: string, answerId: number, after?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('getAnswerVoters', 'channelId', channelId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('getAnswerVoters', 'messageId', messageId)
            // verify required parameter 'answerId' is not null or undefined
            assertParamExists('getAnswerVoters', 'answerId', answerId)
            const localVarPath = `/channels/{channel_id}/polls/{message_id}/answers/{answer_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)))
                .replace(`{${"answer_id"}}`, encodeURIComponent(String(answerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplication', 'applicationId', applicationId)
            const localVarPath = `/applications/{application_id}`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} commandId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationCommand: async (applicationId: string, commandId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationCommand', 'applicationId', applicationId)
            // verify required parameter 'commandId' is not null or undefined
            assertParamExists('getApplicationCommand', 'commandId', commandId)
            const localVarPath = `/applications/{application_id}/commands/{command_id}`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"command_id"}}`, encodeURIComponent(String(commandId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} emojiId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationEmoji: async (applicationId: string, emojiId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationEmoji', 'applicationId', applicationId)
            // verify required parameter 'emojiId' is not null or undefined
            assertParamExists('getApplicationEmoji', 'emojiId', emojiId)
            const localVarPath = `/applications/{application_id}/emojis/{emoji_id}`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"emoji_id"}}`, encodeURIComponent(String(emojiId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationRoleConnectionsMetadata: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationRoleConnectionsMetadata', 'applicationId', applicationId)
            const localVarPath = `/applications/{application_id}/role-connections/metadata`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUserRoleConnection: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationUserRoleConnection', 'applicationId', applicationId)
            const localVarPath = `/users/@me/applications/{application_id}/role-connection`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["role_connections.write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} ruleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoModerationRule: async (guildId: string, ruleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getAutoModerationRule', 'guildId', guildId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('getAutoModerationRule', 'ruleId', ruleId)
            const localVarPath = `/guilds/{guild_id}/auto-moderation/rules/{rule_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotGateway: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gateway/bot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel: async (channelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('getChannel', 'channelId', channelId)
            const localVarPath = `/channels/{channel_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} entitlementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlement: async (applicationId: string, entitlementId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getEntitlement', 'applicationId', applicationId)
            // verify required parameter 'entitlementId' is not null or undefined
            assertParamExists('getEntitlement', 'entitlementId', entitlementId)
            const localVarPath = `/applications/{application_id}/entitlements/{entitlement_id}`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"entitlement_id"}}`, encodeURIComponent(String(entitlementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.entitlements"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.entitlements"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.entitlements"], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetEntitlementsSkuIdsParameter} skuIds 
         * @param {string} applicationId 
         * @param {string} [userId] 
         * @param {string} [guildId] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {boolean} [excludeEnded] 
         * @param {boolean} [excludeDeleted] 
         * @param {boolean} [onlyActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlements: async (skuIds: GetEntitlementsSkuIdsParameter, applicationId: string, userId?: string, guildId?: string, before?: string, after?: string, limit?: number, excludeEnded?: boolean, excludeDeleted?: boolean, onlyActive?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'skuIds' is not null or undefined
            assertParamExists('getEntitlements', 'skuIds', skuIds)
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getEntitlements', 'applicationId', applicationId)
            const localVarPath = `/applications/{application_id}/entitlements`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.entitlements"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.entitlements"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.entitlements"], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (skuIds !== undefined) {
                for (const [key, value] of Object.entries(skuIds)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (guildId !== undefined) {
                localVarQueryParameter['guild_id'] = guildId;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (excludeEnded !== undefined) {
                localVarQueryParameter['exclude_ended'] = excludeEnded;
            }

            if (excludeDeleted !== undefined) {
                localVarQueryParameter['exclude_deleted'] = excludeDeleted;
            }

            if (onlyActive !== undefined) {
                localVarQueryParameter['only_active'] = onlyActive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGateway: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gateway`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {boolean} [withCounts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuild: async (guildId: string, withCounts?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getGuild', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (withCounts !== undefined) {
                localVarQueryParameter['with_counts'] = withCounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {string} commandId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildApplicationCommand: async (applicationId: string, guildId: string, commandId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getGuildApplicationCommand', 'applicationId', applicationId)
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getGuildApplicationCommand', 'guildId', guildId)
            // verify required parameter 'commandId' is not null or undefined
            assertParamExists('getGuildApplicationCommand', 'commandId', commandId)
            const localVarPath = `/applications/{application_id}/guilds/{guild_id}/commands/{command_id}`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"command_id"}}`, encodeURIComponent(String(commandId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {string} commandId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildApplicationCommandPermissions: async (applicationId: string, guildId: string, commandId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getGuildApplicationCommandPermissions', 'applicationId', applicationId)
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getGuildApplicationCommandPermissions', 'guildId', guildId)
            // verify required parameter 'commandId' is not null or undefined
            assertParamExists('getGuildApplicationCommandPermissions', 'commandId', commandId)
            const localVarPath = `/applications/{application_id}/guilds/{guild_id}/commands/{command_id}/permissions`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"command_id"}}`, encodeURIComponent(String(commandId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.permissions.update"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.permissions.update"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.permissions.update"], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildBan: async (guildId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getGuildBan', 'guildId', guildId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getGuildBan', 'userId', userId)
            const localVarPath = `/guilds/{guild_id}/bans/{user_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} emojiId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildEmoji: async (guildId: string, emojiId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getGuildEmoji', 'guildId', guildId)
            // verify required parameter 'emojiId' is not null or undefined
            assertParamExists('getGuildEmoji', 'emojiId', emojiId)
            const localVarPath = `/guilds/{guild_id}/emojis/{emoji_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"emoji_id"}}`, encodeURIComponent(String(emojiId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildMember: async (guildId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getGuildMember', 'guildId', guildId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getGuildMember', 'userId', userId)
            const localVarPath = `/guilds/{guild_id}/members/{user_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildNewMemberWelcome: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getGuildNewMemberWelcome', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/new-member-welcome`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildPreview: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getGuildPreview', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/preview`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildRole: async (guildId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getGuildRole', 'guildId', guildId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('getGuildRole', 'roleId', roleId)
            const localVarPath = `/guilds/{guild_id}/roles/{role_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} guildScheduledEventId 
         * @param {boolean} [withUserCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildScheduledEvent: async (guildId: string, guildScheduledEventId: string, withUserCount?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getGuildScheduledEvent', 'guildId', guildId)
            // verify required parameter 'guildScheduledEventId' is not null or undefined
            assertParamExists('getGuildScheduledEvent', 'guildScheduledEventId', guildScheduledEventId)
            const localVarPath = `/guilds/{guild_id}/scheduled-events/{guild_scheduled_event_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"guild_scheduled_event_id"}}`, encodeURIComponent(String(guildScheduledEventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (withUserCount !== undefined) {
                localVarQueryParameter['with_user_count'] = withUserCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} soundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildSoundboardSound: async (guildId: string, soundId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getGuildSoundboardSound', 'guildId', guildId)
            // verify required parameter 'soundId' is not null or undefined
            assertParamExists('getGuildSoundboardSound', 'soundId', soundId)
            const localVarPath = `/guilds/{guild_id}/soundboard-sounds/{sound_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"sound_id"}}`, encodeURIComponent(String(soundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} stickerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildSticker: async (guildId: string, stickerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getGuildSticker', 'guildId', guildId)
            // verify required parameter 'stickerId' is not null or undefined
            assertParamExists('getGuildSticker', 'stickerId', stickerId)
            const localVarPath = `/guilds/{guild_id}/stickers/{sticker_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"sticker_id"}}`, encodeURIComponent(String(stickerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildTemplate: async (code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('getGuildTemplate', 'code', code)
            const localVarPath = `/guilds/templates/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildVanityUrl: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getGuildVanityUrl', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/vanity-url`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildWebhooks: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getGuildWebhooks', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/webhooks`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildWelcomeScreen: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getGuildWelcomeScreen', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/welcome-screen`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildWidget: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getGuildWidget', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/widget.json`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} [style] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildWidgetPng: async (guildId: string, style?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getGuildWidgetPng', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/widget.png`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (style !== undefined) {
                localVarQueryParameter['style'] = style;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildWidgetSettings: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getGuildWidgetSettings', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/widget`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildsOnboarding: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getGuildsOnboarding', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/onboarding`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLobby: async (lobbyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lobbyId' is not null or undefined
            assertParamExists('getLobby', 'lobbyId', lobbyId)
            const localVarPath = `/lobbies/{lobby_id}`
                .replace(`{${"lobby_id"}}`, encodeURIComponent(String(lobbyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLobbyMessages: async (lobbyId: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lobbyId' is not null or undefined
            assertParamExists('getLobbyMessages', 'lobbyId', lobbyId)
            const localVarPath = `/lobbies/{lobby_id}/messages`
                .replace(`{${"lobby_id"}}`, encodeURIComponent(String(lobbyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage: async (channelId: string, messageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('getMessage', 'channelId', channelId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('getMessage', 'messageId', messageId)
            const localVarPath = `/channels/{channel_id}/messages/{message_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyApplication: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/applications/@me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyGuildMember: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getMyGuildMember', 'guildId', guildId)
            const localVarPath = `/users/@me/guilds/{guild_id}/member`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["guilds.members.read"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["guilds.members.read"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["guilds.members.read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyOauth2Application: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth2/applications/@me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyOauth2Authorization: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth2/@me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["activities.invites.write", "activities.read", "activities.write", "applications.builds.read", "applications.builds.upload", "applications.commands", "applications.commands.permissions.update", "applications.entitlements", "applications.store.update", "bot", "connections", "dm_channels.read", "email", "gdm.join", "guilds", "guilds.join", "guilds.members.read", "identify", "messages.read", "openid", "relationships.read", "rpc", "rpc.activities.write", "rpc.notifications.read", "rpc.screenshare.read", "rpc.screenshare.write", "rpc.video.read", "rpc.video.write", "rpc.voice.read", "rpc.voice.write", "voice", "webhook.incoming"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["activities.invites.write", "activities.read", "activities.write", "applications.builds.read", "applications.builds.upload", "applications.commands", "applications.commands.permissions.update", "applications.commands.update", "applications.entitlements", "applications.store.update", "bot", "connections", "dm_channels.read", "email", "gdm.join", "guilds", "guilds.join", "guilds.members.read", "identify", "messages.read", "openid", "relationships.read", "rpc", "rpc.activities.write", "rpc.notifications.read", "rpc.screenshare.read", "rpc.screenshare.write", "rpc.video.read", "rpc.video.write", "rpc.voice.read", "rpc.voice.write", "voice", "webhook.incoming"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["activities.invites.write", "activities.read", "activities.write", "applications.builds.read", "applications.builds.upload", "applications.commands", "applications.commands.permissions.update", "applications.entitlements", "applications.store.update", "bot", "connections", "dm_channels.read", "email", "gdm.join", "guilds", "guilds.join", "guilds.members.read", "identify", "messages.read", "openid", "relationships.read", "role_connections.write", "rpc", "rpc.activities.write", "rpc.notifications.read", "rpc.screenshare.read", "rpc.screenshare.write", "rpc.video.read", "rpc.video.write", "rpc.voice.read", "rpc.voice.write", "voice", "webhook.incoming"], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/@me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["identify"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["identify"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["identify"], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenidConnectUserinfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth2/userinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["openid"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["openid"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["openid"], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {string} [threadId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOriginalWebhookMessage: async (webhookId: string, webhookToken: string, threadId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('getOriginalWebhookMessage', 'webhookId', webhookId)
            // verify required parameter 'webhookToken' is not null or undefined
            assertParamExists('getOriginalWebhookMessage', 'webhookToken', webhookToken)
            const localVarPath = `/webhooks/{webhook_id}/{webhook_token}/messages/@original`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
                .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (threadId !== undefined) {
                localVarQueryParameter['thread_id'] = threadId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth2/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSelfVoiceState: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getSelfVoiceState', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/voice-states/@me`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSoundboardDefaultSounds: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/soundboard-default-sounds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStageInstance: async (channelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('getStageInstance', 'channelId', channelId)
            const localVarPath = `/stage-instances/{channel_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} stickerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSticker: async (stickerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stickerId' is not null or undefined
            assertParamExists('getSticker', 'stickerId', stickerId)
            const localVarPath = `/stickers/{sticker_id}`
                .replace(`{${"sticker_id"}}`, encodeURIComponent(String(stickerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} packId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStickerPack: async (packId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packId' is not null or undefined
            assertParamExists('getStickerPack', 'packId', packId)
            const localVarPath = `/sticker-packs/{pack_id}`
                .replace(`{${"pack_id"}}`, encodeURIComponent(String(packId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} userId 
         * @param {boolean} [withMember] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreadMember: async (channelId: string, userId: string, withMember?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('getThreadMember', 'channelId', channelId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getThreadMember', 'userId', userId)
            const localVarPath = `/channels/{channel_id}/thread-members/{user_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (withMember !== undefined) {
                localVarQueryParameter['with_member'] = withMember;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoiceState: async (guildId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('getVoiceState', 'guildId', guildId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getVoiceState', 'userId', userId)
            const localVarPath = `/guilds/{guild_id}/voice-states/{user_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('getWebhook', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookByToken: async (webhookId: string, webhookToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('getWebhookByToken', 'webhookId', webhookId)
            // verify required parameter 'webhookToken' is not null or undefined
            assertParamExists('getWebhookByToken', 'webhookToken', webhookToken)
            const localVarPath = `/webhooks/{webhook_id}/{webhook_token}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
                .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {string} messageId 
         * @param {string} [threadId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookMessage: async (webhookId: string, webhookToken: string, messageId: string, threadId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('getWebhookMessage', 'webhookId', webhookId)
            // verify required parameter 'webhookToken' is not null or undefined
            assertParamExists('getWebhookMessage', 'webhookToken', webhookToken)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('getWebhookMessage', 'messageId', messageId)
            const localVarPath = `/webhooks/{webhook_id}/{webhook_token}/messages/{message_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
                .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (threadId !== undefined) {
                localVarQueryParameter['thread_id'] = threadId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} code 
         * @param {boolean} [withCounts] 
         * @param {string} [guildScheduledEventId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteResolve: async (code: string, withCounts?: boolean, guildScheduledEventId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('inviteResolve', 'code', code)
            const localVarPath = `/invites/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (withCounts !== undefined) {
                localVarQueryParameter['with_counts'] = withCounts;
            }

            if (guildScheduledEventId !== undefined) {
                localVarQueryParameter['guild_scheduled_event_id'] = guildScheduledEventId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteRevoke: async (code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('inviteRevoke', 'code', code)
            const localVarPath = `/invites/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinThread: async (channelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('joinThread', 'channelId', channelId)
            const localVarPath = `/channels/{channel_id}/thread-members/@me`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveGuild: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('leaveGuild', 'guildId', guildId)
            const localVarPath = `/users/@me/guilds/{guild_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveLobby: async (lobbyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lobbyId' is not null or undefined
            assertParamExists('leaveLobby', 'lobbyId', lobbyId)
            const localVarPath = `/lobbies/{lobby_id}/members/@me`
                .replace(`{${"lobby_id"}}`, encodeURIComponent(String(lobbyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveThread: async (channelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('leaveThread', 'channelId', channelId)
            const localVarPath = `/channels/{channel_id}/thread-members/@me`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {boolean} [withLocalizations] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationCommands: async (applicationId: string, withLocalizations?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationCommands', 'applicationId', applicationId)
            const localVarPath = `/applications/{application_id}/commands`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (withLocalizations !== undefined) {
                localVarQueryParameter['with_localizations'] = withLocalizations;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationEmojis: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationEmojis', 'applicationId', applicationId)
            const localVarPath = `/applications/{application_id}/emojis`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAutoModerationRules: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('listAutoModerationRules', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/auto-moderation/rules`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChannelInvites: async (channelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('listChannelInvites', 'channelId', channelId)
            const localVarPath = `/channels/{channel_id}/invites`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChannelWebhooks: async (channelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('listChannelWebhooks', 'channelId', channelId)
            const localVarPath = `/channels/{channel_id}/webhooks`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildApplicationCommandPermissions: async (applicationId: string, guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listGuildApplicationCommandPermissions', 'applicationId', applicationId)
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('listGuildApplicationCommandPermissions', 'guildId', guildId)
            const localVarPath = `/applications/{application_id}/guilds/{guild_id}/commands/permissions`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.permissions.update"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.permissions.update"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.permissions.update"], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {boolean} [withLocalizations] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildApplicationCommands: async (applicationId: string, guildId: string, withLocalizations?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listGuildApplicationCommands', 'applicationId', applicationId)
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('listGuildApplicationCommands', 'guildId', guildId)
            const localVarPath = `/applications/{application_id}/guilds/{guild_id}/commands`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (withLocalizations !== undefined) {
                localVarQueryParameter['with_localizations'] = withLocalizations;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} [userId] 
         * @param {string} [targetId] 
         * @param {number} [actionType] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildAuditLogEntries: async (guildId: string, userId?: string, targetId?: string, actionType?: number, before?: string, after?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('listGuildAuditLogEntries', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/audit-logs`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (targetId !== undefined) {
                localVarQueryParameter['target_id'] = targetId;
            }

            if (actionType !== undefined) {
                localVarQueryParameter['action_type'] = actionType;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {number} [limit] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildBans: async (guildId: string, limit?: number, before?: string, after?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('listGuildBans', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/bans`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildChannels: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('listGuildChannels', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/channels`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildEmojis: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('listGuildEmojis', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/emojis`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildIntegrations: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('listGuildIntegrations', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/integrations`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildInvites: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('listGuildInvites', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/invites`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {number} [limit] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildMembers: async (guildId: string, limit?: number, after?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('listGuildMembers', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/members`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildRoles: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('listGuildRoles', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/roles`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} guildScheduledEventId 
         * @param {boolean} [withMember] 
         * @param {number} [limit] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildScheduledEventUsers: async (guildId: string, guildScheduledEventId: string, withMember?: boolean, limit?: number, before?: string, after?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('listGuildScheduledEventUsers', 'guildId', guildId)
            // verify required parameter 'guildScheduledEventId' is not null or undefined
            assertParamExists('listGuildScheduledEventUsers', 'guildScheduledEventId', guildScheduledEventId)
            const localVarPath = `/guilds/{guild_id}/scheduled-events/{guild_scheduled_event_id}/users`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"guild_scheduled_event_id"}}`, encodeURIComponent(String(guildScheduledEventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (withMember !== undefined) {
                localVarQueryParameter['with_member'] = withMember;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {boolean} [withUserCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildScheduledEvents: async (guildId: string, withUserCount?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('listGuildScheduledEvents', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/scheduled-events`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (withUserCount !== undefined) {
                localVarQueryParameter['with_user_count'] = withUserCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildSoundboardSounds: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('listGuildSoundboardSounds', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/soundboard-sounds`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildStickers: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('listGuildStickers', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/stickers`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildTemplates: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('listGuildTemplates', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/templates`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildVoiceRegions: async (guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('listGuildVoiceRegions', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/regions`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {string} emojiName 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {number} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessageReactionsByEmoji: async (channelId: string, messageId: string, emojiName: string, after?: string, limit?: number, type?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('listMessageReactionsByEmoji', 'channelId', channelId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('listMessageReactionsByEmoji', 'messageId', messageId)
            // verify required parameter 'emojiName' is not null or undefined
            assertParamExists('listMessageReactionsByEmoji', 'emojiName', emojiName)
            const localVarPath = `/channels/{channel_id}/messages/{message_id}/reactions/{emoji_name}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)))
                .replace(`{${"emoji_name"}}`, encodeURIComponent(String(emojiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [around] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessages: async (channelId: string, around?: string, before?: string, after?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('listMessages', 'channelId', channelId)
            const localVarPath = `/channels/{channel_id}/messages`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (around !== undefined) {
                localVarQueryParameter['around'] = around;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyConnections: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/@me/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["connections"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["connections"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["connections"], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {boolean} [withCounts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyGuilds: async (before?: string, after?: string, limit?: number, withCounts?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/@me/guilds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["guilds"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["guilds"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["guilds"], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (withCounts !== undefined) {
                localVarQueryParameter['with_counts'] = withCounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [before] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyPrivateArchivedThreads: async (channelId: string, before?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('listMyPrivateArchivedThreads', 'channelId', channelId)
            const localVarPath = `/channels/{channel_id}/users/@me/threads/archived/private`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [before] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPins: async (channelId: string, before?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('listPins', 'channelId', channelId)
            const localVarPath = `/channels/{channel_id}/messages/pins`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [before] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPrivateArchivedThreads: async (channelId: string, before?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('listPrivateArchivedThreads', 'channelId', channelId)
            const localVarPath = `/channels/{channel_id}/threads/archived/private`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [before] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicArchivedThreads: async (channelId: string, before?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('listPublicArchivedThreads', 'channelId', channelId)
            const localVarPath = `/channels/{channel_id}/threads/archived/public`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStickerPacks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sticker-packs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {boolean} [withMember] 
         * @param {number} [limit] 
         * @param {string} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listThreadMembers: async (channelId: string, withMember?: boolean, limit?: number, after?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('listThreadMembers', 'channelId', channelId)
            const localVarPath = `/channels/{channel_id}/thread-members`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (withMember !== undefined) {
                localVarQueryParameter['with_member'] = withMember;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoiceRegions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/voice/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PartnerSdkUnmergeProvisionalAccountRequest} partnerSdkUnmergeProvisionalAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerSdkToken: async (partnerSdkUnmergeProvisionalAccountRequest: PartnerSdkUnmergeProvisionalAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerSdkUnmergeProvisionalAccountRequest' is not null or undefined
            assertParamExists('partnerSdkToken', 'partnerSdkUnmergeProvisionalAccountRequest', partnerSdkUnmergeProvisionalAccountRequest)
            const localVarPath = `/partner-sdk/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partnerSdkUnmergeProvisionalAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PartnerSdkUnmergeProvisionalAccountRequest} partnerSdkUnmergeProvisionalAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerSdkUnmergeProvisionalAccount: async (partnerSdkUnmergeProvisionalAccountRequest: PartnerSdkUnmergeProvisionalAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerSdkUnmergeProvisionalAccountRequest' is not null or undefined
            assertParamExists('partnerSdkUnmergeProvisionalAccount', 'partnerSdkUnmergeProvisionalAccountRequest', partnerSdkUnmergeProvisionalAccountRequest)
            const localVarPath = `/partner-sdk/provisional-accounts/unmerge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partnerSdkUnmergeProvisionalAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollExpire: async (channelId: string, messageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('pollExpire', 'channelId', channelId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('pollExpire', 'messageId', messageId)
            const localVarPath = `/channels/{channel_id}/polls/{message_id}/expire`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {number} [days] 
         * @param {GetEntitlementsSkuIdsParameter} [includeRoles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewPruneGuild: async (guildId: string, days?: number, includeRoles?: GetEntitlementsSkuIdsParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('previewPruneGuild', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/prune`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }

            if (includeRoles !== undefined) {
                for (const [key, value] of Object.entries(includeRoles)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {PruneGuildRequest} pruneGuildRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pruneGuild: async (guildId: string, pruneGuildRequest: PruneGuildRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('pruneGuild', 'guildId', guildId)
            // verify required parameter 'pruneGuildRequest' is not null or undefined
            assertParamExists('pruneGuild', 'pruneGuildRequest', pruneGuildRequest)
            const localVarPath = `/guilds/{guild_id}/prune`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pruneGuildRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {UpdateGuildOnboardingRequest} updateGuildOnboardingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGuildsOnboarding: async (guildId: string, updateGuildOnboardingRequest: UpdateGuildOnboardingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('putGuildsOnboarding', 'guildId', guildId)
            // verify required parameter 'updateGuildOnboardingRequest' is not null or undefined
            assertParamExists('putGuildsOnboarding', 'updateGuildOnboardingRequest', updateGuildOnboardingRequest)
            const localVarPath = `/guilds/{guild_id}/onboarding`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGuildOnboardingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} limit 
         * @param {string} query 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGuildMembers: async (limit: number, query: string, guildId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('searchGuildMembers', 'limit', limit)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('searchGuildMembers', 'query', query)
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('searchGuildMembers', 'guildId', guildId)
            const localVarPath = `/guilds/{guild_id}/members/search`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {SoundboardSoundSendRequest} soundboardSoundSendRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSoundboardSound: async (channelId: string, soundboardSoundSendRequest: SoundboardSoundSendRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('sendSoundboardSound', 'channelId', channelId)
            // verify required parameter 'soundboardSoundSendRequest' is not null or undefined
            assertParamExists('sendSoundboardSound', 'soundboardSoundSendRequest', soundboardSoundSendRequest)
            const localVarPath = `/channels/{channel_id}/send-soundboard-sound`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(soundboardSoundSendRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} overwriteId 
         * @param {SetChannelPermissionOverwriteRequest} setChannelPermissionOverwriteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelPermissionOverwrite: async (channelId: string, overwriteId: string, setChannelPermissionOverwriteRequest: SetChannelPermissionOverwriteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('setChannelPermissionOverwrite', 'channelId', channelId)
            // verify required parameter 'overwriteId' is not null or undefined
            assertParamExists('setChannelPermissionOverwrite', 'overwriteId', overwriteId)
            // verify required parameter 'setChannelPermissionOverwriteRequest' is not null or undefined
            assertParamExists('setChannelPermissionOverwrite', 'setChannelPermissionOverwriteRequest', setChannelPermissionOverwriteRequest)
            const localVarPath = `/channels/{channel_id}/permissions/{overwrite_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"overwrite_id"}}`, encodeURIComponent(String(overwriteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setChannelPermissionOverwriteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {string} commandId 
         * @param {SetGuildApplicationCommandPermissionsRequest} setGuildApplicationCommandPermissionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGuildApplicationCommandPermissions: async (applicationId: string, guildId: string, commandId: string, setGuildApplicationCommandPermissionsRequest: SetGuildApplicationCommandPermissionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('setGuildApplicationCommandPermissions', 'applicationId', applicationId)
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('setGuildApplicationCommandPermissions', 'guildId', guildId)
            // verify required parameter 'commandId' is not null or undefined
            assertParamExists('setGuildApplicationCommandPermissions', 'commandId', commandId)
            // verify required parameter 'setGuildApplicationCommandPermissionsRequest' is not null or undefined
            assertParamExists('setGuildApplicationCommandPermissions', 'setGuildApplicationCommandPermissionsRequest', setGuildApplicationCommandPermissionsRequest)
            const localVarPath = `/applications/{application_id}/guilds/{guild_id}/commands/{command_id}/permissions`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"command_id"}}`, encodeURIComponent(String(commandId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.permissions.update"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.permissions.update"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.permissions.update"], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setGuildApplicationCommandPermissionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {SetGuildMfaLevelRequest} setGuildMfaLevelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGuildMfaLevel: async (guildId: string, setGuildMfaLevelRequest: SetGuildMfaLevelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('setGuildMfaLevel', 'guildId', guildId)
            // verify required parameter 'setGuildMfaLevelRequest' is not null or undefined
            assertParamExists('setGuildMfaLevel', 'setGuildMfaLevelRequest', setGuildMfaLevelRequest)
            const localVarPath = `/guilds/{guild_id}/mfa`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setGuildMfaLevelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncGuildTemplate: async (guildId: string, code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('syncGuildTemplate', 'guildId', guildId)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('syncGuildTemplate', 'code', code)
            const localVarPath = `/guilds/{guild_id}/templates/{code}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [name] 
         * @param {number} [slop] 
         * @param {string} [minId] 
         * @param {string} [maxId] 
         * @param {ThreadSearchTagParameter} [tag] 
         * @param {string} [tagSetting] 
         * @param {boolean} [archived] 
         * @param {string | null} [sortBy] 
         * @param {string | null} [sortOrder] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadSearch: async (channelId: string, name?: string, slop?: number, minId?: string, maxId?: string, tag?: ThreadSearchTagParameter, tagSetting?: string, archived?: boolean, sortBy?: string | null, sortOrder?: string | null, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('threadSearch', 'channelId', channelId)
            const localVarPath = `/channels/{channel_id}/threads/search`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slop !== undefined) {
                localVarQueryParameter['slop'] = slop;
            }

            if (minId !== undefined) {
                localVarQueryParameter['min_id'] = minId;
            }

            if (maxId !== undefined) {
                localVarQueryParameter['max_id'] = maxId;
            }

            if (tag !== undefined) {
                for (const [key, value] of Object.entries(tag)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (tagSetting !== undefined) {
                localVarQueryParameter['tag_setting'] = tagSetting;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerTypingIndicator: async (channelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('triggerTypingIndicator', 'channelId', channelId)
            const localVarPath = `/channels/{channel_id}/typing`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbanUserFromGuild: async (guildId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('unbanUserFromGuild', 'guildId', guildId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('unbanUserFromGuild', 'userId', userId)
            const localVarPath = `/guilds/{guild_id}/bans/{user_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {ApplicationFormPartial} applicationFormPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication: async (applicationId: string, applicationFormPartial: ApplicationFormPartial, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('updateApplication', 'applicationId', applicationId)
            // verify required parameter 'applicationFormPartial' is not null or undefined
            assertParamExists('updateApplication', 'applicationFormPartial', applicationFormPartial)
            const localVarPath = `/applications/{application_id}`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationFormPartial, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} commandId 
         * @param {ApplicationCommandPatchRequestPartial} applicationCommandPatchRequestPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationCommand: async (applicationId: string, commandId: string, applicationCommandPatchRequestPartial: ApplicationCommandPatchRequestPartial, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('updateApplicationCommand', 'applicationId', applicationId)
            // verify required parameter 'commandId' is not null or undefined
            assertParamExists('updateApplicationCommand', 'commandId', commandId)
            // verify required parameter 'applicationCommandPatchRequestPartial' is not null or undefined
            assertParamExists('updateApplicationCommand', 'applicationCommandPatchRequestPartial', applicationCommandPatchRequestPartial)
            const localVarPath = `/applications/{application_id}/commands/{command_id}`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"command_id"}}`, encodeURIComponent(String(commandId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationCommandPatchRequestPartial, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} emojiId 
         * @param {UpdateApplicationEmojiRequest} updateApplicationEmojiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationEmoji: async (applicationId: string, emojiId: string, updateApplicationEmojiRequest: UpdateApplicationEmojiRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('updateApplicationEmoji', 'applicationId', applicationId)
            // verify required parameter 'emojiId' is not null or undefined
            assertParamExists('updateApplicationEmoji', 'emojiId', emojiId)
            // verify required parameter 'updateApplicationEmojiRequest' is not null or undefined
            assertParamExists('updateApplicationEmoji', 'updateApplicationEmojiRequest', updateApplicationEmojiRequest)
            const localVarPath = `/applications/{application_id}/emojis/{emoji_id}`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"emoji_id"}}`, encodeURIComponent(String(emojiId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateApplicationEmojiRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {Array<ApplicationRoleConnectionsMetadataItemRequest> | null} applicationRoleConnectionsMetadataItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationRoleConnectionsMetadata: async (applicationId: string, applicationRoleConnectionsMetadataItemRequest: Array<ApplicationRoleConnectionsMetadataItemRequest> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('updateApplicationRoleConnectionsMetadata', 'applicationId', applicationId)
            // verify required parameter 'applicationRoleConnectionsMetadataItemRequest' is not null or undefined
            assertParamExists('updateApplicationRoleConnectionsMetadata', 'applicationRoleConnectionsMetadataItemRequest', applicationRoleConnectionsMetadataItemRequest)
            const localVarPath = `/applications/{application_id}/role-connections/metadata`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationRoleConnectionsMetadataItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {UpdateApplicationUserRoleConnectionRequest} updateApplicationUserRoleConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationUserRoleConnection: async (applicationId: string, updateApplicationUserRoleConnectionRequest: UpdateApplicationUserRoleConnectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('updateApplicationUserRoleConnection', 'applicationId', applicationId)
            // verify required parameter 'updateApplicationUserRoleConnectionRequest' is not null or undefined
            assertParamExists('updateApplicationUserRoleConnection', 'updateApplicationUserRoleConnectionRequest', updateApplicationUserRoleConnectionRequest)
            const localVarPath = `/users/@me/applications/{application_id}/role-connection`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["role_connections.write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateApplicationUserRoleConnectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} ruleId 
         * @param {UpdateAutoModerationRuleRequest} updateAutoModerationRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutoModerationRule: async (guildId: string, ruleId: string, updateAutoModerationRuleRequest: UpdateAutoModerationRuleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('updateAutoModerationRule', 'guildId', guildId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('updateAutoModerationRule', 'ruleId', ruleId)
            // verify required parameter 'updateAutoModerationRuleRequest' is not null or undefined
            assertParamExists('updateAutoModerationRule', 'updateAutoModerationRuleRequest', updateAutoModerationRuleRequest)
            const localVarPath = `/guilds/{guild_id}/auto-moderation/rules/{rule_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAutoModerationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {UpdateChannelRequest} updateChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChannel: async (channelId: string, updateChannelRequest: UpdateChannelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('updateChannel', 'channelId', channelId)
            // verify required parameter 'updateChannelRequest' is not null or undefined
            assertParamExists('updateChannel', 'updateChannelRequest', updateChannelRequest)
            const localVarPath = `/channels/{channel_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateChannelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {GuildPatchRequestPartial} guildPatchRequestPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuild: async (guildId: string, guildPatchRequestPartial: GuildPatchRequestPartial, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('updateGuild', 'guildId', guildId)
            // verify required parameter 'guildPatchRequestPartial' is not null or undefined
            assertParamExists('updateGuild', 'guildPatchRequestPartial', guildPatchRequestPartial)
            const localVarPath = `/guilds/{guild_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(guildPatchRequestPartial, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {string} commandId 
         * @param {ApplicationCommandPatchRequestPartial} applicationCommandPatchRequestPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildApplicationCommand: async (applicationId: string, guildId: string, commandId: string, applicationCommandPatchRequestPartial: ApplicationCommandPatchRequestPartial, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('updateGuildApplicationCommand', 'applicationId', applicationId)
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('updateGuildApplicationCommand', 'guildId', guildId)
            // verify required parameter 'commandId' is not null or undefined
            assertParamExists('updateGuildApplicationCommand', 'commandId', commandId)
            // verify required parameter 'applicationCommandPatchRequestPartial' is not null or undefined
            assertParamExists('updateGuildApplicationCommand', 'applicationCommandPatchRequestPartial', applicationCommandPatchRequestPartial)
            const localVarPath = `/applications/{application_id}/guilds/{guild_id}/commands/{command_id}`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"command_id"}}`, encodeURIComponent(String(commandId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationCommandPatchRequestPartial, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} emojiId 
         * @param {UpdateGuildEmojiRequest} updateGuildEmojiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildEmoji: async (guildId: string, emojiId: string, updateGuildEmojiRequest: UpdateGuildEmojiRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('updateGuildEmoji', 'guildId', guildId)
            // verify required parameter 'emojiId' is not null or undefined
            assertParamExists('updateGuildEmoji', 'emojiId', emojiId)
            // verify required parameter 'updateGuildEmojiRequest' is not null or undefined
            assertParamExists('updateGuildEmoji', 'updateGuildEmojiRequest', updateGuildEmojiRequest)
            const localVarPath = `/guilds/{guild_id}/emojis/{emoji_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"emoji_id"}}`, encodeURIComponent(String(emojiId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGuildEmojiRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {UpdateGuildMemberRequest} updateGuildMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildMember: async (guildId: string, userId: string, updateGuildMemberRequest: UpdateGuildMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('updateGuildMember', 'guildId', guildId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateGuildMember', 'userId', userId)
            // verify required parameter 'updateGuildMemberRequest' is not null or undefined
            assertParamExists('updateGuildMember', 'updateGuildMemberRequest', updateGuildMemberRequest)
            const localVarPath = `/guilds/{guild_id}/members/{user_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGuildMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} roleId 
         * @param {CreateGuildRoleRequest} createGuildRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildRole: async (guildId: string, roleId: string, createGuildRoleRequest: CreateGuildRoleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('updateGuildRole', 'guildId', guildId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('updateGuildRole', 'roleId', roleId)
            // verify required parameter 'createGuildRoleRequest' is not null or undefined
            assertParamExists('updateGuildRole', 'createGuildRoleRequest', createGuildRoleRequest)
            const localVarPath = `/guilds/{guild_id}/roles/{role_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGuildRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} guildScheduledEventId 
         * @param {UpdateGuildScheduledEventRequest} updateGuildScheduledEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildScheduledEvent: async (guildId: string, guildScheduledEventId: string, updateGuildScheduledEventRequest: UpdateGuildScheduledEventRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('updateGuildScheduledEvent', 'guildId', guildId)
            // verify required parameter 'guildScheduledEventId' is not null or undefined
            assertParamExists('updateGuildScheduledEvent', 'guildScheduledEventId', guildScheduledEventId)
            // verify required parameter 'updateGuildScheduledEventRequest' is not null or undefined
            assertParamExists('updateGuildScheduledEvent', 'updateGuildScheduledEventRequest', updateGuildScheduledEventRequest)
            const localVarPath = `/guilds/{guild_id}/scheduled-events/{guild_scheduled_event_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"guild_scheduled_event_id"}}`, encodeURIComponent(String(guildScheduledEventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGuildScheduledEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} soundId 
         * @param {SoundboardPatchRequestPartial} soundboardPatchRequestPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildSoundboardSound: async (guildId: string, soundId: string, soundboardPatchRequestPartial: SoundboardPatchRequestPartial, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('updateGuildSoundboardSound', 'guildId', guildId)
            // verify required parameter 'soundId' is not null or undefined
            assertParamExists('updateGuildSoundboardSound', 'soundId', soundId)
            // verify required parameter 'soundboardPatchRequestPartial' is not null or undefined
            assertParamExists('updateGuildSoundboardSound', 'soundboardPatchRequestPartial', soundboardPatchRequestPartial)
            const localVarPath = `/guilds/{guild_id}/soundboard-sounds/{sound_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"sound_id"}}`, encodeURIComponent(String(soundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(soundboardPatchRequestPartial, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} stickerId 
         * @param {UpdateGuildStickerRequest} updateGuildStickerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildSticker: async (guildId: string, stickerId: string, updateGuildStickerRequest: UpdateGuildStickerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('updateGuildSticker', 'guildId', guildId)
            // verify required parameter 'stickerId' is not null or undefined
            assertParamExists('updateGuildSticker', 'stickerId', stickerId)
            // verify required parameter 'updateGuildStickerRequest' is not null or undefined
            assertParamExists('updateGuildSticker', 'updateGuildStickerRequest', updateGuildStickerRequest)
            const localVarPath = `/guilds/{guild_id}/stickers/{sticker_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"sticker_id"}}`, encodeURIComponent(String(stickerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGuildStickerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} code 
         * @param {UpdateGuildTemplateRequest} updateGuildTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildTemplate: async (guildId: string, code: string, updateGuildTemplateRequest: UpdateGuildTemplateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('updateGuildTemplate', 'guildId', guildId)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('updateGuildTemplate', 'code', code)
            // verify required parameter 'updateGuildTemplateRequest' is not null or undefined
            assertParamExists('updateGuildTemplate', 'updateGuildTemplateRequest', updateGuildTemplateRequest)
            const localVarPath = `/guilds/{guild_id}/templates/{code}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGuildTemplateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {WelcomeScreenPatchRequestPartial} welcomeScreenPatchRequestPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildWelcomeScreen: async (guildId: string, welcomeScreenPatchRequestPartial: WelcomeScreenPatchRequestPartial, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('updateGuildWelcomeScreen', 'guildId', guildId)
            // verify required parameter 'welcomeScreenPatchRequestPartial' is not null or undefined
            assertParamExists('updateGuildWelcomeScreen', 'welcomeScreenPatchRequestPartial', welcomeScreenPatchRequestPartial)
            const localVarPath = `/guilds/{guild_id}/welcome-screen`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(welcomeScreenPatchRequestPartial, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {UpdateGuildWidgetSettingsRequest} updateGuildWidgetSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildWidgetSettings: async (guildId: string, updateGuildWidgetSettingsRequest: UpdateGuildWidgetSettingsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('updateGuildWidgetSettings', 'guildId', guildId)
            // verify required parameter 'updateGuildWidgetSettingsRequest' is not null or undefined
            assertParamExists('updateGuildWidgetSettings', 'updateGuildWidgetSettingsRequest', updateGuildWidgetSettingsRequest)
            const localVarPath = `/guilds/{guild_id}/widget`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGuildWidgetSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {MessageEditRequestPartial} messageEditRequestPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessage: async (channelId: string, messageId: string, messageEditRequestPartial: MessageEditRequestPartial, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('updateMessage', 'channelId', channelId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('updateMessage', 'messageId', messageId)
            // verify required parameter 'messageEditRequestPartial' is not null or undefined
            assertParamExists('updateMessage', 'messageEditRequestPartial', messageEditRequestPartial)
            const localVarPath = `/channels/{channel_id}/messages/{message_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messageEditRequestPartial, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApplicationFormPartial} applicationFormPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyApplication: async (applicationFormPartial: ApplicationFormPartial, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationFormPartial' is not null or undefined
            assertParamExists('updateMyApplication', 'applicationFormPartial', applicationFormPartial)
            const localVarPath = `/applications/@me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationFormPartial, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {UpdateMyGuildMemberRequest} updateMyGuildMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyGuildMember: async (guildId: string, updateMyGuildMemberRequest: UpdateMyGuildMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('updateMyGuildMember', 'guildId', guildId)
            // verify required parameter 'updateMyGuildMemberRequest' is not null or undefined
            assertParamExists('updateMyGuildMember', 'updateMyGuildMemberRequest', updateMyGuildMemberRequest)
            const localVarPath = `/guilds/{guild_id}/members/@me`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMyGuildMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BotAccountPatchRequest} botAccountPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyUser: async (botAccountPatchRequest: BotAccountPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botAccountPatchRequest' is not null or undefined
            assertParamExists('updateMyUser', 'botAccountPatchRequest', botAccountPatchRequest)
            const localVarPath = `/users/@me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botAccountPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {IncomingWebhookUpdateRequestPartial} incomingWebhookUpdateRequestPartial 
         * @param {string} [threadId] 
         * @param {boolean} [withComponents] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOriginalWebhookMessage: async (webhookId: string, webhookToken: string, incomingWebhookUpdateRequestPartial: IncomingWebhookUpdateRequestPartial, threadId?: string, withComponents?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateOriginalWebhookMessage', 'webhookId', webhookId)
            // verify required parameter 'webhookToken' is not null or undefined
            assertParamExists('updateOriginalWebhookMessage', 'webhookToken', webhookToken)
            // verify required parameter 'incomingWebhookUpdateRequestPartial' is not null or undefined
            assertParamExists('updateOriginalWebhookMessage', 'incomingWebhookUpdateRequestPartial', incomingWebhookUpdateRequestPartial)
            const localVarPath = `/webhooks/{webhook_id}/{webhook_token}/messages/@original`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
                .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (threadId !== undefined) {
                localVarQueryParameter['thread_id'] = threadId;
            }

            if (withComponents !== undefined) {
                localVarQueryParameter['with_components'] = withComponents;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(incomingWebhookUpdateRequestPartial, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {UpdateSelfVoiceStateRequest} updateSelfVoiceStateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSelfVoiceState: async (guildId: string, updateSelfVoiceStateRequest: UpdateSelfVoiceStateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('updateSelfVoiceState', 'guildId', guildId)
            // verify required parameter 'updateSelfVoiceStateRequest' is not null or undefined
            assertParamExists('updateSelfVoiceState', 'updateSelfVoiceStateRequest', updateSelfVoiceStateRequest)
            const localVarPath = `/guilds/{guild_id}/voice-states/@me`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSelfVoiceStateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {UpdateStageInstanceRequest} updateStageInstanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStageInstance: async (channelId: string, updateStageInstanceRequest: UpdateStageInstanceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('updateStageInstance', 'channelId', channelId)
            // verify required parameter 'updateStageInstanceRequest' is not null or undefined
            assertParamExists('updateStageInstance', 'updateStageInstanceRequest', updateStageInstanceRequest)
            const localVarPath = `/stage-instances/{channel_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStageInstanceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {UpdateVoiceStateRequest} updateVoiceStateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoiceState: async (guildId: string, userId: string, updateVoiceStateRequest: UpdateVoiceStateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('updateVoiceState', 'guildId', guildId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateVoiceState', 'userId', userId)
            // verify required parameter 'updateVoiceStateRequest' is not null or undefined
            assertParamExists('updateVoiceState', 'updateVoiceStateRequest', updateVoiceStateRequest)
            const localVarPath = `/guilds/{guild_id}/voice-states/{user_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVoiceStateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {UpdateWebhookRequest} updateWebhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (webhookId: string, updateWebhookRequest: UpdateWebhookRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateWebhook', 'webhookId', webhookId)
            // verify required parameter 'updateWebhookRequest' is not null or undefined
            assertParamExists('updateWebhook', 'updateWebhookRequest', updateWebhookRequest)
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {UpdateWebhookByTokenRequest} updateWebhookByTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookByToken: async (webhookId: string, webhookToken: string, updateWebhookByTokenRequest: UpdateWebhookByTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateWebhookByToken', 'webhookId', webhookId)
            // verify required parameter 'webhookToken' is not null or undefined
            assertParamExists('updateWebhookByToken', 'webhookToken', webhookToken)
            // verify required parameter 'updateWebhookByTokenRequest' is not null or undefined
            assertParamExists('updateWebhookByToken', 'updateWebhookByTokenRequest', updateWebhookByTokenRequest)
            const localVarPath = `/webhooks/{webhook_id}/{webhook_token}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
                .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWebhookByTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {string} messageId 
         * @param {IncomingWebhookUpdateRequestPartial} incomingWebhookUpdateRequestPartial 
         * @param {string} [threadId] 
         * @param {boolean} [withComponents] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookMessage: async (webhookId: string, webhookToken: string, messageId: string, incomingWebhookUpdateRequestPartial: IncomingWebhookUpdateRequestPartial, threadId?: string, withComponents?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateWebhookMessage', 'webhookId', webhookId)
            // verify required parameter 'webhookToken' is not null or undefined
            assertParamExists('updateWebhookMessage', 'webhookToken', webhookToken)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('updateWebhookMessage', 'messageId', messageId)
            // verify required parameter 'incomingWebhookUpdateRequestPartial' is not null or undefined
            assertParamExists('updateWebhookMessage', 'incomingWebhookUpdateRequestPartial', incomingWebhookUpdateRequestPartial)
            const localVarPath = `/webhooks/{webhook_id}/{webhook_token}/messages/{message_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
                .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (threadId !== undefined) {
                localVarQueryParameter['thread_id'] = threadId;
            }

            if (withComponents !== undefined) {
                localVarQueryParameter['with_components'] = withComponents;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(incomingWebhookUpdateRequestPartial, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadApplicationAttachment: async (applicationId: string, file: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('uploadApplicationAttachment', 'applicationId', applicationId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadApplicationAttachment', 'file', file)
            const localVarPath = `/applications/{application_id}/attachment`
                .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["activities.invites.write", "activities.read", "activities.write", "applications.builds.read", "applications.builds.upload", "applications.commands", "applications.commands.permissions.update", "applications.entitlements", "applications.store.update", "bot", "connections", "dm_channels.read", "email", "gdm.join", "guilds", "guilds.join", "guilds.members.read", "identify", "messages.read", "openid", "relationships.read", "rpc", "rpc.activities.write", "rpc.notifications.read", "rpc.screenshare.read", "rpc.screenshare.write", "rpc.video.read", "rpc.video.write", "rpc.voice.read", "rpc.voice.write", "voice", "webhook.incoming"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["activities.invites.write", "activities.read", "activities.write", "applications.builds.read", "applications.builds.upload", "applications.commands", "applications.commands.permissions.update", "applications.commands.update", "applications.entitlements", "applications.store.update", "bot", "connections", "dm_channels.read", "email", "gdm.join", "guilds", "guilds.join", "guilds.members.read", "identify", "messages.read", "openid", "relationships.read", "rpc", "rpc.activities.write", "rpc.notifications.read", "rpc.screenshare.read", "rpc.screenshare.write", "rpc.video.read", "rpc.video.write", "rpc.voice.read", "rpc.voice.write", "voice", "webhook.incoming"], configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["activities.invites.write", "activities.read", "activities.write", "applications.builds.read", "applications.builds.upload", "applications.commands", "applications.commands.permissions.update", "applications.entitlements", "applications.store.update", "bot", "connections", "dm_channels.read", "email", "gdm.join", "guilds", "guilds.join", "guilds.members.read", "identify", "messages.read", "openid", "relationships.read", "role_connections.write", "rpc", "rpc.activities.write", "rpc.notifications.read", "rpc.screenshare.read", "rpc.screenshare.write", "rpc.video.read", "rpc.video.write", "rpc.voice.read", "rpc.voice.write", "voice", "webhook.incoming"], configuration)

            // authentication BotToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} channelId 
         * @param {string} userId 
         * @param {AddGroupDmUserRequest} addGroupDmUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addGroupDmUser(channelId: string, userId: string, addGroupDmUserRequest: AddGroupDmUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddGroupDmUser201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addGroupDmUser(channelId, userId, addGroupDmUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.addGroupDmUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {AddGuildMemberRequest} addGuildMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addGuildMember(guildId: string, userId: string, addGuildMemberRequest: AddGuildMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildMemberResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addGuildMember(guildId, userId, addGuildMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.addGuildMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addGuildMemberRole(guildId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addGuildMemberRole(guildId, userId, roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.addGuildMemberRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {string} userId 
         * @param {AddLobbyMemberRequest} addLobbyMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addLobbyMember(lobbyId: string, userId: string, addLobbyMemberRequest: AddLobbyMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LobbyMemberResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addLobbyMember(lobbyId, userId, addLobbyMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.addLobbyMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {string} emojiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMyMessageReaction(channelId: string, messageId: string, emojiName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMyMessageReaction(channelId, messageId, emojiName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.addMyMessageReaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addThreadMember(channelId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addThreadMember(channelId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.addThreadMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applicationsGetActivityInstance(applicationId: string, instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmbeddedActivityInstance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.applicationsGetActivityInstance(applicationId, instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.applicationsGetActivityInstance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {BanUserFromGuildRequest} banUserFromGuildRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async banUserFromGuild(guildId: string, userId: string, banUserFromGuildRequest: BanUserFromGuildRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.banUserFromGuild(guildId, userId, banUserFromGuildRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.banUserFromGuild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {BulkBanUsersFromGuildRequest} bulkBanUsersFromGuildRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkBanUsersFromGuild(guildId: string, bulkBanUsersFromGuildRequest: BulkBanUsersFromGuildRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkBanUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkBanUsersFromGuild(guildId, bulkBanUsersFromGuildRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.bulkBanUsersFromGuild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {BulkDeleteMessagesRequest} bulkDeleteMessagesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkDeleteMessages(channelId: string, bulkDeleteMessagesRequest: BulkDeleteMessagesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDeleteMessages(channelId, bulkDeleteMessagesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.bulkDeleteMessages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {Array<ApplicationCommandUpdateRequest> | null} applicationCommandUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkSetApplicationCommands(applicationId: string, applicationCommandUpdateRequest: Array<ApplicationCommandUpdateRequest> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationCommandResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkSetApplicationCommands(applicationId, applicationCommandUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.bulkSetApplicationCommands']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {Array<ApplicationCommandUpdateRequest> | null} applicationCommandUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkSetGuildApplicationCommands(applicationId: string, guildId: string, applicationCommandUpdateRequest: Array<ApplicationCommandUpdateRequest> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationCommandResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkSetGuildApplicationCommands(applicationId, guildId, applicationCommandUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.bulkSetGuildApplicationCommands']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {Array<BulkUpdateGuildChannelsRequestInner>} bulkUpdateGuildChannelsRequestInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkUpdateGuildChannels(guildId: string, bulkUpdateGuildChannelsRequestInner: Array<BulkUpdateGuildChannelsRequestInner>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUpdateGuildChannels(guildId, bulkUpdateGuildChannelsRequestInner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.bulkUpdateGuildChannels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {Array<BulkUpdateGuildRolesRequestInner>} bulkUpdateGuildRolesRequestInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkUpdateGuildRoles(guildId: string, bulkUpdateGuildRolesRequestInner: Array<BulkUpdateGuildRolesRequestInner>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuildRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUpdateGuildRoles(guildId, bulkUpdateGuildRolesRequestInner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.bulkUpdateGuildRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {Array<BulkLobbyMemberRequest> | null} bulkLobbyMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkUpdateLobbyMembers(lobbyId: string, bulkLobbyMemberRequest: Array<BulkLobbyMemberRequest> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LobbyMemberResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUpdateLobbyMembers(lobbyId, bulkLobbyMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.bulkUpdateLobbyMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} entitlementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumeEntitlement(applicationId: string, entitlementId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumeEntitlement(applicationId, entitlementId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.consumeEntitlement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {ApplicationCommandCreateRequest} applicationCommandCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationCommand(applicationId: string, applicationCommandCreateRequest: ApplicationCommandCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationCommandResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationCommand(applicationId, applicationCommandCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createApplicationCommand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {CreateApplicationEmojiRequest} createApplicationEmojiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationEmoji(applicationId: string, createApplicationEmojiRequest: CreateApplicationEmojiRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmojiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationEmoji(applicationId, createApplicationEmojiRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createApplicationEmoji']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {CreateAutoModerationRuleRequest} createAutoModerationRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAutoModerationRule(guildId: string, createAutoModerationRuleRequest: CreateAutoModerationRuleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAutoModerationRule200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAutoModerationRule(guildId, createAutoModerationRuleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createAutoModerationRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {CreateChannelInviteRequest} createChannelInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChannelInvite(channelId: string, createChannelInviteRequest: CreateChannelInviteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListChannelInvites200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChannelInvite(channelId, createChannelInviteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createChannelInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreatePrivateChannelRequest} createPrivateChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDm(createPrivateChannelRequest: CreatePrivateChannelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddGroupDmUser201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDm(createPrivateChannelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createDm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {CreateEntitlementRequestData} createEntitlementRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntitlement(applicationId: string, createEntitlementRequestData: CreateEntitlementRequestData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntitlementResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntitlement(applicationId, createEntitlementRequestData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createEntitlement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GuildCreateRequest} guildCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGuild(guildCreateRequest: GuildCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGuild(guildCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createGuild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {ApplicationCommandCreateRequest} applicationCommandCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGuildApplicationCommand(applicationId: string, guildId: string, applicationCommandCreateRequest: ApplicationCommandCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationCommandResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGuildApplicationCommand(applicationId, guildId, applicationCommandCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createGuildApplicationCommand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {CreateGuildChannelRequest} createGuildChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGuildChannel(guildId: string, createGuildChannelRequest: CreateGuildChannelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildChannelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGuildChannel(guildId, createGuildChannelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createGuildChannel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {CreateGuildEmojiRequest} createGuildEmojiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGuildEmoji(guildId: string, createGuildEmojiRequest: CreateGuildEmojiRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmojiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGuildEmoji(guildId, createGuildEmojiRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createGuildEmoji']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} code 
         * @param {CreateGuildFromTemplateRequest} createGuildFromTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGuildFromTemplate(code: string, createGuildFromTemplateRequest: CreateGuildFromTemplateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGuildFromTemplate(code, createGuildFromTemplateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createGuildFromTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {CreateGuildRoleRequest} createGuildRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGuildRole(guildId: string, createGuildRoleRequest: CreateGuildRoleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGuildRole(guildId, createGuildRoleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createGuildRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {CreateGuildScheduledEventRequest} createGuildScheduledEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGuildScheduledEvent(guildId: string, createGuildScheduledEventRequest: CreateGuildScheduledEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListGuildScheduledEvents200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGuildScheduledEvent(guildId, createGuildScheduledEventRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createGuildScheduledEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {SoundboardCreateRequest} soundboardCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGuildSoundboardSound(guildId: string, soundboardCreateRequest: SoundboardCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SoundboardSoundResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGuildSoundboardSound(guildId, soundboardCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createGuildSoundboardSound']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} name 
         * @param {string} tags 
         * @param {string} file 
         * @param {string | null} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGuildSticker(guildId: string, name: string, tags: string, file: string, description?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildStickerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGuildSticker(guildId, name, tags, file, description, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createGuildSticker']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {CreateGuildTemplateRequest} createGuildTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGuildTemplate(guildId: string, createGuildTemplateRequest: CreateGuildTemplateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGuildTemplate(guildId, createGuildTemplateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createGuildTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} interactionId 
         * @param {string} interactionToken 
         * @param {CreateInteractionResponseRequest} createInteractionResponseRequest 
         * @param {boolean} [withResponse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInteractionResponse(interactionId: string, interactionToken: string, createInteractionResponseRequest: CreateInteractionResponseRequest, withResponse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InteractionCallbackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInteractionResponse(interactionId, interactionToken, createInteractionResponseRequest, withResponse, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createInteractionResponse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateLobbyRequest} createLobbyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLobby(createLobbyRequest: CreateLobbyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LobbyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLobby(createLobbyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createLobby']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {SDKMessageRequest} sDKMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLobbyMessage(lobbyId: string, sDKMessageRequest: SDKMessageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LobbyMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLobbyMessage(lobbyId, sDKMessageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createLobbyMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {MessageCreateRequest} messageCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMessage(channelId: string, messageCreateRequest: MessageCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMessage(channelId, messageCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateOrJoinLobbyRequest} createOrJoinLobbyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrJoinLobby(createOrJoinLobbyRequest: CreateOrJoinLobbyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LobbyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrJoinLobby(createOrJoinLobbyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createOrJoinLobby']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPin(channelId: string, messageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPin(channelId, messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createPin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateStageInstanceRequest} createStageInstanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStageInstance(createStageInstanceRequest: CreateStageInstanceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StageInstanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStageInstance(createStageInstanceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createStageInstance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {CreateThreadRequest} createThreadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createThread(channelId: string, createThreadRequest: CreateThreadRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedThreadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createThread(channelId, createThreadRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createThread']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {CreateTextThreadWithMessageRequest} createTextThreadWithMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createThreadFromMessage(channelId: string, messageId: string, createTextThreadWithMessageRequest: CreateTextThreadWithMessageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createThreadFromMessage(channelId, messageId, createTextThreadWithMessageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createThreadFromMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {CreateWebhookRequest} createWebhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebhook(channelId: string, createWebhookRequest: CreateWebhookRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildIncomingWebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(channelId, createWebhookRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crosspostMessage(channelId: string, messageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crosspostMessage(channelId, messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.crosspostMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllMessageReactions(channelId: string, messageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllMessageReactions(channelId, messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteAllMessageReactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {string} emojiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllMessageReactionsByEmoji(channelId: string, messageId: string, emojiName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllMessageReactionsByEmoji(channelId, messageId, emojiName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteAllMessageReactionsByEmoji']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} commandId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationCommand(applicationId: string, commandId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationCommand(applicationId, commandId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteApplicationCommand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} emojiId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationEmoji(applicationId: string, emojiId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationEmoji(applicationId, emojiId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteApplicationEmoji']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationUserRoleConnection(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationUserRoleConnection(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteApplicationUserRoleConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} ruleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAutoModerationRule(guildId: string, ruleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAutoModerationRule(guildId, ruleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteAutoModerationRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChannel(channelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChannel200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChannel(channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteChannel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} overwriteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChannelPermissionOverwrite(channelId: string, overwriteId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChannelPermissionOverwrite(channelId, overwriteId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteChannelPermissionOverwrite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} entitlementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntitlement(applicationId: string, entitlementId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntitlement(applicationId, entitlementId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteEntitlement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupDmUser(channelId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupDmUser(channelId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteGroupDmUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGuild(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuild(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteGuild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {string} commandId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGuildApplicationCommand(applicationId: string, guildId: string, commandId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuildApplicationCommand(applicationId, guildId, commandId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteGuildApplicationCommand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} emojiId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGuildEmoji(guildId: string, emojiId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuildEmoji(guildId, emojiId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteGuildEmoji']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} integrationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGuildIntegration(guildId: string, integrationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuildIntegration(guildId, integrationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteGuildIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGuildMember(guildId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuildMember(guildId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteGuildMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGuildMemberRole(guildId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuildMemberRole(guildId, userId, roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteGuildMemberRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGuildRole(guildId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuildRole(guildId, roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteGuildRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} guildScheduledEventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGuildScheduledEvent(guildId: string, guildScheduledEventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuildScheduledEvent(guildId, guildScheduledEventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteGuildScheduledEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} soundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGuildSoundboardSound(guildId: string, soundId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuildSoundboardSound(guildId, soundId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteGuildSoundboardSound']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} stickerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGuildSticker(guildId: string, stickerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuildSticker(guildId, stickerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteGuildSticker']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGuildTemplate(guildId: string, code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuildTemplate(guildId, code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteGuildTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLobbyMember(lobbyId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLobbyMember(lobbyId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteLobbyMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMessage(channelId: string, messageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessage(channelId, messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {string} emojiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMyMessageReaction(channelId: string, messageId: string, emojiName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMyMessageReaction(channelId, messageId, emojiName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteMyMessageReaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {string} [threadId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOriginalWebhookMessage(webhookId: string, webhookToken: string, threadId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOriginalWebhookMessage(webhookId, webhookToken, threadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteOriginalWebhookMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePin(channelId: string, messageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePin(channelId, messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deletePin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStageInstance(channelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStageInstance(channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteStageInstance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteThreadMember(channelId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteThreadMember(channelId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteThreadMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {string} emojiName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserMessageReaction(channelId: string, messageId: string, emojiName: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserMessageReaction(channelId, messageId, emojiName, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteUserMessageReaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhookByToken(webhookId: string, webhookToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhookByToken(webhookId, webhookToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteWebhookByToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {string} messageId 
         * @param {string} [threadId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhookMessage(webhookId: string, webhookToken: string, messageId: string, threadId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhookMessage(webhookId, webhookToken, messageId, threadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteWebhookMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deprecatedCreatePin(channelId: string, messageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deprecatedCreatePin(channelId, messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deprecatedCreatePin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deprecatedDeletePin(channelId: string, messageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deprecatedDeletePin(channelId, messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deprecatedDeletePin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deprecatedListPins(channelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deprecatedListPins(channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deprecatedListPins']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {CreateLobbyRequest} createLobbyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editLobby(lobbyId: string, createLobbyRequest: CreateLobbyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LobbyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editLobby(lobbyId, createLobbyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.editLobby']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {EditLobbyChannelLinkRequest} editLobbyChannelLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editLobbyChannelLink(lobbyId: string, editLobbyChannelLinkRequest: EditLobbyChannelLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LobbyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editLobbyChannelLink(lobbyId, editLobbyChannelLinkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.editLobbyChannelLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {GithubWebhook} githubWebhook 
         * @param {boolean} [wait] 
         * @param {string} [threadId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeGithubCompatibleWebhook(webhookId: string, webhookToken: string, githubWebhook: GithubWebhook, wait?: boolean, threadId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeGithubCompatibleWebhook(webhookId, webhookToken, githubWebhook, wait, threadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.executeGithubCompatibleWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {SlackWebhook} slackWebhook 
         * @param {boolean} [wait] 
         * @param {string} [threadId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSlackCompatibleWebhook(webhookId: string, webhookToken: string, slackWebhook: SlackWebhook, wait?: boolean, threadId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSlackCompatibleWebhook(webhookId, webhookToken, slackWebhook, wait, threadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.executeSlackCompatibleWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {ExecuteWebhookRequest} executeWebhookRequest 
         * @param {boolean} [wait] 
         * @param {string} [threadId] 
         * @param {boolean} [withComponents] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeWebhook(webhookId: string, webhookToken: string, executeWebhookRequest: ExecuteWebhookRequest, wait?: boolean, threadId?: string, withComponents?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeWebhook(webhookId, webhookToken, executeWebhookRequest, wait, threadId, withComponents, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.executeWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {FollowChannelRequest} followChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followChannel(channelId: string, followChannelRequest: FollowChannelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelFollowerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followChannel(channelId, followChannelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.followChannel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveGuildThreads(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveGuildThreads(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getActiveGuildThreads']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {number} answerId 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnswerVoters(channelId: string, messageId: string, answerId: number, after?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PollAnswerDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnswerVoters(channelId, messageId, answerId, after, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAnswerVoters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplication(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} commandId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationCommand(applicationId: string, commandId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationCommandResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationCommand(applicationId, commandId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getApplicationCommand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} emojiId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationEmoji(applicationId: string, emojiId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmojiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationEmoji(applicationId, emojiId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getApplicationEmoji']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationRoleConnectionsMetadata(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationRoleConnectionsMetadataItemResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationRoleConnectionsMetadata(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getApplicationRoleConnectionsMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationUserRoleConnection(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationUserRoleConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationUserRoleConnection(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getApplicationUserRoleConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} ruleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAutoModerationRule(guildId: string, ruleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAutoModerationRule200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAutoModerationRule(guildId, ruleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAutoModerationRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBotGateway(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayBotResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBotGateway(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBotGateway']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel(channelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChannel200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChannel(channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getChannel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} entitlementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntitlement(applicationId: string, entitlementId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntitlementResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntitlement(applicationId, entitlementId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getEntitlement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetEntitlementsSkuIdsParameter} skuIds 
         * @param {string} applicationId 
         * @param {string} [userId] 
         * @param {string} [guildId] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {boolean} [excludeEnded] 
         * @param {boolean} [excludeDeleted] 
         * @param {boolean} [onlyActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntitlements(skuIds: GetEntitlementsSkuIdsParameter, applicationId: string, userId?: string, guildId?: string, before?: string, after?: string, limit?: number, excludeEnded?: boolean, excludeDeleted?: boolean, onlyActive?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EntitlementResponse | null>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntitlements(skuIds, applicationId, userId, guildId, before, after, limit, excludeEnded, excludeDeleted, onlyActive, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getEntitlements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGateway(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGateway(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGateway']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {boolean} [withCounts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuild(guildId: string, withCounts?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildWithCountsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuild(guildId, withCounts, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGuild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {string} commandId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuildApplicationCommand(applicationId: string, guildId: string, commandId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationCommandResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildApplicationCommand(applicationId, guildId, commandId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGuildApplicationCommand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {string} commandId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuildApplicationCommandPermissions(applicationId: string, guildId: string, commandId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandPermissionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildApplicationCommandPermissions(applicationId, guildId, commandId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGuildApplicationCommandPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuildBan(guildId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildBanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildBan(guildId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGuildBan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} emojiId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuildEmoji(guildId: string, emojiId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmojiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildEmoji(guildId, emojiId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGuildEmoji']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuildMember(guildId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildMemberResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildMember(guildId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGuildMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuildNewMemberWelcome(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildHomeSettingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildNewMemberWelcome(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGuildNewMemberWelcome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuildPreview(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildPreviewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildPreview(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGuildPreview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuildRole(guildId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildRole(guildId, roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGuildRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} guildScheduledEventId 
         * @param {boolean} [withUserCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuildScheduledEvent(guildId: string, guildScheduledEventId: string, withUserCount?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListGuildScheduledEvents200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildScheduledEvent(guildId, guildScheduledEventId, withUserCount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGuildScheduledEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} soundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuildSoundboardSound(guildId: string, soundId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SoundboardSoundResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildSoundboardSound(guildId, soundId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGuildSoundboardSound']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} stickerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuildSticker(guildId: string, stickerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildStickerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildSticker(guildId, stickerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGuildSticker']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuildTemplate(code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildTemplate(code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGuildTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuildVanityUrl(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VanityURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildVanityUrl(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGuildVanityUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuildWebhooks(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListChannelWebhooks200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildWebhooks(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGuildWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuildWelcomeScreen(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildWelcomeScreenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildWelcomeScreen(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGuildWelcomeScreen']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuildWidget(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WidgetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildWidget(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGuildWidget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} [style] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuildWidgetPng(guildId: string, style?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildWidgetPng(guildId, style, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGuildWidgetPng']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuildWidgetSettings(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WidgetSettingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildWidgetSettings(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGuildWidgetSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuildsOnboarding(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGuildOnboardingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildsOnboarding(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGuildsOnboarding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLobby(lobbyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LobbyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLobby(lobbyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLobby']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLobbyMessages(lobbyId: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LobbyMessageResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLobbyMessages(lobbyId, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLobbyMessages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessage(channelId: string, messageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessage(channelId, messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyApplication(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyApplication(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getMyApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyGuildMember(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateGuildMemberResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyGuildMember(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getMyGuildMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyOauth2Application(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyOauth2Application(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getMyOauth2Application']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyOauth2Authorization(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2GetAuthorizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyOauth2Authorization(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getMyOauth2Authorization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPIIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getMyUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenidConnectUserinfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2GetOpenIDConnectUserInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenidConnectUserinfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOpenidConnectUserinfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {string} [threadId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOriginalWebhookMessage(webhookId: string, webhookToken: string, threadId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOriginalWebhookMessage(webhookId, webhookToken, threadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOriginalWebhookMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeys(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2GetKeys>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeys(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getPublicKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSelfVoiceState(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VoiceStateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSelfVoiceState(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSelfVoiceState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSoundboardDefaultSounds(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SoundboardSoundResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSoundboardDefaultSounds(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSoundboardDefaultSounds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStageInstance(channelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StageInstanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStageInstance(channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStageInstance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} stickerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSticker(stickerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSticker200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSticker(stickerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSticker']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} packId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStickerPack(packId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StickerPackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStickerPack(packId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStickerPack']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} userId 
         * @param {boolean} [withMember] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThreadMember(channelId: string, userId: string, withMember?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadMemberResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThreadMember(channelId, userId, withMember, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getThreadMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVoiceState(guildId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VoiceStateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVoiceState(guildId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getVoiceState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListChannelWebhooks200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhook(webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhookByToken(webhookId: string, webhookToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListChannelWebhooks200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhookByToken(webhookId, webhookToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getWebhookByToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {string} messageId 
         * @param {string} [threadId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhookMessage(webhookId: string, webhookToken: string, messageId: string, threadId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhookMessage(webhookId, webhookToken, messageId, threadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getWebhookMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} code 
         * @param {boolean} [withCounts] 
         * @param {string} [guildScheduledEventId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteResolve(code: string, withCounts?: boolean, guildScheduledEventId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListChannelInvites200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteResolve(code, withCounts, guildScheduledEventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.inviteResolve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteRevoke(code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListChannelInvites200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteRevoke(code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.inviteRevoke']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinThread(channelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinThread(channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.joinThread']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveGuild(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveGuild(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.leaveGuild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveLobby(lobbyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveLobby(lobbyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.leaveLobby']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveThread(channelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveThread(channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.leaveThread']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {boolean} [withLocalizations] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationCommands(applicationId: string, withLocalizations?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationCommandResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationCommands(applicationId, withLocalizations, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listApplicationCommands']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationEmojis(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListApplicationEmojisResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationEmojis(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listApplicationEmojis']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAutoModerationRules(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListAutoModerationRules200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAutoModerationRules(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listAutoModerationRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChannelInvites(channelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListChannelInvites200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listChannelInvites(channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listChannelInvites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChannelWebhooks(channelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListChannelWebhooks200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listChannelWebhooks(channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listChannelWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGuildApplicationCommandPermissions(applicationId: string, guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommandPermissionsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildApplicationCommandPermissions(applicationId, guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listGuildApplicationCommandPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {boolean} [withLocalizations] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGuildApplicationCommands(applicationId: string, guildId: string, withLocalizations?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationCommandResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildApplicationCommands(applicationId, guildId, withLocalizations, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listGuildApplicationCommands']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} [userId] 
         * @param {string} [targetId] 
         * @param {number} [actionType] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGuildAuditLogEntries(guildId: string, userId?: string, targetId?: string, actionType?: number, before?: string, after?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildAuditLogResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildAuditLogEntries(guildId, userId, targetId, actionType, before, after, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listGuildAuditLogEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {number} [limit] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGuildBans(guildId: string, limit?: number, before?: string, after?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuildBanResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildBans(guildId, limit, before, after, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listGuildBans']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGuildChannels(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetChannel200Response>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildChannels(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listGuildChannels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGuildEmojis(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EmojiResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildEmojis(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listGuildEmojis']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGuildIntegrations(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListGuildIntegrations200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildIntegrations(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listGuildIntegrations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGuildInvites(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListChannelInvites200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildInvites(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listGuildInvites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {number} [limit] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGuildMembers(guildId: string, limit?: number, after?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuildMemberResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildMembers(guildId, limit, after, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listGuildMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGuildRoles(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuildRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildRoles(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listGuildRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} guildScheduledEventId 
         * @param {boolean} [withMember] 
         * @param {number} [limit] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGuildScheduledEventUsers(guildId: string, guildScheduledEventId: string, withMember?: boolean, limit?: number, before?: string, after?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScheduledEventUserResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildScheduledEventUsers(guildId, guildScheduledEventId, withMember, limit, before, after, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listGuildScheduledEventUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {boolean} [withUserCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGuildScheduledEvents(guildId: string, withUserCount?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListGuildScheduledEvents200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildScheduledEvents(guildId, withUserCount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listGuildScheduledEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGuildSoundboardSounds(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListGuildSoundboardSoundsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildSoundboardSounds(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listGuildSoundboardSounds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGuildStickers(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuildStickerResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildStickers(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listGuildStickers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGuildTemplates(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuildTemplateResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildTemplates(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listGuildTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGuildVoiceRegions(guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VoiceRegionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildVoiceRegions(guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listGuildVoiceRegions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {string} emojiName 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {number} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMessageReactionsByEmoji(channelId: string, messageId: string, emojiName: string, after?: string, limit?: number, type?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMessageReactionsByEmoji(channelId, messageId, emojiName, after, limit, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listMessageReactionsByEmoji']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [around] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMessages(channelId: string, around?: string, before?: string, after?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMessages(channelId, around, before, after, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listMessages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyConnections(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConnectedAccountResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyConnections(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listMyConnections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {boolean} [withCounts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyGuilds(before?: string, after?: string, limit?: number, withCounts?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MyGuildResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyGuilds(before, after, limit, withCounts, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listMyGuilds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [before] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyPrivateArchivedThreads(channelId: string, before?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyPrivateArchivedThreads(channelId, before, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listMyPrivateArchivedThreads']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [before] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPins(channelId: string, before?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PinnedMessagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPins(channelId, before, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listPins']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [before] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPrivateArchivedThreads(channelId: string, before?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPrivateArchivedThreads(channelId, before, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listPrivateArchivedThreads']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [before] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPublicArchivedThreads(channelId: string, before?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPublicArchivedThreads(channelId, before, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listPublicArchivedThreads']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStickerPacks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StickerPackCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStickerPacks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listStickerPacks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {boolean} [withMember] 
         * @param {number} [limit] 
         * @param {string} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listThreadMembers(channelId: string, withMember?: boolean, limit?: number, after?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThreadMemberResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listThreadMembers(channelId, withMember, limit, after, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listThreadMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVoiceRegions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VoiceRegionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVoiceRegions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listVoiceRegions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PartnerSdkUnmergeProvisionalAccountRequest} partnerSdkUnmergeProvisionalAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerSdkToken(partnerSdkUnmergeProvisionalAccountRequest: PartnerSdkUnmergeProvisionalAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisionalTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerSdkToken(partnerSdkUnmergeProvisionalAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.partnerSdkToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PartnerSdkUnmergeProvisionalAccountRequest} partnerSdkUnmergeProvisionalAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerSdkUnmergeProvisionalAccount(partnerSdkUnmergeProvisionalAccountRequest: PartnerSdkUnmergeProvisionalAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerSdkUnmergeProvisionalAccount(partnerSdkUnmergeProvisionalAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.partnerSdkUnmergeProvisionalAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pollExpire(channelId: string, messageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pollExpire(channelId, messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.pollExpire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {number} [days] 
         * @param {GetEntitlementsSkuIdsParameter} [includeRoles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async previewPruneGuild(guildId: string, days?: number, includeRoles?: GetEntitlementsSkuIdsParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildPruneResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.previewPruneGuild(guildId, days, includeRoles, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.previewPruneGuild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {PruneGuildRequest} pruneGuildRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pruneGuild(guildId: string, pruneGuildRequest: PruneGuildRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildPruneResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pruneGuild(guildId, pruneGuildRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.pruneGuild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {UpdateGuildOnboardingRequest} updateGuildOnboardingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putGuildsOnboarding(guildId: string, updateGuildOnboardingRequest: UpdateGuildOnboardingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildOnboardingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putGuildsOnboarding(guildId, updateGuildOnboardingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.putGuildsOnboarding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} limit 
         * @param {string} query 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchGuildMembers(limit: number, query: string, guildId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuildMemberResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchGuildMembers(limit, query, guildId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.searchGuildMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {SoundboardSoundSendRequest} soundboardSoundSendRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendSoundboardSound(channelId: string, soundboardSoundSendRequest: SoundboardSoundSendRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendSoundboardSound(channelId, soundboardSoundSendRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.sendSoundboardSound']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} overwriteId 
         * @param {SetChannelPermissionOverwriteRequest} setChannelPermissionOverwriteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setChannelPermissionOverwrite(channelId: string, overwriteId: string, setChannelPermissionOverwriteRequest: SetChannelPermissionOverwriteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setChannelPermissionOverwrite(channelId, overwriteId, setChannelPermissionOverwriteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.setChannelPermissionOverwrite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {string} commandId 
         * @param {SetGuildApplicationCommandPermissionsRequest} setGuildApplicationCommandPermissionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setGuildApplicationCommandPermissions(applicationId: string, guildId: string, commandId: string, setGuildApplicationCommandPermissionsRequest: SetGuildApplicationCommandPermissionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandPermissionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setGuildApplicationCommandPermissions(applicationId, guildId, commandId, setGuildApplicationCommandPermissionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.setGuildApplicationCommandPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {SetGuildMfaLevelRequest} setGuildMfaLevelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setGuildMfaLevel(guildId: string, setGuildMfaLevelRequest: SetGuildMfaLevelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildMFALevelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setGuildMfaLevel(guildId, setGuildMfaLevelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.setGuildMfaLevel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncGuildTemplate(guildId: string, code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncGuildTemplate(guildId, code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.syncGuildTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [name] 
         * @param {number} [slop] 
         * @param {string} [minId] 
         * @param {string} [maxId] 
         * @param {ThreadSearchTagParameter} [tag] 
         * @param {string} [tagSetting] 
         * @param {boolean} [archived] 
         * @param {string | null} [sortBy] 
         * @param {string | null} [sortOrder] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async threadSearch(channelId: string, name?: string, slop?: number, minId?: string, maxId?: string, tag?: ThreadSearchTagParameter, tagSetting?: string, archived?: boolean, sortBy?: string | null, sortOrder?: string | null, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.threadSearch(channelId, name, slop, minId, maxId, tag, tagSetting, archived, sortBy, sortOrder, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.threadSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerTypingIndicator(channelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerTypingIndicator(channelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.triggerTypingIndicator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unbanUserFromGuild(guildId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unbanUserFromGuild(guildId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.unbanUserFromGuild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {ApplicationFormPartial} applicationFormPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplication(applicationId: string, applicationFormPartial: ApplicationFormPartial, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplication(applicationId, applicationFormPartial, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} commandId 
         * @param {ApplicationCommandPatchRequestPartial} applicationCommandPatchRequestPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplicationCommand(applicationId: string, commandId: string, applicationCommandPatchRequestPartial: ApplicationCommandPatchRequestPartial, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationCommandResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplicationCommand(applicationId, commandId, applicationCommandPatchRequestPartial, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateApplicationCommand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} emojiId 
         * @param {UpdateApplicationEmojiRequest} updateApplicationEmojiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplicationEmoji(applicationId: string, emojiId: string, updateApplicationEmojiRequest: UpdateApplicationEmojiRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmojiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplicationEmoji(applicationId, emojiId, updateApplicationEmojiRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateApplicationEmoji']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {Array<ApplicationRoleConnectionsMetadataItemRequest> | null} applicationRoleConnectionsMetadataItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplicationRoleConnectionsMetadata(applicationId: string, applicationRoleConnectionsMetadataItemRequest: Array<ApplicationRoleConnectionsMetadataItemRequest> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationRoleConnectionsMetadataItemResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplicationRoleConnectionsMetadata(applicationId, applicationRoleConnectionsMetadataItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateApplicationRoleConnectionsMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {UpdateApplicationUserRoleConnectionRequest} updateApplicationUserRoleConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplicationUserRoleConnection(applicationId: string, updateApplicationUserRoleConnectionRequest: UpdateApplicationUserRoleConnectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationUserRoleConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplicationUserRoleConnection(applicationId, updateApplicationUserRoleConnectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateApplicationUserRoleConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} ruleId 
         * @param {UpdateAutoModerationRuleRequest} updateAutoModerationRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAutoModerationRule(guildId: string, ruleId: string, updateAutoModerationRuleRequest: UpdateAutoModerationRuleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAutoModerationRule200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAutoModerationRule(guildId, ruleId, updateAutoModerationRuleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateAutoModerationRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {UpdateChannelRequest} updateChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateChannel(channelId: string, updateChannelRequest: UpdateChannelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChannel200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateChannel(channelId, updateChannelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateChannel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {GuildPatchRequestPartial} guildPatchRequestPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGuild(guildId: string, guildPatchRequestPartial: GuildPatchRequestPartial, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGuild(guildId, guildPatchRequestPartial, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateGuild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {string} commandId 
         * @param {ApplicationCommandPatchRequestPartial} applicationCommandPatchRequestPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGuildApplicationCommand(applicationId: string, guildId: string, commandId: string, applicationCommandPatchRequestPartial: ApplicationCommandPatchRequestPartial, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationCommandResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGuildApplicationCommand(applicationId, guildId, commandId, applicationCommandPatchRequestPartial, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateGuildApplicationCommand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} emojiId 
         * @param {UpdateGuildEmojiRequest} updateGuildEmojiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGuildEmoji(guildId: string, emojiId: string, updateGuildEmojiRequest: UpdateGuildEmojiRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmojiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGuildEmoji(guildId, emojiId, updateGuildEmojiRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateGuildEmoji']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {UpdateGuildMemberRequest} updateGuildMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGuildMember(guildId: string, userId: string, updateGuildMemberRequest: UpdateGuildMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildMemberResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGuildMember(guildId, userId, updateGuildMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateGuildMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} roleId 
         * @param {CreateGuildRoleRequest} createGuildRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGuildRole(guildId: string, roleId: string, createGuildRoleRequest: CreateGuildRoleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGuildRole(guildId, roleId, createGuildRoleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateGuildRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} guildScheduledEventId 
         * @param {UpdateGuildScheduledEventRequest} updateGuildScheduledEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGuildScheduledEvent(guildId: string, guildScheduledEventId: string, updateGuildScheduledEventRequest: UpdateGuildScheduledEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListGuildScheduledEvents200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGuildScheduledEvent(guildId, guildScheduledEventId, updateGuildScheduledEventRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateGuildScheduledEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} soundId 
         * @param {SoundboardPatchRequestPartial} soundboardPatchRequestPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGuildSoundboardSound(guildId: string, soundId: string, soundboardPatchRequestPartial: SoundboardPatchRequestPartial, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SoundboardSoundResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGuildSoundboardSound(guildId, soundId, soundboardPatchRequestPartial, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateGuildSoundboardSound']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} stickerId 
         * @param {UpdateGuildStickerRequest} updateGuildStickerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGuildSticker(guildId: string, stickerId: string, updateGuildStickerRequest: UpdateGuildStickerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildStickerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGuildSticker(guildId, stickerId, updateGuildStickerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateGuildSticker']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} code 
         * @param {UpdateGuildTemplateRequest} updateGuildTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGuildTemplate(guildId: string, code: string, updateGuildTemplateRequest: UpdateGuildTemplateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGuildTemplate(guildId, code, updateGuildTemplateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateGuildTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {WelcomeScreenPatchRequestPartial} welcomeScreenPatchRequestPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGuildWelcomeScreen(guildId: string, welcomeScreenPatchRequestPartial: WelcomeScreenPatchRequestPartial, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildWelcomeScreenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGuildWelcomeScreen(guildId, welcomeScreenPatchRequestPartial, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateGuildWelcomeScreen']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {UpdateGuildWidgetSettingsRequest} updateGuildWidgetSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGuildWidgetSettings(guildId: string, updateGuildWidgetSettingsRequest: UpdateGuildWidgetSettingsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WidgetSettingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGuildWidgetSettings(guildId, updateGuildWidgetSettingsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateGuildWidgetSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {MessageEditRequestPartial} messageEditRequestPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMessage(channelId: string, messageId: string, messageEditRequestPartial: MessageEditRequestPartial, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMessage(channelId, messageId, messageEditRequestPartial, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApplicationFormPartial} applicationFormPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMyApplication(applicationFormPartial: ApplicationFormPartial, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMyApplication(applicationFormPartial, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateMyApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {UpdateMyGuildMemberRequest} updateMyGuildMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMyGuildMember(guildId: string, updateMyGuildMemberRequest: UpdateMyGuildMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateGuildMemberResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMyGuildMember(guildId, updateMyGuildMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateMyGuildMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {BotAccountPatchRequest} botAccountPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMyUser(botAccountPatchRequest: BotAccountPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPIIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMyUser(botAccountPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateMyUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {IncomingWebhookUpdateRequestPartial} incomingWebhookUpdateRequestPartial 
         * @param {string} [threadId] 
         * @param {boolean} [withComponents] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOriginalWebhookMessage(webhookId: string, webhookToken: string, incomingWebhookUpdateRequestPartial: IncomingWebhookUpdateRequestPartial, threadId?: string, withComponents?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOriginalWebhookMessage(webhookId, webhookToken, incomingWebhookUpdateRequestPartial, threadId, withComponents, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateOriginalWebhookMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {UpdateSelfVoiceStateRequest} updateSelfVoiceStateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSelfVoiceState(guildId: string, updateSelfVoiceStateRequest: UpdateSelfVoiceStateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSelfVoiceState(guildId, updateSelfVoiceStateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateSelfVoiceState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} channelId 
         * @param {UpdateStageInstanceRequest} updateStageInstanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStageInstance(channelId: string, updateStageInstanceRequest: UpdateStageInstanceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StageInstanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStageInstance(channelId, updateStageInstanceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateStageInstance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {UpdateVoiceStateRequest} updateVoiceStateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVoiceState(guildId: string, userId: string, updateVoiceStateRequest: UpdateVoiceStateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVoiceState(guildId, userId, updateVoiceStateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateVoiceState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {UpdateWebhookRequest} updateWebhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(webhookId: string, updateWebhookRequest: UpdateWebhookRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListChannelWebhooks200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(webhookId, updateWebhookRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {UpdateWebhookByTokenRequest} updateWebhookByTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhookByToken(webhookId: string, webhookToken: string, updateWebhookByTokenRequest: UpdateWebhookByTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListChannelWebhooks200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhookByToken(webhookId, webhookToken, updateWebhookByTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateWebhookByToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {string} messageId 
         * @param {IncomingWebhookUpdateRequestPartial} incomingWebhookUpdateRequestPartial 
         * @param {string} [threadId] 
         * @param {boolean} [withComponents] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhookMessage(webhookId: string, webhookToken: string, messageId: string, incomingWebhookUpdateRequestPartial: IncomingWebhookUpdateRequestPartial, threadId?: string, withComponents?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhookMessage(webhookId, webhookToken, messageId, incomingWebhookUpdateRequestPartial, threadId, withComponents, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateWebhookMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadApplicationAttachment(applicationId: string, file: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivitiesAttachmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadApplicationAttachment(applicationId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.uploadApplicationAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {string} channelId 
         * @param {string} userId 
         * @param {AddGroupDmUserRequest} addGroupDmUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupDmUser(channelId: string, userId: string, addGroupDmUserRequest: AddGroupDmUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddGroupDmUser201Response> {
            return localVarFp.addGroupDmUser(channelId, userId, addGroupDmUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {AddGuildMemberRequest} addGuildMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGuildMember(guildId: string, userId: string, addGuildMemberRequest: AddGuildMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<GuildMemberResponse> {
            return localVarFp.addGuildMember(guildId, userId, addGuildMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGuildMemberRole(guildId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addGuildMemberRole(guildId, userId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {string} userId 
         * @param {AddLobbyMemberRequest} addLobbyMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLobbyMember(lobbyId: string, userId: string, addLobbyMemberRequest: AddLobbyMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<LobbyMemberResponse> {
            return localVarFp.addLobbyMember(lobbyId, userId, addLobbyMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {string} emojiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMyMessageReaction(channelId: string, messageId: string, emojiName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addMyMessageReaction(channelId, messageId, emojiName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addThreadMember(channelId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addThreadMember(channelId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applicationsGetActivityInstance(applicationId: string, instanceId: string, options?: RawAxiosRequestConfig): AxiosPromise<EmbeddedActivityInstance> {
            return localVarFp.applicationsGetActivityInstance(applicationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {BanUserFromGuildRequest} banUserFromGuildRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banUserFromGuild(guildId: string, userId: string, banUserFromGuildRequest: BanUserFromGuildRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.banUserFromGuild(guildId, userId, banUserFromGuildRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {BulkBanUsersFromGuildRequest} bulkBanUsersFromGuildRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkBanUsersFromGuild(guildId: string, bulkBanUsersFromGuildRequest: BulkBanUsersFromGuildRequest, options?: RawAxiosRequestConfig): AxiosPromise<BulkBanUsersResponse> {
            return localVarFp.bulkBanUsersFromGuild(guildId, bulkBanUsersFromGuildRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {BulkDeleteMessagesRequest} bulkDeleteMessagesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteMessages(channelId: string, bulkDeleteMessagesRequest: BulkDeleteMessagesRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bulkDeleteMessages(channelId, bulkDeleteMessagesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {Array<ApplicationCommandUpdateRequest> | null} applicationCommandUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSetApplicationCommands(applicationId: string, applicationCommandUpdateRequest: Array<ApplicationCommandUpdateRequest> | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApplicationCommandResponse>> {
            return localVarFp.bulkSetApplicationCommands(applicationId, applicationCommandUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {Array<ApplicationCommandUpdateRequest> | null} applicationCommandUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSetGuildApplicationCommands(applicationId: string, guildId: string, applicationCommandUpdateRequest: Array<ApplicationCommandUpdateRequest> | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApplicationCommandResponse>> {
            return localVarFp.bulkSetGuildApplicationCommands(applicationId, guildId, applicationCommandUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {Array<BulkUpdateGuildChannelsRequestInner>} bulkUpdateGuildChannelsRequestInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateGuildChannels(guildId: string, bulkUpdateGuildChannelsRequestInner: Array<BulkUpdateGuildChannelsRequestInner>, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bulkUpdateGuildChannels(guildId, bulkUpdateGuildChannelsRequestInner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {Array<BulkUpdateGuildRolesRequestInner>} bulkUpdateGuildRolesRequestInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateGuildRoles(guildId: string, bulkUpdateGuildRolesRequestInner: Array<BulkUpdateGuildRolesRequestInner>, options?: RawAxiosRequestConfig): AxiosPromise<Array<GuildRoleResponse>> {
            return localVarFp.bulkUpdateGuildRoles(guildId, bulkUpdateGuildRolesRequestInner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {Array<BulkLobbyMemberRequest> | null} bulkLobbyMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateLobbyMembers(lobbyId: string, bulkLobbyMemberRequest: Array<BulkLobbyMemberRequest> | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<LobbyMemberResponse>> {
            return localVarFp.bulkUpdateLobbyMembers(lobbyId, bulkLobbyMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} entitlementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumeEntitlement(applicationId: string, entitlementId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.consumeEntitlement(applicationId, entitlementId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {ApplicationCommandCreateRequest} applicationCommandCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationCommand(applicationId: string, applicationCommandCreateRequest: ApplicationCommandCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationCommandResponse> {
            return localVarFp.createApplicationCommand(applicationId, applicationCommandCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {CreateApplicationEmojiRequest} createApplicationEmojiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEmoji(applicationId: string, createApplicationEmojiRequest: CreateApplicationEmojiRequest, options?: RawAxiosRequestConfig): AxiosPromise<EmojiResponse> {
            return localVarFp.createApplicationEmoji(applicationId, createApplicationEmojiRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {CreateAutoModerationRuleRequest} createAutoModerationRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAutoModerationRule(guildId: string, createAutoModerationRuleRequest: CreateAutoModerationRuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateAutoModerationRule200Response> {
            return localVarFp.createAutoModerationRule(guildId, createAutoModerationRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {CreateChannelInviteRequest} createChannelInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannelInvite(channelId: string, createChannelInviteRequest: CreateChannelInviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListChannelInvites200ResponseInner> {
            return localVarFp.createChannelInvite(channelId, createChannelInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreatePrivateChannelRequest} createPrivateChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDm(createPrivateChannelRequest: CreatePrivateChannelRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddGroupDmUser201Response> {
            return localVarFp.createDm(createPrivateChannelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {CreateEntitlementRequestData} createEntitlementRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntitlement(applicationId: string, createEntitlementRequestData: CreateEntitlementRequestData, options?: RawAxiosRequestConfig): AxiosPromise<EntitlementResponse> {
            return localVarFp.createEntitlement(applicationId, createEntitlementRequestData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GuildCreateRequest} guildCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuild(guildCreateRequest: GuildCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GuildResponse> {
            return localVarFp.createGuild(guildCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {ApplicationCommandCreateRequest} applicationCommandCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuildApplicationCommand(applicationId: string, guildId: string, applicationCommandCreateRequest: ApplicationCommandCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationCommandResponse> {
            return localVarFp.createGuildApplicationCommand(applicationId, guildId, applicationCommandCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {CreateGuildChannelRequest} createGuildChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuildChannel(guildId: string, createGuildChannelRequest: CreateGuildChannelRequest, options?: RawAxiosRequestConfig): AxiosPromise<GuildChannelResponse> {
            return localVarFp.createGuildChannel(guildId, createGuildChannelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {CreateGuildEmojiRequest} createGuildEmojiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuildEmoji(guildId: string, createGuildEmojiRequest: CreateGuildEmojiRequest, options?: RawAxiosRequestConfig): AxiosPromise<EmojiResponse> {
            return localVarFp.createGuildEmoji(guildId, createGuildEmojiRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} code 
         * @param {CreateGuildFromTemplateRequest} createGuildFromTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuildFromTemplate(code: string, createGuildFromTemplateRequest: CreateGuildFromTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GuildResponse> {
            return localVarFp.createGuildFromTemplate(code, createGuildFromTemplateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {CreateGuildRoleRequest} createGuildRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuildRole(guildId: string, createGuildRoleRequest: CreateGuildRoleRequest, options?: RawAxiosRequestConfig): AxiosPromise<GuildRoleResponse> {
            return localVarFp.createGuildRole(guildId, createGuildRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {CreateGuildScheduledEventRequest} createGuildScheduledEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuildScheduledEvent(guildId: string, createGuildScheduledEventRequest: CreateGuildScheduledEventRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListGuildScheduledEvents200ResponseInner> {
            return localVarFp.createGuildScheduledEvent(guildId, createGuildScheduledEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {SoundboardCreateRequest} soundboardCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuildSoundboardSound(guildId: string, soundboardCreateRequest: SoundboardCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<SoundboardSoundResponse> {
            return localVarFp.createGuildSoundboardSound(guildId, soundboardCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} name 
         * @param {string} tags 
         * @param {string} file 
         * @param {string | null} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuildSticker(guildId: string, name: string, tags: string, file: string, description?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<GuildStickerResponse> {
            return localVarFp.createGuildSticker(guildId, name, tags, file, description, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {CreateGuildTemplateRequest} createGuildTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuildTemplate(guildId: string, createGuildTemplateRequest: CreateGuildTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GuildTemplateResponse> {
            return localVarFp.createGuildTemplate(guildId, createGuildTemplateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} interactionId 
         * @param {string} interactionToken 
         * @param {CreateInteractionResponseRequest} createInteractionResponseRequest 
         * @param {boolean} [withResponse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInteractionResponse(interactionId: string, interactionToken: string, createInteractionResponseRequest: CreateInteractionResponseRequest, withResponse?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<InteractionCallbackResponse> {
            return localVarFp.createInteractionResponse(interactionId, interactionToken, createInteractionResponseRequest, withResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateLobbyRequest} createLobbyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLobby(createLobbyRequest: CreateLobbyRequest, options?: RawAxiosRequestConfig): AxiosPromise<LobbyResponse> {
            return localVarFp.createLobby(createLobbyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {SDKMessageRequest} sDKMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLobbyMessage(lobbyId: string, sDKMessageRequest: SDKMessageRequest, options?: RawAxiosRequestConfig): AxiosPromise<LobbyMessageResponse> {
            return localVarFp.createLobbyMessage(lobbyId, sDKMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {MessageCreateRequest} messageCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessage(channelId: string, messageCreateRequest: MessageCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
            return localVarFp.createMessage(channelId, messageCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateOrJoinLobbyRequest} createOrJoinLobbyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrJoinLobby(createOrJoinLobbyRequest: CreateOrJoinLobbyRequest, options?: RawAxiosRequestConfig): AxiosPromise<LobbyResponse> {
            return localVarFp.createOrJoinLobby(createOrJoinLobbyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPin(channelId: string, messageId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createPin(channelId, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateStageInstanceRequest} createStageInstanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStageInstance(createStageInstanceRequest: CreateStageInstanceRequest, options?: RawAxiosRequestConfig): AxiosPromise<StageInstanceResponse> {
            return localVarFp.createStageInstance(createStageInstanceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {CreateThreadRequest} createThreadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createThread(channelId: string, createThreadRequest: CreateThreadRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreatedThreadResponse> {
            return localVarFp.createThread(channelId, createThreadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {CreateTextThreadWithMessageRequest} createTextThreadWithMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createThreadFromMessage(channelId: string, messageId: string, createTextThreadWithMessageRequest: CreateTextThreadWithMessageRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThreadResponse> {
            return localVarFp.createThreadFromMessage(channelId, messageId, createTextThreadWithMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {CreateWebhookRequest} createWebhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(channelId: string, createWebhookRequest: CreateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<GuildIncomingWebhookResponse> {
            return localVarFp.createWebhook(channelId, createWebhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crosspostMessage(channelId: string, messageId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
            return localVarFp.crosspostMessage(channelId, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllMessageReactions(channelId: string, messageId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAllMessageReactions(channelId, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {string} emojiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllMessageReactionsByEmoji(channelId: string, messageId: string, emojiName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAllMessageReactionsByEmoji(channelId, messageId, emojiName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} commandId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationCommand(applicationId: string, commandId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteApplicationCommand(applicationId, commandId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} emojiId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationEmoji(applicationId: string, emojiId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteApplicationEmoji(applicationId, emojiId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationUserRoleConnection(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteApplicationUserRoleConnection(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} ruleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAutoModerationRule(guildId: string, ruleId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAutoModerationRule(guildId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannel(channelId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetChannel200Response> {
            return localVarFp.deleteChannel(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} overwriteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannelPermissionOverwrite(channelId: string, overwriteId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteChannelPermissionOverwrite(channelId, overwriteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} entitlementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntitlement(applicationId: string, entitlementId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteEntitlement(applicationId, entitlementId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupDmUser(channelId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGroupDmUser(channelId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuild(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGuild(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {string} commandId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildApplicationCommand(applicationId: string, guildId: string, commandId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGuildApplicationCommand(applicationId, guildId, commandId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} emojiId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildEmoji(guildId: string, emojiId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGuildEmoji(guildId, emojiId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} integrationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildIntegration(guildId: string, integrationId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGuildIntegration(guildId, integrationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildMember(guildId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGuildMember(guildId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildMemberRole(guildId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGuildMemberRole(guildId, userId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildRole(guildId: string, roleId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGuildRole(guildId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} guildScheduledEventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildScheduledEvent(guildId: string, guildScheduledEventId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGuildScheduledEvent(guildId, guildScheduledEventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} soundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildSoundboardSound(guildId: string, soundId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGuildSoundboardSound(guildId, soundId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} stickerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildSticker(guildId: string, stickerId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGuildSticker(guildId, stickerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildTemplate(guildId: string, code: string, options?: RawAxiosRequestConfig): AxiosPromise<GuildTemplateResponse> {
            return localVarFp.deleteGuildTemplate(guildId, code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLobbyMember(lobbyId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteLobbyMember(lobbyId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(channelId: string, messageId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMessage(channelId, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {string} emojiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMyMessageReaction(channelId: string, messageId: string, emojiName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMyMessageReaction(channelId, messageId, emojiName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {string} [threadId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOriginalWebhookMessage(webhookId: string, webhookToken: string, threadId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOriginalWebhookMessage(webhookId, webhookToken, threadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePin(channelId: string, messageId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePin(channelId, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStageInstance(channelId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteStageInstance(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteThreadMember(channelId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteThreadMember(channelId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {string} emojiName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserMessageReaction(channelId: string, messageId: string, emojiName: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUserMessageReaction(channelId, messageId, emojiName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookByToken(webhookId: string, webhookToken: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWebhookByToken(webhookId, webhookToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {string} messageId 
         * @param {string} [threadId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookMessage(webhookId: string, webhookToken: string, messageId: string, threadId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWebhookMessage(webhookId, webhookToken, messageId, threadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedCreatePin(channelId: string, messageId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deprecatedCreatePin(channelId, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedDeletePin(channelId: string, messageId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deprecatedDeletePin(channelId, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedListPins(channelId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<MessageResponse>> {
            return localVarFp.deprecatedListPins(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {CreateLobbyRequest} createLobbyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editLobby(lobbyId: string, createLobbyRequest: CreateLobbyRequest, options?: RawAxiosRequestConfig): AxiosPromise<LobbyResponse> {
            return localVarFp.editLobby(lobbyId, createLobbyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {EditLobbyChannelLinkRequest} editLobbyChannelLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editLobbyChannelLink(lobbyId: string, editLobbyChannelLinkRequest: EditLobbyChannelLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<LobbyResponse> {
            return localVarFp.editLobbyChannelLink(lobbyId, editLobbyChannelLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {GithubWebhook} githubWebhook 
         * @param {boolean} [wait] 
         * @param {string} [threadId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeGithubCompatibleWebhook(webhookId: string, webhookToken: string, githubWebhook: GithubWebhook, wait?: boolean, threadId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.executeGithubCompatibleWebhook(webhookId, webhookToken, githubWebhook, wait, threadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {SlackWebhook} slackWebhook 
         * @param {boolean} [wait] 
         * @param {string} [threadId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSlackCompatibleWebhook(webhookId: string, webhookToken: string, slackWebhook: SlackWebhook, wait?: boolean, threadId?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.executeSlackCompatibleWebhook(webhookId, webhookToken, slackWebhook, wait, threadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {ExecuteWebhookRequest} executeWebhookRequest 
         * @param {boolean} [wait] 
         * @param {string} [threadId] 
         * @param {boolean} [withComponents] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWebhook(webhookId: string, webhookToken: string, executeWebhookRequest: ExecuteWebhookRequest, wait?: boolean, threadId?: string, withComponents?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
            return localVarFp.executeWebhook(webhookId, webhookToken, executeWebhookRequest, wait, threadId, withComponents, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {FollowChannelRequest} followChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followChannel(channelId: string, followChannelRequest: FollowChannelRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChannelFollowerResponse> {
            return localVarFp.followChannel(channelId, followChannelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveGuildThreads(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<ThreadsResponse> {
            return localVarFp.getActiveGuildThreads(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {number} answerId 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnswerVoters(channelId: string, messageId: string, answerId: number, after?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PollAnswerDetailsResponse> {
            return localVarFp.getAnswerVoters(channelId, messageId, answerId, after, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<PrivateApplicationResponse> {
            return localVarFp.getApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} commandId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationCommand(applicationId: string, commandId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationCommandResponse> {
            return localVarFp.getApplicationCommand(applicationId, commandId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} emojiId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationEmoji(applicationId: string, emojiId: string, options?: RawAxiosRequestConfig): AxiosPromise<EmojiResponse> {
            return localVarFp.getApplicationEmoji(applicationId, emojiId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationRoleConnectionsMetadata(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApplicationRoleConnectionsMetadataItemResponse>> {
            return localVarFp.getApplicationRoleConnectionsMetadata(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUserRoleConnection(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationUserRoleConnectionResponse> {
            return localVarFp.getApplicationUserRoleConnection(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} ruleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoModerationRule(guildId: string, ruleId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateAutoModerationRule200Response> {
            return localVarFp.getAutoModerationRule(guildId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotGateway(options?: RawAxiosRequestConfig): AxiosPromise<GatewayBotResponse> {
            return localVarFp.getBotGateway(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel(channelId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetChannel200Response> {
            return localVarFp.getChannel(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} entitlementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlement(applicationId: string, entitlementId: string, options?: RawAxiosRequestConfig): AxiosPromise<EntitlementResponse> {
            return localVarFp.getEntitlement(applicationId, entitlementId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetEntitlementsSkuIdsParameter} skuIds 
         * @param {string} applicationId 
         * @param {string} [userId] 
         * @param {string} [guildId] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {boolean} [excludeEnded] 
         * @param {boolean} [excludeDeleted] 
         * @param {boolean} [onlyActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlements(skuIds: GetEntitlementsSkuIdsParameter, applicationId: string, userId?: string, guildId?: string, before?: string, after?: string, limit?: number, excludeEnded?: boolean, excludeDeleted?: boolean, onlyActive?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<EntitlementResponse | null>> {
            return localVarFp.getEntitlements(skuIds, applicationId, userId, guildId, before, after, limit, excludeEnded, excludeDeleted, onlyActive, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGateway(options?: RawAxiosRequestConfig): AxiosPromise<GatewayResponse> {
            return localVarFp.getGateway(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {boolean} [withCounts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuild(guildId: string, withCounts?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<GuildWithCountsResponse> {
            return localVarFp.getGuild(guildId, withCounts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {string} commandId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildApplicationCommand(applicationId: string, guildId: string, commandId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationCommandResponse> {
            return localVarFp.getGuildApplicationCommand(applicationId, guildId, commandId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {string} commandId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildApplicationCommandPermissions(applicationId: string, guildId: string, commandId: string, options?: RawAxiosRequestConfig): AxiosPromise<CommandPermissionsResponse> {
            return localVarFp.getGuildApplicationCommandPermissions(applicationId, guildId, commandId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildBan(guildId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<GuildBanResponse> {
            return localVarFp.getGuildBan(guildId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} emojiId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildEmoji(guildId: string, emojiId: string, options?: RawAxiosRequestConfig): AxiosPromise<EmojiResponse> {
            return localVarFp.getGuildEmoji(guildId, emojiId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildMember(guildId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<GuildMemberResponse> {
            return localVarFp.getGuildMember(guildId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildNewMemberWelcome(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<GuildHomeSettingsResponse> {
            return localVarFp.getGuildNewMemberWelcome(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildPreview(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<GuildPreviewResponse> {
            return localVarFp.getGuildPreview(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildRole(guildId: string, roleId: string, options?: RawAxiosRequestConfig): AxiosPromise<GuildRoleResponse> {
            return localVarFp.getGuildRole(guildId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} guildScheduledEventId 
         * @param {boolean} [withUserCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildScheduledEvent(guildId: string, guildScheduledEventId: string, withUserCount?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ListGuildScheduledEvents200ResponseInner> {
            return localVarFp.getGuildScheduledEvent(guildId, guildScheduledEventId, withUserCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} soundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildSoundboardSound(guildId: string, soundId: string, options?: RawAxiosRequestConfig): AxiosPromise<SoundboardSoundResponse> {
            return localVarFp.getGuildSoundboardSound(guildId, soundId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} stickerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildSticker(guildId: string, stickerId: string, options?: RawAxiosRequestConfig): AxiosPromise<GuildStickerResponse> {
            return localVarFp.getGuildSticker(guildId, stickerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildTemplate(code: string, options?: RawAxiosRequestConfig): AxiosPromise<GuildTemplateResponse> {
            return localVarFp.getGuildTemplate(code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildVanityUrl(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<VanityURLResponse> {
            return localVarFp.getGuildVanityUrl(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildWebhooks(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ListChannelWebhooks200ResponseInner>> {
            return localVarFp.getGuildWebhooks(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildWelcomeScreen(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<GuildWelcomeScreenResponse> {
            return localVarFp.getGuildWelcomeScreen(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildWidget(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<WidgetResponse> {
            return localVarFp.getGuildWidget(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} [style] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildWidgetPng(guildId: string, style?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getGuildWidgetPng(guildId, style, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildWidgetSettings(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<WidgetSettingsResponse> {
            return localVarFp.getGuildWidgetSettings(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildsOnboarding(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserGuildOnboardingResponse> {
            return localVarFp.getGuildsOnboarding(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLobby(lobbyId: string, options?: RawAxiosRequestConfig): AxiosPromise<LobbyResponse> {
            return localVarFp.getLobby(lobbyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLobbyMessages(lobbyId: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<LobbyMessageResponse>> {
            return localVarFp.getLobbyMessages(lobbyId, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage(channelId: string, messageId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
            return localVarFp.getMessage(channelId, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyApplication(options?: RawAxiosRequestConfig): AxiosPromise<PrivateApplicationResponse> {
            return localVarFp.getMyApplication(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyGuildMember(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<PrivateGuildMemberResponse> {
            return localVarFp.getMyGuildMember(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyOauth2Application(options?: RawAxiosRequestConfig): AxiosPromise<PrivateApplicationResponse> {
            return localVarFp.getMyOauth2Application(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyOauth2Authorization(options?: RawAxiosRequestConfig): AxiosPromise<OAuth2GetAuthorizationResponse> {
            return localVarFp.getMyOauth2Authorization(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUser(options?: RawAxiosRequestConfig): AxiosPromise<UserPIIResponse> {
            return localVarFp.getMyUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenidConnectUserinfo(options?: RawAxiosRequestConfig): AxiosPromise<OAuth2GetOpenIDConnectUserInfoResponse> {
            return localVarFp.getOpenidConnectUserinfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {string} [threadId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOriginalWebhookMessage(webhookId: string, webhookToken: string, threadId?: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
            return localVarFp.getOriginalWebhookMessage(webhookId, webhookToken, threadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys(options?: RawAxiosRequestConfig): AxiosPromise<OAuth2GetKeys> {
            return localVarFp.getPublicKeys(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSelfVoiceState(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<VoiceStateResponse> {
            return localVarFp.getSelfVoiceState(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSoundboardDefaultSounds(options?: RawAxiosRequestConfig): AxiosPromise<Array<SoundboardSoundResponse>> {
            return localVarFp.getSoundboardDefaultSounds(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStageInstance(channelId: string, options?: RawAxiosRequestConfig): AxiosPromise<StageInstanceResponse> {
            return localVarFp.getStageInstance(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} stickerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSticker(stickerId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetSticker200Response> {
            return localVarFp.getSticker(stickerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} packId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStickerPack(packId: string, options?: RawAxiosRequestConfig): AxiosPromise<StickerPackResponse> {
            return localVarFp.getStickerPack(packId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} userId 
         * @param {boolean} [withMember] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreadMember(channelId: string, userId: string, withMember?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ThreadMemberResponse> {
            return localVarFp.getThreadMember(channelId, userId, withMember, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoiceState(guildId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<VoiceStateResponse> {
            return localVarFp.getVoiceState(guildId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<ListChannelWebhooks200ResponseInner> {
            return localVarFp.getWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookByToken(webhookId: string, webhookToken: string, options?: RawAxiosRequestConfig): AxiosPromise<ListChannelWebhooks200ResponseInner> {
            return localVarFp.getWebhookByToken(webhookId, webhookToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {string} messageId 
         * @param {string} [threadId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookMessage(webhookId: string, webhookToken: string, messageId: string, threadId?: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
            return localVarFp.getWebhookMessage(webhookId, webhookToken, messageId, threadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} code 
         * @param {boolean} [withCounts] 
         * @param {string} [guildScheduledEventId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteResolve(code: string, withCounts?: boolean, guildScheduledEventId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListChannelInvites200ResponseInner> {
            return localVarFp.inviteResolve(code, withCounts, guildScheduledEventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteRevoke(code: string, options?: RawAxiosRequestConfig): AxiosPromise<ListChannelInvites200ResponseInner> {
            return localVarFp.inviteRevoke(code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinThread(channelId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.joinThread(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveGuild(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.leaveGuild(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} lobbyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveLobby(lobbyId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.leaveLobby(lobbyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveThread(channelId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.leaveThread(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {boolean} [withLocalizations] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationCommands(applicationId: string, withLocalizations?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApplicationCommandResponse>> {
            return localVarFp.listApplicationCommands(applicationId, withLocalizations, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationEmojis(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ListApplicationEmojisResponse> {
            return localVarFp.listApplicationEmojis(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAutoModerationRules(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ListAutoModerationRules200ResponseInner>> {
            return localVarFp.listAutoModerationRules(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChannelInvites(channelId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ListChannelInvites200ResponseInner>> {
            return localVarFp.listChannelInvites(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChannelWebhooks(channelId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ListChannelWebhooks200ResponseInner>> {
            return localVarFp.listChannelWebhooks(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildApplicationCommandPermissions(applicationId: string, guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CommandPermissionsResponse>> {
            return localVarFp.listGuildApplicationCommandPermissions(applicationId, guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {boolean} [withLocalizations] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildApplicationCommands(applicationId: string, guildId: string, withLocalizations?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApplicationCommandResponse>> {
            return localVarFp.listGuildApplicationCommands(applicationId, guildId, withLocalizations, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} [userId] 
         * @param {string} [targetId] 
         * @param {number} [actionType] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildAuditLogEntries(guildId: string, userId?: string, targetId?: string, actionType?: number, before?: string, after?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<GuildAuditLogResponse> {
            return localVarFp.listGuildAuditLogEntries(guildId, userId, targetId, actionType, before, after, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {number} [limit] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildBans(guildId: string, limit?: number, before?: string, after?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GuildBanResponse>> {
            return localVarFp.listGuildBans(guildId, limit, before, after, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildChannels(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetChannel200Response>> {
            return localVarFp.listGuildChannels(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildEmojis(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EmojiResponse>> {
            return localVarFp.listGuildEmojis(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildIntegrations(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ListGuildIntegrations200ResponseInner>> {
            return localVarFp.listGuildIntegrations(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildInvites(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ListChannelInvites200ResponseInner>> {
            return localVarFp.listGuildInvites(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {number} [limit] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildMembers(guildId: string, limit?: number, after?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<GuildMemberResponse>> {
            return localVarFp.listGuildMembers(guildId, limit, after, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildRoles(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GuildRoleResponse>> {
            return localVarFp.listGuildRoles(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} guildScheduledEventId 
         * @param {boolean} [withMember] 
         * @param {number} [limit] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildScheduledEventUsers(guildId: string, guildScheduledEventId: string, withMember?: boolean, limit?: number, before?: string, after?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ScheduledEventUserResponse>> {
            return localVarFp.listGuildScheduledEventUsers(guildId, guildScheduledEventId, withMember, limit, before, after, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {boolean} [withUserCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildScheduledEvents(guildId: string, withUserCount?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<ListGuildScheduledEvents200ResponseInner>> {
            return localVarFp.listGuildScheduledEvents(guildId, withUserCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildSoundboardSounds(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<ListGuildSoundboardSoundsResponse> {
            return localVarFp.listGuildSoundboardSounds(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildStickers(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GuildStickerResponse>> {
            return localVarFp.listGuildStickers(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildTemplates(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GuildTemplateResponse>> {
            return localVarFp.listGuildTemplates(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildVoiceRegions(guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<VoiceRegionResponse>> {
            return localVarFp.listGuildVoiceRegions(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {string} emojiName 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {number} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessageReactionsByEmoji(channelId: string, messageId: string, emojiName: string, after?: string, limit?: number, type?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserResponse>> {
            return localVarFp.listMessageReactionsByEmoji(channelId, messageId, emojiName, after, limit, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [around] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessages(channelId: string, around?: string, before?: string, after?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<MessageResponse>> {
            return localVarFp.listMessages(channelId, around, before, after, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyConnections(options?: RawAxiosRequestConfig): AxiosPromise<Array<ConnectedAccountResponse>> {
            return localVarFp.listMyConnections(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {boolean} [withCounts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyGuilds(before?: string, after?: string, limit?: number, withCounts?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<MyGuildResponse>> {
            return localVarFp.listMyGuilds(before, after, limit, withCounts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [before] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyPrivateArchivedThreads(channelId: string, before?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ThreadsResponse> {
            return localVarFp.listMyPrivateArchivedThreads(channelId, before, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [before] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPins(channelId: string, before?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PinnedMessagesResponse> {
            return localVarFp.listPins(channelId, before, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [before] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPrivateArchivedThreads(channelId: string, before?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ThreadsResponse> {
            return localVarFp.listPrivateArchivedThreads(channelId, before, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [before] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicArchivedThreads(channelId: string, before?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ThreadsResponse> {
            return localVarFp.listPublicArchivedThreads(channelId, before, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStickerPacks(options?: RawAxiosRequestConfig): AxiosPromise<StickerPackCollectionResponse> {
            return localVarFp.listStickerPacks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {boolean} [withMember] 
         * @param {number} [limit] 
         * @param {string} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listThreadMembers(channelId: string, withMember?: boolean, limit?: number, after?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ThreadMemberResponse>> {
            return localVarFp.listThreadMembers(channelId, withMember, limit, after, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoiceRegions(options?: RawAxiosRequestConfig): AxiosPromise<Array<VoiceRegionResponse>> {
            return localVarFp.listVoiceRegions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PartnerSdkUnmergeProvisionalAccountRequest} partnerSdkUnmergeProvisionalAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerSdkToken(partnerSdkUnmergeProvisionalAccountRequest: PartnerSdkUnmergeProvisionalAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProvisionalTokenResponse> {
            return localVarFp.partnerSdkToken(partnerSdkUnmergeProvisionalAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PartnerSdkUnmergeProvisionalAccountRequest} partnerSdkUnmergeProvisionalAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerSdkUnmergeProvisionalAccount(partnerSdkUnmergeProvisionalAccountRequest: PartnerSdkUnmergeProvisionalAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.partnerSdkUnmergeProvisionalAccount(partnerSdkUnmergeProvisionalAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollExpire(channelId: string, messageId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
            return localVarFp.pollExpire(channelId, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {number} [days] 
         * @param {GetEntitlementsSkuIdsParameter} [includeRoles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewPruneGuild(guildId: string, days?: number, includeRoles?: GetEntitlementsSkuIdsParameter, options?: RawAxiosRequestConfig): AxiosPromise<GuildPruneResponse> {
            return localVarFp.previewPruneGuild(guildId, days, includeRoles, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {PruneGuildRequest} pruneGuildRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pruneGuild(guildId: string, pruneGuildRequest: PruneGuildRequest, options?: RawAxiosRequestConfig): AxiosPromise<GuildPruneResponse> {
            return localVarFp.pruneGuild(guildId, pruneGuildRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {UpdateGuildOnboardingRequest} updateGuildOnboardingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGuildsOnboarding(guildId: string, updateGuildOnboardingRequest: UpdateGuildOnboardingRequest, options?: RawAxiosRequestConfig): AxiosPromise<GuildOnboardingResponse> {
            return localVarFp.putGuildsOnboarding(guildId, updateGuildOnboardingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} limit 
         * @param {string} query 
         * @param {string} guildId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGuildMembers(limit: number, query: string, guildId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GuildMemberResponse>> {
            return localVarFp.searchGuildMembers(limit, query, guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {SoundboardSoundSendRequest} soundboardSoundSendRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSoundboardSound(channelId: string, soundboardSoundSendRequest: SoundboardSoundSendRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendSoundboardSound(channelId, soundboardSoundSendRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} overwriteId 
         * @param {SetChannelPermissionOverwriteRequest} setChannelPermissionOverwriteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelPermissionOverwrite(channelId: string, overwriteId: string, setChannelPermissionOverwriteRequest: SetChannelPermissionOverwriteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setChannelPermissionOverwrite(channelId, overwriteId, setChannelPermissionOverwriteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {string} commandId 
         * @param {SetGuildApplicationCommandPermissionsRequest} setGuildApplicationCommandPermissionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGuildApplicationCommandPermissions(applicationId: string, guildId: string, commandId: string, setGuildApplicationCommandPermissionsRequest: SetGuildApplicationCommandPermissionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommandPermissionsResponse> {
            return localVarFp.setGuildApplicationCommandPermissions(applicationId, guildId, commandId, setGuildApplicationCommandPermissionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {SetGuildMfaLevelRequest} setGuildMfaLevelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGuildMfaLevel(guildId: string, setGuildMfaLevelRequest: SetGuildMfaLevelRequest, options?: RawAxiosRequestConfig): AxiosPromise<GuildMFALevelResponse> {
            return localVarFp.setGuildMfaLevel(guildId, setGuildMfaLevelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncGuildTemplate(guildId: string, code: string, options?: RawAxiosRequestConfig): AxiosPromise<GuildTemplateResponse> {
            return localVarFp.syncGuildTemplate(guildId, code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [name] 
         * @param {number} [slop] 
         * @param {string} [minId] 
         * @param {string} [maxId] 
         * @param {ThreadSearchTagParameter} [tag] 
         * @param {string} [tagSetting] 
         * @param {boolean} [archived] 
         * @param {string | null} [sortBy] 
         * @param {string | null} [sortOrder] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadSearch(channelId: string, name?: string, slop?: number, minId?: string, maxId?: string, tag?: ThreadSearchTagParameter, tagSetting?: string, archived?: boolean, sortBy?: string | null, sortOrder?: string | null, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ThreadSearchResponse> {
            return localVarFp.threadSearch(channelId, name, slop, minId, maxId, tag, tagSetting, archived, sortBy, sortOrder, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerTypingIndicator(channelId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.triggerTypingIndicator(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbanUserFromGuild(guildId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unbanUserFromGuild(guildId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {ApplicationFormPartial} applicationFormPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication(applicationId: string, applicationFormPartial: ApplicationFormPartial, options?: RawAxiosRequestConfig): AxiosPromise<PrivateApplicationResponse> {
            return localVarFp.updateApplication(applicationId, applicationFormPartial, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} commandId 
         * @param {ApplicationCommandPatchRequestPartial} applicationCommandPatchRequestPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationCommand(applicationId: string, commandId: string, applicationCommandPatchRequestPartial: ApplicationCommandPatchRequestPartial, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationCommandResponse> {
            return localVarFp.updateApplicationCommand(applicationId, commandId, applicationCommandPatchRequestPartial, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} emojiId 
         * @param {UpdateApplicationEmojiRequest} updateApplicationEmojiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationEmoji(applicationId: string, emojiId: string, updateApplicationEmojiRequest: UpdateApplicationEmojiRequest, options?: RawAxiosRequestConfig): AxiosPromise<EmojiResponse> {
            return localVarFp.updateApplicationEmoji(applicationId, emojiId, updateApplicationEmojiRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {Array<ApplicationRoleConnectionsMetadataItemRequest> | null} applicationRoleConnectionsMetadataItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationRoleConnectionsMetadata(applicationId: string, applicationRoleConnectionsMetadataItemRequest: Array<ApplicationRoleConnectionsMetadataItemRequest> | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApplicationRoleConnectionsMetadataItemResponse>> {
            return localVarFp.updateApplicationRoleConnectionsMetadata(applicationId, applicationRoleConnectionsMetadataItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {UpdateApplicationUserRoleConnectionRequest} updateApplicationUserRoleConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationUserRoleConnection(applicationId: string, updateApplicationUserRoleConnectionRequest: UpdateApplicationUserRoleConnectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationUserRoleConnectionResponse> {
            return localVarFp.updateApplicationUserRoleConnection(applicationId, updateApplicationUserRoleConnectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} ruleId 
         * @param {UpdateAutoModerationRuleRequest} updateAutoModerationRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutoModerationRule(guildId: string, ruleId: string, updateAutoModerationRuleRequest: UpdateAutoModerationRuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateAutoModerationRule200Response> {
            return localVarFp.updateAutoModerationRule(guildId, ruleId, updateAutoModerationRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {UpdateChannelRequest} updateChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChannel(channelId: string, updateChannelRequest: UpdateChannelRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetChannel200Response> {
            return localVarFp.updateChannel(channelId, updateChannelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {GuildPatchRequestPartial} guildPatchRequestPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuild(guildId: string, guildPatchRequestPartial: GuildPatchRequestPartial, options?: RawAxiosRequestConfig): AxiosPromise<GuildResponse> {
            return localVarFp.updateGuild(guildId, guildPatchRequestPartial, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} guildId 
         * @param {string} commandId 
         * @param {ApplicationCommandPatchRequestPartial} applicationCommandPatchRequestPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildApplicationCommand(applicationId: string, guildId: string, commandId: string, applicationCommandPatchRequestPartial: ApplicationCommandPatchRequestPartial, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationCommandResponse> {
            return localVarFp.updateGuildApplicationCommand(applicationId, guildId, commandId, applicationCommandPatchRequestPartial, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} emojiId 
         * @param {UpdateGuildEmojiRequest} updateGuildEmojiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildEmoji(guildId: string, emojiId: string, updateGuildEmojiRequest: UpdateGuildEmojiRequest, options?: RawAxiosRequestConfig): AxiosPromise<EmojiResponse> {
            return localVarFp.updateGuildEmoji(guildId, emojiId, updateGuildEmojiRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {UpdateGuildMemberRequest} updateGuildMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildMember(guildId: string, userId: string, updateGuildMemberRequest: UpdateGuildMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<GuildMemberResponse> {
            return localVarFp.updateGuildMember(guildId, userId, updateGuildMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} roleId 
         * @param {CreateGuildRoleRequest} createGuildRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildRole(guildId: string, roleId: string, createGuildRoleRequest: CreateGuildRoleRequest, options?: RawAxiosRequestConfig): AxiosPromise<GuildRoleResponse> {
            return localVarFp.updateGuildRole(guildId, roleId, createGuildRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} guildScheduledEventId 
         * @param {UpdateGuildScheduledEventRequest} updateGuildScheduledEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildScheduledEvent(guildId: string, guildScheduledEventId: string, updateGuildScheduledEventRequest: UpdateGuildScheduledEventRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListGuildScheduledEvents200ResponseInner> {
            return localVarFp.updateGuildScheduledEvent(guildId, guildScheduledEventId, updateGuildScheduledEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} soundId 
         * @param {SoundboardPatchRequestPartial} soundboardPatchRequestPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildSoundboardSound(guildId: string, soundId: string, soundboardPatchRequestPartial: SoundboardPatchRequestPartial, options?: RawAxiosRequestConfig): AxiosPromise<SoundboardSoundResponse> {
            return localVarFp.updateGuildSoundboardSound(guildId, soundId, soundboardPatchRequestPartial, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} stickerId 
         * @param {UpdateGuildStickerRequest} updateGuildStickerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildSticker(guildId: string, stickerId: string, updateGuildStickerRequest: UpdateGuildStickerRequest, options?: RawAxiosRequestConfig): AxiosPromise<GuildStickerResponse> {
            return localVarFp.updateGuildSticker(guildId, stickerId, updateGuildStickerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} code 
         * @param {UpdateGuildTemplateRequest} updateGuildTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildTemplate(guildId: string, code: string, updateGuildTemplateRequest: UpdateGuildTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GuildTemplateResponse> {
            return localVarFp.updateGuildTemplate(guildId, code, updateGuildTemplateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {WelcomeScreenPatchRequestPartial} welcomeScreenPatchRequestPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildWelcomeScreen(guildId: string, welcomeScreenPatchRequestPartial: WelcomeScreenPatchRequestPartial, options?: RawAxiosRequestConfig): AxiosPromise<GuildWelcomeScreenResponse> {
            return localVarFp.updateGuildWelcomeScreen(guildId, welcomeScreenPatchRequestPartial, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {UpdateGuildWidgetSettingsRequest} updateGuildWidgetSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildWidgetSettings(guildId: string, updateGuildWidgetSettingsRequest: UpdateGuildWidgetSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<WidgetSettingsResponse> {
            return localVarFp.updateGuildWidgetSettings(guildId, updateGuildWidgetSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} messageId 
         * @param {MessageEditRequestPartial} messageEditRequestPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessage(channelId: string, messageId: string, messageEditRequestPartial: MessageEditRequestPartial, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
            return localVarFp.updateMessage(channelId, messageId, messageEditRequestPartial, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApplicationFormPartial} applicationFormPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyApplication(applicationFormPartial: ApplicationFormPartial, options?: RawAxiosRequestConfig): AxiosPromise<PrivateApplicationResponse> {
            return localVarFp.updateMyApplication(applicationFormPartial, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {UpdateMyGuildMemberRequest} updateMyGuildMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyGuildMember(guildId: string, updateMyGuildMemberRequest: UpdateMyGuildMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<PrivateGuildMemberResponse> {
            return localVarFp.updateMyGuildMember(guildId, updateMyGuildMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BotAccountPatchRequest} botAccountPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyUser(botAccountPatchRequest: BotAccountPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserPIIResponse> {
            return localVarFp.updateMyUser(botAccountPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {IncomingWebhookUpdateRequestPartial} incomingWebhookUpdateRequestPartial 
         * @param {string} [threadId] 
         * @param {boolean} [withComponents] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOriginalWebhookMessage(webhookId: string, webhookToken: string, incomingWebhookUpdateRequestPartial: IncomingWebhookUpdateRequestPartial, threadId?: string, withComponents?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
            return localVarFp.updateOriginalWebhookMessage(webhookId, webhookToken, incomingWebhookUpdateRequestPartial, threadId, withComponents, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {UpdateSelfVoiceStateRequest} updateSelfVoiceStateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSelfVoiceState(guildId: string, updateSelfVoiceStateRequest: UpdateSelfVoiceStateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateSelfVoiceState(guildId, updateSelfVoiceStateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {UpdateStageInstanceRequest} updateStageInstanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStageInstance(channelId: string, updateStageInstanceRequest: UpdateStageInstanceRequest, options?: RawAxiosRequestConfig): AxiosPromise<StageInstanceResponse> {
            return localVarFp.updateStageInstance(channelId, updateStageInstanceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guildId 
         * @param {string} userId 
         * @param {UpdateVoiceStateRequest} updateVoiceStateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoiceState(guildId: string, userId: string, updateVoiceStateRequest: UpdateVoiceStateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateVoiceState(guildId, userId, updateVoiceStateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {UpdateWebhookRequest} updateWebhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhookId: string, updateWebhookRequest: UpdateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListChannelWebhooks200ResponseInner> {
            return localVarFp.updateWebhook(webhookId, updateWebhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {UpdateWebhookByTokenRequest} updateWebhookByTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookByToken(webhookId: string, webhookToken: string, updateWebhookByTokenRequest: UpdateWebhookByTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListChannelWebhooks200ResponseInner> {
            return localVarFp.updateWebhookByToken(webhookId, webhookToken, updateWebhookByTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {string} webhookToken 
         * @param {string} messageId 
         * @param {IncomingWebhookUpdateRequestPartial} incomingWebhookUpdateRequestPartial 
         * @param {string} [threadId] 
         * @param {boolean} [withComponents] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookMessage(webhookId: string, webhookToken: string, messageId: string, incomingWebhookUpdateRequestPartial: IncomingWebhookUpdateRequestPartial, threadId?: string, withComponents?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
            return localVarFp.updateWebhookMessage(webhookId, webhookToken, messageId, incomingWebhookUpdateRequestPartial, threadId, withComponents, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadApplicationAttachment(applicationId: string, file: string, options?: RawAxiosRequestConfig): AxiosPromise<ActivitiesAttachmentResponse> {
            return localVarFp.uploadApplicationAttachment(applicationId, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {string} channelId 
     * @param {string} userId 
     * @param {AddGroupDmUserRequest} addGroupDmUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addGroupDmUser(channelId: string, userId: string, addGroupDmUserRequest: AddGroupDmUserRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addGroupDmUser(channelId, userId, addGroupDmUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} userId 
     * @param {AddGuildMemberRequest} addGuildMemberRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addGuildMember(guildId: string, userId: string, addGuildMemberRequest: AddGuildMemberRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addGuildMember(guildId, userId, addGuildMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} userId 
     * @param {string} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addGuildMemberRole(guildId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addGuildMemberRole(guildId, userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} lobbyId 
     * @param {string} userId 
     * @param {AddLobbyMemberRequest} addLobbyMemberRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addLobbyMember(lobbyId: string, userId: string, addLobbyMemberRequest: AddLobbyMemberRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addLobbyMember(lobbyId, userId, addLobbyMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} messageId 
     * @param {string} emojiName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addMyMessageReaction(channelId: string, messageId: string, emojiName: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addMyMessageReaction(channelId, messageId, emojiName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addThreadMember(channelId: string, userId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addThreadMember(channelId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public applicationsGetActivityInstance(applicationId: string, instanceId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).applicationsGetActivityInstance(applicationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} userId 
     * @param {BanUserFromGuildRequest} banUserFromGuildRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public banUserFromGuild(guildId: string, userId: string, banUserFromGuildRequest: BanUserFromGuildRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).banUserFromGuild(guildId, userId, banUserFromGuildRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {BulkBanUsersFromGuildRequest} bulkBanUsersFromGuildRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bulkBanUsersFromGuild(guildId: string, bulkBanUsersFromGuildRequest: BulkBanUsersFromGuildRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bulkBanUsersFromGuild(guildId, bulkBanUsersFromGuildRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {BulkDeleteMessagesRequest} bulkDeleteMessagesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bulkDeleteMessages(channelId: string, bulkDeleteMessagesRequest: BulkDeleteMessagesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bulkDeleteMessages(channelId, bulkDeleteMessagesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {Array<ApplicationCommandUpdateRequest> | null} applicationCommandUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bulkSetApplicationCommands(applicationId: string, applicationCommandUpdateRequest: Array<ApplicationCommandUpdateRequest> | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bulkSetApplicationCommands(applicationId, applicationCommandUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} guildId 
     * @param {Array<ApplicationCommandUpdateRequest> | null} applicationCommandUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bulkSetGuildApplicationCommands(applicationId: string, guildId: string, applicationCommandUpdateRequest: Array<ApplicationCommandUpdateRequest> | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bulkSetGuildApplicationCommands(applicationId, guildId, applicationCommandUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {Array<BulkUpdateGuildChannelsRequestInner>} bulkUpdateGuildChannelsRequestInner 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bulkUpdateGuildChannels(guildId: string, bulkUpdateGuildChannelsRequestInner: Array<BulkUpdateGuildChannelsRequestInner>, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bulkUpdateGuildChannels(guildId, bulkUpdateGuildChannelsRequestInner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {Array<BulkUpdateGuildRolesRequestInner>} bulkUpdateGuildRolesRequestInner 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bulkUpdateGuildRoles(guildId: string, bulkUpdateGuildRolesRequestInner: Array<BulkUpdateGuildRolesRequestInner>, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bulkUpdateGuildRoles(guildId, bulkUpdateGuildRolesRequestInner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} lobbyId 
     * @param {Array<BulkLobbyMemberRequest> | null} bulkLobbyMemberRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bulkUpdateLobbyMembers(lobbyId: string, bulkLobbyMemberRequest: Array<BulkLobbyMemberRequest> | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bulkUpdateLobbyMembers(lobbyId, bulkLobbyMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} entitlementId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public consumeEntitlement(applicationId: string, entitlementId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).consumeEntitlement(applicationId, entitlementId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {ApplicationCommandCreateRequest} applicationCommandCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createApplicationCommand(applicationId: string, applicationCommandCreateRequest: ApplicationCommandCreateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createApplicationCommand(applicationId, applicationCommandCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {CreateApplicationEmojiRequest} createApplicationEmojiRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createApplicationEmoji(applicationId: string, createApplicationEmojiRequest: CreateApplicationEmojiRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createApplicationEmoji(applicationId, createApplicationEmojiRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {CreateAutoModerationRuleRequest} createAutoModerationRuleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createAutoModerationRule(guildId: string, createAutoModerationRuleRequest: CreateAutoModerationRuleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createAutoModerationRule(guildId, createAutoModerationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {CreateChannelInviteRequest} createChannelInviteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createChannelInvite(channelId: string, createChannelInviteRequest: CreateChannelInviteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createChannelInvite(channelId, createChannelInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreatePrivateChannelRequest} createPrivateChannelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createDm(createPrivateChannelRequest: CreatePrivateChannelRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createDm(createPrivateChannelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {CreateEntitlementRequestData} createEntitlementRequestData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createEntitlement(applicationId: string, createEntitlementRequestData: CreateEntitlementRequestData, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createEntitlement(applicationId, createEntitlementRequestData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GuildCreateRequest} guildCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createGuild(guildCreateRequest: GuildCreateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createGuild(guildCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} guildId 
     * @param {ApplicationCommandCreateRequest} applicationCommandCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createGuildApplicationCommand(applicationId: string, guildId: string, applicationCommandCreateRequest: ApplicationCommandCreateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createGuildApplicationCommand(applicationId, guildId, applicationCommandCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {CreateGuildChannelRequest} createGuildChannelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createGuildChannel(guildId: string, createGuildChannelRequest: CreateGuildChannelRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createGuildChannel(guildId, createGuildChannelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {CreateGuildEmojiRequest} createGuildEmojiRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createGuildEmoji(guildId: string, createGuildEmojiRequest: CreateGuildEmojiRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createGuildEmoji(guildId, createGuildEmojiRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} code 
     * @param {CreateGuildFromTemplateRequest} createGuildFromTemplateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createGuildFromTemplate(code: string, createGuildFromTemplateRequest: CreateGuildFromTemplateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createGuildFromTemplate(code, createGuildFromTemplateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {CreateGuildRoleRequest} createGuildRoleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createGuildRole(guildId: string, createGuildRoleRequest: CreateGuildRoleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createGuildRole(guildId, createGuildRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {CreateGuildScheduledEventRequest} createGuildScheduledEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createGuildScheduledEvent(guildId: string, createGuildScheduledEventRequest: CreateGuildScheduledEventRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createGuildScheduledEvent(guildId, createGuildScheduledEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {SoundboardCreateRequest} soundboardCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createGuildSoundboardSound(guildId: string, soundboardCreateRequest: SoundboardCreateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createGuildSoundboardSound(guildId, soundboardCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} name 
     * @param {string} tags 
     * @param {string} file 
     * @param {string | null} [description] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createGuildSticker(guildId: string, name: string, tags: string, file: string, description?: string | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createGuildSticker(guildId, name, tags, file, description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {CreateGuildTemplateRequest} createGuildTemplateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createGuildTemplate(guildId: string, createGuildTemplateRequest: CreateGuildTemplateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createGuildTemplate(guildId, createGuildTemplateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} interactionId 
     * @param {string} interactionToken 
     * @param {CreateInteractionResponseRequest} createInteractionResponseRequest 
     * @param {boolean} [withResponse] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createInteractionResponse(interactionId: string, interactionToken: string, createInteractionResponseRequest: CreateInteractionResponseRequest, withResponse?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createInteractionResponse(interactionId, interactionToken, createInteractionResponseRequest, withResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateLobbyRequest} createLobbyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createLobby(createLobbyRequest: CreateLobbyRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createLobby(createLobbyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} lobbyId 
     * @param {SDKMessageRequest} sDKMessageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createLobbyMessage(lobbyId: string, sDKMessageRequest: SDKMessageRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createLobbyMessage(lobbyId, sDKMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {MessageCreateRequest} messageCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createMessage(channelId: string, messageCreateRequest: MessageCreateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createMessage(channelId, messageCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateOrJoinLobbyRequest} createOrJoinLobbyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createOrJoinLobby(createOrJoinLobbyRequest: CreateOrJoinLobbyRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createOrJoinLobby(createOrJoinLobbyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} messageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createPin(channelId: string, messageId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createPin(channelId, messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateStageInstanceRequest} createStageInstanceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createStageInstance(createStageInstanceRequest: CreateStageInstanceRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createStageInstance(createStageInstanceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {CreateThreadRequest} createThreadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createThread(channelId: string, createThreadRequest: CreateThreadRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createThread(channelId, createThreadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} messageId 
     * @param {CreateTextThreadWithMessageRequest} createTextThreadWithMessageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createThreadFromMessage(channelId: string, messageId: string, createTextThreadWithMessageRequest: CreateTextThreadWithMessageRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createThreadFromMessage(channelId, messageId, createTextThreadWithMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {CreateWebhookRequest} createWebhookRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createWebhook(channelId: string, createWebhookRequest: CreateWebhookRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createWebhook(channelId, createWebhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} messageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public crosspostMessage(channelId: string, messageId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).crosspostMessage(channelId, messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} messageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteAllMessageReactions(channelId: string, messageId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteAllMessageReactions(channelId, messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} messageId 
     * @param {string} emojiName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteAllMessageReactionsByEmoji(channelId: string, messageId: string, emojiName: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteAllMessageReactionsByEmoji(channelId, messageId, emojiName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} commandId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteApplicationCommand(applicationId: string, commandId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteApplicationCommand(applicationId, commandId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} emojiId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteApplicationEmoji(applicationId: string, emojiId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteApplicationEmoji(applicationId, emojiId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteApplicationUserRoleConnection(applicationId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteApplicationUserRoleConnection(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} ruleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteAutoModerationRule(guildId: string, ruleId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteAutoModerationRule(guildId, ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteChannel(channelId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteChannel(channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} overwriteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteChannelPermissionOverwrite(channelId: string, overwriteId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteChannelPermissionOverwrite(channelId, overwriteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} entitlementId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteEntitlement(applicationId: string, entitlementId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteEntitlement(applicationId, entitlementId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteGroupDmUser(channelId: string, userId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteGroupDmUser(channelId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteGuild(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteGuild(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} guildId 
     * @param {string} commandId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteGuildApplicationCommand(applicationId: string, guildId: string, commandId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteGuildApplicationCommand(applicationId, guildId, commandId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} emojiId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteGuildEmoji(guildId: string, emojiId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteGuildEmoji(guildId, emojiId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} integrationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteGuildIntegration(guildId: string, integrationId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteGuildIntegration(guildId, integrationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteGuildMember(guildId: string, userId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteGuildMember(guildId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} userId 
     * @param {string} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteGuildMemberRole(guildId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteGuildMemberRole(guildId, userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteGuildRole(guildId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteGuildRole(guildId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} guildScheduledEventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteGuildScheduledEvent(guildId: string, guildScheduledEventId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteGuildScheduledEvent(guildId, guildScheduledEventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} soundId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteGuildSoundboardSound(guildId: string, soundId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteGuildSoundboardSound(guildId, soundId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} stickerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteGuildSticker(guildId: string, stickerId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteGuildSticker(guildId, stickerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteGuildTemplate(guildId: string, code: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteGuildTemplate(guildId, code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} lobbyId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteLobbyMember(lobbyId: string, userId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteLobbyMember(lobbyId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} messageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteMessage(channelId: string, messageId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteMessage(channelId, messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} messageId 
     * @param {string} emojiName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteMyMessageReaction(channelId: string, messageId: string, emojiName: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteMyMessageReaction(channelId, messageId, emojiName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} webhookId 
     * @param {string} webhookToken 
     * @param {string} [threadId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteOriginalWebhookMessage(webhookId: string, webhookToken: string, threadId?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteOriginalWebhookMessage(webhookId, webhookToken, threadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} messageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deletePin(channelId: string, messageId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deletePin(channelId, messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteStageInstance(channelId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteStageInstance(channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteThreadMember(channelId: string, userId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteThreadMember(channelId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} messageId 
     * @param {string} emojiName 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteUserMessageReaction(channelId: string, messageId: string, emojiName: string, userId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteUserMessageReaction(channelId, messageId, emojiName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} webhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} webhookId 
     * @param {string} webhookToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteWebhookByToken(webhookId: string, webhookToken: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteWebhookByToken(webhookId, webhookToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} webhookId 
     * @param {string} webhookToken 
     * @param {string} messageId 
     * @param {string} [threadId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteWebhookMessage(webhookId: string, webhookToken: string, messageId: string, threadId?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteWebhookMessage(webhookId, webhookToken, messageId, threadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} messageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deprecatedCreatePin(channelId: string, messageId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deprecatedCreatePin(channelId, messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} messageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deprecatedDeletePin(channelId: string, messageId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deprecatedDeletePin(channelId, messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deprecatedListPins(channelId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deprecatedListPins(channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} lobbyId 
     * @param {CreateLobbyRequest} createLobbyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public editLobby(lobbyId: string, createLobbyRequest: CreateLobbyRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).editLobby(lobbyId, createLobbyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} lobbyId 
     * @param {EditLobbyChannelLinkRequest} editLobbyChannelLinkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public editLobbyChannelLink(lobbyId: string, editLobbyChannelLinkRequest: EditLobbyChannelLinkRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).editLobbyChannelLink(lobbyId, editLobbyChannelLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} webhookId 
     * @param {string} webhookToken 
     * @param {GithubWebhook} githubWebhook 
     * @param {boolean} [wait] 
     * @param {string} [threadId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public executeGithubCompatibleWebhook(webhookId: string, webhookToken: string, githubWebhook: GithubWebhook, wait?: boolean, threadId?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).executeGithubCompatibleWebhook(webhookId, webhookToken, githubWebhook, wait, threadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} webhookId 
     * @param {string} webhookToken 
     * @param {SlackWebhook} slackWebhook 
     * @param {boolean} [wait] 
     * @param {string} [threadId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public executeSlackCompatibleWebhook(webhookId: string, webhookToken: string, slackWebhook: SlackWebhook, wait?: boolean, threadId?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).executeSlackCompatibleWebhook(webhookId, webhookToken, slackWebhook, wait, threadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} webhookId 
     * @param {string} webhookToken 
     * @param {ExecuteWebhookRequest} executeWebhookRequest 
     * @param {boolean} [wait] 
     * @param {string} [threadId] 
     * @param {boolean} [withComponents] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public executeWebhook(webhookId: string, webhookToken: string, executeWebhookRequest: ExecuteWebhookRequest, wait?: boolean, threadId?: string, withComponents?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).executeWebhook(webhookId, webhookToken, executeWebhookRequest, wait, threadId, withComponents, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {FollowChannelRequest} followChannelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public followChannel(channelId: string, followChannelRequest: FollowChannelRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).followChannel(channelId, followChannelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getActiveGuildThreads(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getActiveGuildThreads(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} messageId 
     * @param {number} answerId 
     * @param {string} [after] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAnswerVoters(channelId: string, messageId: string, answerId: number, after?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAnswerVoters(channelId, messageId, answerId, after, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApplication(applicationId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} commandId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApplicationCommand(applicationId: string, commandId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApplicationCommand(applicationId, commandId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} emojiId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApplicationEmoji(applicationId: string, emojiId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApplicationEmoji(applicationId, emojiId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApplicationRoleConnectionsMetadata(applicationId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApplicationRoleConnectionsMetadata(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApplicationUserRoleConnection(applicationId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApplicationUserRoleConnection(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} ruleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAutoModerationRule(guildId: string, ruleId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAutoModerationRule(guildId, ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBotGateway(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBotGateway(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getChannel(channelId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getChannel(channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} entitlementId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEntitlement(applicationId: string, entitlementId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEntitlement(applicationId, entitlementId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetEntitlementsSkuIdsParameter} skuIds 
     * @param {string} applicationId 
     * @param {string} [userId] 
     * @param {string} [guildId] 
     * @param {string} [before] 
     * @param {string} [after] 
     * @param {number} [limit] 
     * @param {boolean} [excludeEnded] 
     * @param {boolean} [excludeDeleted] 
     * @param {boolean} [onlyActive] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEntitlements(skuIds: GetEntitlementsSkuIdsParameter, applicationId: string, userId?: string, guildId?: string, before?: string, after?: string, limit?: number, excludeEnded?: boolean, excludeDeleted?: boolean, onlyActive?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEntitlements(skuIds, applicationId, userId, guildId, before, after, limit, excludeEnded, excludeDeleted, onlyActive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGateway(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGateway(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {boolean} [withCounts] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGuild(guildId: string, withCounts?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGuild(guildId, withCounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} guildId 
     * @param {string} commandId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGuildApplicationCommand(applicationId: string, guildId: string, commandId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGuildApplicationCommand(applicationId, guildId, commandId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} guildId 
     * @param {string} commandId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGuildApplicationCommandPermissions(applicationId: string, guildId: string, commandId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGuildApplicationCommandPermissions(applicationId, guildId, commandId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGuildBan(guildId: string, userId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGuildBan(guildId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} emojiId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGuildEmoji(guildId: string, emojiId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGuildEmoji(guildId, emojiId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGuildMember(guildId: string, userId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGuildMember(guildId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGuildNewMemberWelcome(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGuildNewMemberWelcome(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGuildPreview(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGuildPreview(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGuildRole(guildId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGuildRole(guildId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} guildScheduledEventId 
     * @param {boolean} [withUserCount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGuildScheduledEvent(guildId: string, guildScheduledEventId: string, withUserCount?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGuildScheduledEvent(guildId, guildScheduledEventId, withUserCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} soundId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGuildSoundboardSound(guildId: string, soundId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGuildSoundboardSound(guildId, soundId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} stickerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGuildSticker(guildId: string, stickerId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGuildSticker(guildId, stickerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGuildTemplate(code: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGuildTemplate(code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGuildVanityUrl(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGuildVanityUrl(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGuildWebhooks(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGuildWebhooks(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGuildWelcomeScreen(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGuildWelcomeScreen(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGuildWidget(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGuildWidget(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} [style] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGuildWidgetPng(guildId: string, style?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGuildWidgetPng(guildId, style, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGuildWidgetSettings(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGuildWidgetSettings(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGuildsOnboarding(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGuildsOnboarding(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} lobbyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLobby(lobbyId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLobby(lobbyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} lobbyId 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLobbyMessages(lobbyId: string, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLobbyMessages(lobbyId, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} messageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMessage(channelId: string, messageId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMessage(channelId, messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMyApplication(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMyApplication(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMyGuildMember(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMyGuildMember(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMyOauth2Application(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMyOauth2Application(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMyOauth2Authorization(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMyOauth2Authorization(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMyUser(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMyUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOpenidConnectUserinfo(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOpenidConnectUserinfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} webhookId 
     * @param {string} webhookToken 
     * @param {string} [threadId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOriginalWebhookMessage(webhookId: string, webhookToken: string, threadId?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOriginalWebhookMessage(webhookId, webhookToken, threadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPublicKeys(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPublicKeys(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSelfVoiceState(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSelfVoiceState(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSoundboardDefaultSounds(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSoundboardDefaultSounds(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStageInstance(channelId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStageInstance(channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} stickerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSticker(stickerId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSticker(stickerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} packId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStickerPack(packId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStickerPack(packId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} userId 
     * @param {boolean} [withMember] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getThreadMember(channelId: string, userId: string, withMember?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getThreadMember(channelId, userId, withMember, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUser(userId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getVoiceState(guildId: string, userId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getVoiceState(guildId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} webhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWebhook(webhookId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} webhookId 
     * @param {string} webhookToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWebhookByToken(webhookId: string, webhookToken: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWebhookByToken(webhookId, webhookToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} webhookId 
     * @param {string} webhookToken 
     * @param {string} messageId 
     * @param {string} [threadId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWebhookMessage(webhookId: string, webhookToken: string, messageId: string, threadId?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWebhookMessage(webhookId, webhookToken, messageId, threadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} code 
     * @param {boolean} [withCounts] 
     * @param {string} [guildScheduledEventId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public inviteResolve(code: string, withCounts?: boolean, guildScheduledEventId?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).inviteResolve(code, withCounts, guildScheduledEventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public inviteRevoke(code: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).inviteRevoke(code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public joinThread(channelId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).joinThread(channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public leaveGuild(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).leaveGuild(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} lobbyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public leaveLobby(lobbyId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).leaveLobby(lobbyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public leaveThread(channelId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).leaveThread(channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {boolean} [withLocalizations] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listApplicationCommands(applicationId: string, withLocalizations?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listApplicationCommands(applicationId, withLocalizations, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listApplicationEmojis(applicationId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listApplicationEmojis(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listAutoModerationRules(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listAutoModerationRules(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listChannelInvites(channelId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listChannelInvites(channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listChannelWebhooks(channelId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listChannelWebhooks(channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listGuildApplicationCommandPermissions(applicationId: string, guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listGuildApplicationCommandPermissions(applicationId, guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} guildId 
     * @param {boolean} [withLocalizations] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listGuildApplicationCommands(applicationId: string, guildId: string, withLocalizations?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listGuildApplicationCommands(applicationId, guildId, withLocalizations, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} [userId] 
     * @param {string} [targetId] 
     * @param {number} [actionType] 
     * @param {string} [before] 
     * @param {string} [after] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listGuildAuditLogEntries(guildId: string, userId?: string, targetId?: string, actionType?: number, before?: string, after?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listGuildAuditLogEntries(guildId, userId, targetId, actionType, before, after, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {number} [limit] 
     * @param {string} [before] 
     * @param {string} [after] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listGuildBans(guildId: string, limit?: number, before?: string, after?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listGuildBans(guildId, limit, before, after, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listGuildChannels(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listGuildChannels(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listGuildEmojis(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listGuildEmojis(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listGuildIntegrations(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listGuildIntegrations(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listGuildInvites(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listGuildInvites(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {number} [limit] 
     * @param {number} [after] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listGuildMembers(guildId: string, limit?: number, after?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listGuildMembers(guildId, limit, after, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listGuildRoles(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listGuildRoles(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} guildScheduledEventId 
     * @param {boolean} [withMember] 
     * @param {number} [limit] 
     * @param {string} [before] 
     * @param {string} [after] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listGuildScheduledEventUsers(guildId: string, guildScheduledEventId: string, withMember?: boolean, limit?: number, before?: string, after?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listGuildScheduledEventUsers(guildId, guildScheduledEventId, withMember, limit, before, after, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {boolean} [withUserCount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listGuildScheduledEvents(guildId: string, withUserCount?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listGuildScheduledEvents(guildId, withUserCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listGuildSoundboardSounds(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listGuildSoundboardSounds(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listGuildStickers(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listGuildStickers(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listGuildTemplates(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listGuildTemplates(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listGuildVoiceRegions(guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listGuildVoiceRegions(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} messageId 
     * @param {string} emojiName 
     * @param {string} [after] 
     * @param {number} [limit] 
     * @param {number} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listMessageReactionsByEmoji(channelId: string, messageId: string, emojiName: string, after?: string, limit?: number, type?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listMessageReactionsByEmoji(channelId, messageId, emojiName, after, limit, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} [around] 
     * @param {string} [before] 
     * @param {string} [after] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listMessages(channelId: string, around?: string, before?: string, after?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listMessages(channelId, around, before, after, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listMyConnections(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listMyConnections(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [before] 
     * @param {string} [after] 
     * @param {number} [limit] 
     * @param {boolean} [withCounts] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listMyGuilds(before?: string, after?: string, limit?: number, withCounts?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listMyGuilds(before, after, limit, withCounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} [before] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listMyPrivateArchivedThreads(channelId: string, before?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listMyPrivateArchivedThreads(channelId, before, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} [before] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listPins(channelId: string, before?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listPins(channelId, before, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} [before] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listPrivateArchivedThreads(channelId: string, before?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listPrivateArchivedThreads(channelId, before, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} [before] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listPublicArchivedThreads(channelId: string, before?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listPublicArchivedThreads(channelId, before, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listStickerPacks(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listStickerPacks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {boolean} [withMember] 
     * @param {number} [limit] 
     * @param {string} [after] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listThreadMembers(channelId: string, withMember?: boolean, limit?: number, after?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listThreadMembers(channelId, withMember, limit, after, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listVoiceRegions(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listVoiceRegions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PartnerSdkUnmergeProvisionalAccountRequest} partnerSdkUnmergeProvisionalAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public partnerSdkToken(partnerSdkUnmergeProvisionalAccountRequest: PartnerSdkUnmergeProvisionalAccountRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).partnerSdkToken(partnerSdkUnmergeProvisionalAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PartnerSdkUnmergeProvisionalAccountRequest} partnerSdkUnmergeProvisionalAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public partnerSdkUnmergeProvisionalAccount(partnerSdkUnmergeProvisionalAccountRequest: PartnerSdkUnmergeProvisionalAccountRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).partnerSdkUnmergeProvisionalAccount(partnerSdkUnmergeProvisionalAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} messageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public pollExpire(channelId: string, messageId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).pollExpire(channelId, messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {number} [days] 
     * @param {GetEntitlementsSkuIdsParameter} [includeRoles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public previewPruneGuild(guildId: string, days?: number, includeRoles?: GetEntitlementsSkuIdsParameter, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).previewPruneGuild(guildId, days, includeRoles, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {PruneGuildRequest} pruneGuildRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public pruneGuild(guildId: string, pruneGuildRequest: PruneGuildRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).pruneGuild(guildId, pruneGuildRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {UpdateGuildOnboardingRequest} updateGuildOnboardingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putGuildsOnboarding(guildId: string, updateGuildOnboardingRequest: UpdateGuildOnboardingRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).putGuildsOnboarding(guildId, updateGuildOnboardingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} limit 
     * @param {string} query 
     * @param {string} guildId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public searchGuildMembers(limit: number, query: string, guildId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).searchGuildMembers(limit, query, guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {SoundboardSoundSendRequest} soundboardSoundSendRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public sendSoundboardSound(channelId: string, soundboardSoundSendRequest: SoundboardSoundSendRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).sendSoundboardSound(channelId, soundboardSoundSendRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} overwriteId 
     * @param {SetChannelPermissionOverwriteRequest} setChannelPermissionOverwriteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setChannelPermissionOverwrite(channelId: string, overwriteId: string, setChannelPermissionOverwriteRequest: SetChannelPermissionOverwriteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setChannelPermissionOverwrite(channelId, overwriteId, setChannelPermissionOverwriteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} guildId 
     * @param {string} commandId 
     * @param {SetGuildApplicationCommandPermissionsRequest} setGuildApplicationCommandPermissionsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setGuildApplicationCommandPermissions(applicationId: string, guildId: string, commandId: string, setGuildApplicationCommandPermissionsRequest: SetGuildApplicationCommandPermissionsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setGuildApplicationCommandPermissions(applicationId, guildId, commandId, setGuildApplicationCommandPermissionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {SetGuildMfaLevelRequest} setGuildMfaLevelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setGuildMfaLevel(guildId: string, setGuildMfaLevelRequest: SetGuildMfaLevelRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setGuildMfaLevel(guildId, setGuildMfaLevelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public syncGuildTemplate(guildId: string, code: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).syncGuildTemplate(guildId, code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} [name] 
     * @param {number} [slop] 
     * @param {string} [minId] 
     * @param {string} [maxId] 
     * @param {ThreadSearchTagParameter} [tag] 
     * @param {string} [tagSetting] 
     * @param {boolean} [archived] 
     * @param {string | null} [sortBy] 
     * @param {string | null} [sortOrder] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public threadSearch(channelId: string, name?: string, slop?: number, minId?: string, maxId?: string, tag?: ThreadSearchTagParameter, tagSetting?: string, archived?: boolean, sortBy?: string | null, sortOrder?: string | null, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).threadSearch(channelId, name, slop, minId, maxId, tag, tagSetting, archived, sortBy, sortOrder, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public triggerTypingIndicator(channelId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).triggerTypingIndicator(channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public unbanUserFromGuild(guildId: string, userId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).unbanUserFromGuild(guildId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {ApplicationFormPartial} applicationFormPartial 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateApplication(applicationId: string, applicationFormPartial: ApplicationFormPartial, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateApplication(applicationId, applicationFormPartial, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} commandId 
     * @param {ApplicationCommandPatchRequestPartial} applicationCommandPatchRequestPartial 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateApplicationCommand(applicationId: string, commandId: string, applicationCommandPatchRequestPartial: ApplicationCommandPatchRequestPartial, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateApplicationCommand(applicationId, commandId, applicationCommandPatchRequestPartial, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} emojiId 
     * @param {UpdateApplicationEmojiRequest} updateApplicationEmojiRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateApplicationEmoji(applicationId: string, emojiId: string, updateApplicationEmojiRequest: UpdateApplicationEmojiRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateApplicationEmoji(applicationId, emojiId, updateApplicationEmojiRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {Array<ApplicationRoleConnectionsMetadataItemRequest> | null} applicationRoleConnectionsMetadataItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateApplicationRoleConnectionsMetadata(applicationId: string, applicationRoleConnectionsMetadataItemRequest: Array<ApplicationRoleConnectionsMetadataItemRequest> | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateApplicationRoleConnectionsMetadata(applicationId, applicationRoleConnectionsMetadataItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {UpdateApplicationUserRoleConnectionRequest} updateApplicationUserRoleConnectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateApplicationUserRoleConnection(applicationId: string, updateApplicationUserRoleConnectionRequest: UpdateApplicationUserRoleConnectionRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateApplicationUserRoleConnection(applicationId, updateApplicationUserRoleConnectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} ruleId 
     * @param {UpdateAutoModerationRuleRequest} updateAutoModerationRuleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateAutoModerationRule(guildId: string, ruleId: string, updateAutoModerationRuleRequest: UpdateAutoModerationRuleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateAutoModerationRule(guildId, ruleId, updateAutoModerationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {UpdateChannelRequest} updateChannelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateChannel(channelId: string, updateChannelRequest: UpdateChannelRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateChannel(channelId, updateChannelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {GuildPatchRequestPartial} guildPatchRequestPartial 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateGuild(guildId: string, guildPatchRequestPartial: GuildPatchRequestPartial, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateGuild(guildId, guildPatchRequestPartial, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} guildId 
     * @param {string} commandId 
     * @param {ApplicationCommandPatchRequestPartial} applicationCommandPatchRequestPartial 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateGuildApplicationCommand(applicationId: string, guildId: string, commandId: string, applicationCommandPatchRequestPartial: ApplicationCommandPatchRequestPartial, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateGuildApplicationCommand(applicationId, guildId, commandId, applicationCommandPatchRequestPartial, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} emojiId 
     * @param {UpdateGuildEmojiRequest} updateGuildEmojiRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateGuildEmoji(guildId: string, emojiId: string, updateGuildEmojiRequest: UpdateGuildEmojiRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateGuildEmoji(guildId, emojiId, updateGuildEmojiRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} userId 
     * @param {UpdateGuildMemberRequest} updateGuildMemberRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateGuildMember(guildId: string, userId: string, updateGuildMemberRequest: UpdateGuildMemberRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateGuildMember(guildId, userId, updateGuildMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} roleId 
     * @param {CreateGuildRoleRequest} createGuildRoleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateGuildRole(guildId: string, roleId: string, createGuildRoleRequest: CreateGuildRoleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateGuildRole(guildId, roleId, createGuildRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} guildScheduledEventId 
     * @param {UpdateGuildScheduledEventRequest} updateGuildScheduledEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateGuildScheduledEvent(guildId: string, guildScheduledEventId: string, updateGuildScheduledEventRequest: UpdateGuildScheduledEventRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateGuildScheduledEvent(guildId, guildScheduledEventId, updateGuildScheduledEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} soundId 
     * @param {SoundboardPatchRequestPartial} soundboardPatchRequestPartial 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateGuildSoundboardSound(guildId: string, soundId: string, soundboardPatchRequestPartial: SoundboardPatchRequestPartial, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateGuildSoundboardSound(guildId, soundId, soundboardPatchRequestPartial, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} stickerId 
     * @param {UpdateGuildStickerRequest} updateGuildStickerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateGuildSticker(guildId: string, stickerId: string, updateGuildStickerRequest: UpdateGuildStickerRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateGuildSticker(guildId, stickerId, updateGuildStickerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} code 
     * @param {UpdateGuildTemplateRequest} updateGuildTemplateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateGuildTemplate(guildId: string, code: string, updateGuildTemplateRequest: UpdateGuildTemplateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateGuildTemplate(guildId, code, updateGuildTemplateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {WelcomeScreenPatchRequestPartial} welcomeScreenPatchRequestPartial 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateGuildWelcomeScreen(guildId: string, welcomeScreenPatchRequestPartial: WelcomeScreenPatchRequestPartial, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateGuildWelcomeScreen(guildId, welcomeScreenPatchRequestPartial, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {UpdateGuildWidgetSettingsRequest} updateGuildWidgetSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateGuildWidgetSettings(guildId: string, updateGuildWidgetSettingsRequest: UpdateGuildWidgetSettingsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateGuildWidgetSettings(guildId, updateGuildWidgetSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {string} messageId 
     * @param {MessageEditRequestPartial} messageEditRequestPartial 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateMessage(channelId: string, messageId: string, messageEditRequestPartial: MessageEditRequestPartial, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateMessage(channelId, messageId, messageEditRequestPartial, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApplicationFormPartial} applicationFormPartial 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateMyApplication(applicationFormPartial: ApplicationFormPartial, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateMyApplication(applicationFormPartial, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {UpdateMyGuildMemberRequest} updateMyGuildMemberRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateMyGuildMember(guildId: string, updateMyGuildMemberRequest: UpdateMyGuildMemberRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateMyGuildMember(guildId, updateMyGuildMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BotAccountPatchRequest} botAccountPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateMyUser(botAccountPatchRequest: BotAccountPatchRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateMyUser(botAccountPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} webhookId 
     * @param {string} webhookToken 
     * @param {IncomingWebhookUpdateRequestPartial} incomingWebhookUpdateRequestPartial 
     * @param {string} [threadId] 
     * @param {boolean} [withComponents] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateOriginalWebhookMessage(webhookId: string, webhookToken: string, incomingWebhookUpdateRequestPartial: IncomingWebhookUpdateRequestPartial, threadId?: string, withComponents?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateOriginalWebhookMessage(webhookId, webhookToken, incomingWebhookUpdateRequestPartial, threadId, withComponents, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {UpdateSelfVoiceStateRequest} updateSelfVoiceStateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateSelfVoiceState(guildId: string, updateSelfVoiceStateRequest: UpdateSelfVoiceStateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateSelfVoiceState(guildId, updateSelfVoiceStateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {UpdateStageInstanceRequest} updateStageInstanceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateStageInstance(channelId: string, updateStageInstanceRequest: UpdateStageInstanceRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateStageInstance(channelId, updateStageInstanceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guildId 
     * @param {string} userId 
     * @param {UpdateVoiceStateRequest} updateVoiceStateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateVoiceState(guildId: string, userId: string, updateVoiceStateRequest: UpdateVoiceStateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateVoiceState(guildId, userId, updateVoiceStateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} webhookId 
     * @param {UpdateWebhookRequest} updateWebhookRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateWebhook(webhookId: string, updateWebhookRequest: UpdateWebhookRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateWebhook(webhookId, updateWebhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} webhookId 
     * @param {string} webhookToken 
     * @param {UpdateWebhookByTokenRequest} updateWebhookByTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateWebhookByToken(webhookId: string, webhookToken: string, updateWebhookByTokenRequest: UpdateWebhookByTokenRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateWebhookByToken(webhookId, webhookToken, updateWebhookByTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} webhookId 
     * @param {string} webhookToken 
     * @param {string} messageId 
     * @param {IncomingWebhookUpdateRequestPartial} incomingWebhookUpdateRequestPartial 
     * @param {string} [threadId] 
     * @param {boolean} [withComponents] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateWebhookMessage(webhookId: string, webhookToken: string, messageId: string, incomingWebhookUpdateRequestPartial: IncomingWebhookUpdateRequestPartial, threadId?: string, withComponents?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateWebhookMessage(webhookId, webhookToken, messageId, incomingWebhookUpdateRequestPartial, threadId, withComponents, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadApplicationAttachment(applicationId: string, file: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadApplicationAttachment(applicationId, file, options).then((request) => request(this.axios, this.basePath));
    }
}



